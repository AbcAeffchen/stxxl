#ifndef SIMDISK_HEADER
#define SIMDISK_HEADER

#include "iobase.h"
#include <sys/mman.h>
#include <unistd.h>
#include <math.h>

namespace io
{

class DiskGeometry
{
  struct Zone {
    // manufactuted data
    //    int last_cyl;
    //    int sect_per_track;
    // derived data
    int first_sector;
    int sectors;
    double sustained_data_rate; // in Mb/s
    Zone(int _first_sector): first_sector(_first_sector) {}; // constructor for zone search

    Zone(//int _last_cyl, 
	 //int _sect_per_track,
	 int _first_sector,
	 int _sectors,
	 double _rate):
        //last_cyl(_last_cyl),
	//	 sect_per_track(_sect_per_track) ,
	 first_sector(_first_sector),
	 sectors(_sectors),
	 sustained_data_rate(_rate) {};
  };
  struct ZoneCmp
  {
    bool operator () (const Zone & a , const Zone & b) const
    {
      return a.first_sector < b.first_sector;
    };
  };

protected:
  int nsurfaces;
  int bytes_per_sector;
  double cmd_ovh; // in s
  double seek_time; // in s
  double rot_latency; // in s
  double head_switch_time; // in s
  double cyl_switch_time; // in s
  double revolution_time; // in s
  double interface_speed; // in byte/s
  set<Zone,ZoneCmp> zones;

  void add_zone(int & first_cyl, int last_cyl,int sec_per_track, int & first_sect)
  {
    double rate = nsurfaces * sec_per_track * bytes_per_sector/
      (  (nsurfaces-1)*head_switch_time + cyl_switch_time +  nsurfaces*revolution_time) ;
    int sectors = (last_cyl - first_cyl + 1) * nsurfaces * sec_per_track;
    zones.insert(Zone(first_sect,sectors,rate));
    first_sect += sectors;
    first_cyl = last_cyl + 1;
  };
public:
  DiskGeometry() {  };
  double get_delay(off_t offset, size_t size) // returns delay in s
    {
      int first_sect = offset/bytes_per_sector;
      int last_sect = (offset + size)/ bytes_per_sector;
      int sectors = size/bytes_per_sector;
      double delay = cmd_ovh + seek_time + rot_latency + double(bytes_per_sector)/double(interface_speed);
      set<Zone,ZoneCmp>::iterator zone = zones.lower_bound(first_sect);
      // cout << __PRETTY_FUNCTION__ << " " << (*zone).first_sector << endl;
      while(1)
	{
	  int from_this_zone = last_sect  - ((*zone).first_sector + (*zone).sectors);
	  if(from_this_zone <= 0)
	  {
	    delay += sectors*bytes_per_sector/((*zone).sustained_data_rate);
	    break;
	  }
	  else
	  {
	    delay+= from_this_zone*bytes_per_sector/((*zone).sustained_data_rate);
	    zone++;
	    mynassert(zone==zones.end());
	    sectors -= from_this_zone;
	  }
	}

      return delay;
    };
  ~DiskGeometry () { };
};


class IC35L080AVVA07: public DiskGeometry // IBM series 120GXP
{
 public:
  IC35L080AVVA07()
    {
      std::cout << "Creating IBM 120GXP IC35L080AVVA07"<< endl;

      nsurfaces=4;
      bytes_per_sector=512;
      cmd_ovh=0.0002; // in s
      seek_time=0.0082; // in s
      rot_latency=0.00417; // in s
      head_switch_time=0.0015; // in s
      cyl_switch_time=0.002; // in s
      revolution_time=0.0083; // in s
      interface_speed=100000000; // in byte/s
      
      int first_sect = 0;
      int last_cyl = 0;
      add_zone(last_cyl,1938,928,first_sect);
      add_zone(last_cyl,3756,921,first_sect);
      add_zone(last_cyl,5564,896,first_sect);
      add_zone(last_cyl,7687,896,first_sect);
      add_zone(last_cyl,9526,888,first_sect);
      add_zone(last_cyl,11334,883,first_sect);
      add_zone(last_cyl,13331,864,first_sect);
      add_zone(last_cyl,15128,850,first_sect);
      add_zone(last_cyl,16925,840,first_sect);
      add_zone(last_cyl,18922,822,first_sect);
      add_zone(last_cyl,20709,806,first_sect);
      add_zone(last_cyl,22601,792,first_sect);
      add_zone(last_cyl,24138,787,first_sect);
      add_zone(last_cyl,26024,768,first_sect);
      add_zone(last_cyl,27652,752,first_sect);
      add_zone(last_cyl,29501,740,first_sect);
      add_zone(last_cyl,31234,725,first_sect);
      add_zone(last_cyl,33009,698,first_sect);
      add_zone(last_cyl,34784,691,first_sect);
      add_zone(last_cyl,36609,672,first_sect);
      add_zone(last_cyl,38374,648,first_sect);
      add_zone(last_cyl,40139,630,first_sect);
      add_zone(last_cyl,41904,614,first_sect);
      add_zone(last_cyl,43519,595,first_sect);
      add_zone(last_cyl,45250,576,first_sect);
      add_zone(last_cyl,47004,552,first_sect);
      add_zone(last_cyl,48758,533,first_sect);
      add_zone(last_cyl,50491,512,first_sect);
      add_zone(last_cyl,52256,493,first_sect);
      add_zone(last_cyl,54010,471,first_sect);
      add_zone(last_cyl,55571,448,first_sect);

      /*
      set<Zone,ZoneCmp>::iterator it=zones.begin();
      int i=0;
      for(;it!=zones.end();it++,i++)
	{
	  //const int block_size = 128*3*1024* 4; // one cylinder

	  cout << "Zone " << i << " first sector: " << (*it).first_sector;
	  cout << " sectors: " << (*it).sectors << " sustained rate: " ;
	  cout << (*it).sustained_data_rate/1000000 << " Mb/s"  << endl;
	
	}


      cout << "Last sector     : " << first_sect <<endl;
      cout << "Approx. capacity: " << (first_sect/1000000)*bytes_per_sector << " Mb" << endl;
      */

      cout <<"Transfer 16 Mb from zone 0 : " << get_delay(0,16*1024*1024) << " s" <<endl;
      cout <<"Transfer 16 Mb from zone 30: " << get_delay(off_t(158204036)*off_t(bytes_per_sector),16*1024*1024)<<" s"<<endl;
    };
};

class SimDiskRequest;

class SimDiskFile: public File, public IC35L080AVVA07
    {
      friend SimDiskRequest;
      off_t disk_size;
      off_t my_page_file_offset;
      static off_t page_file_offset;
    public:

      SimDiskFile(int _disk): File(_disk),disk_size(0)
	{
	};
      virtual void aread(void * buffer, off_t pos, size_t bytes, Request * & req);
      virtual void awrite(void * buffer, off_t pos, size_t bytes, Request * & req);
      virtual void set_size(off_t newsize) // must be called exactly once before all transfer operations
	{
	  if(!disk_size)
	  {
	    disk_size = newsize;
	    my_page_file_offset = page_file_offset;
	    page_file_offset += newsize;
	    cout << "SimDisk "<< disk << " size set to "<< newsize<<" new page_file_offset: "<< page_file_offset<< endl;
	  }
	};
      virtual off_t size() { return disk_size; };
      virtual ~SimDiskFile() {};
    };

  class SimDiskRequest: public Request
    {
      friend class SimDiskFile;
    protected:
      SimDiskFile * file;
      void * buffer;
      off_t offset;
      size_t bytes;
      RequestType type;
      Switch done;
      Mutex waiters_mutex;
      set<Switch *> waiters;

      SimDiskRequest(SimDiskFile * f, void * buf, off_t off, size_t b, RequestType t):
	file(f), buffer(buf), offset(off), bytes(b), type(t), done(false)
      {
	if(type == READ)
	  DiskQueues::get_instance()->add_readreq(this,file->get_disk_number());
	else
	  DiskQueues::get_instance()->add_writereq(this,file->get_disk_number());
      };

    virtual bool add_waiter(Switch * sw)
    {
      waiters_mutex.lock();

      if(done.is_on())
	{
	  mydebug(cout <<"Already done!" << endl;)
	  waiters_mutex.unlock();
	  return true;
	}
      
      waiters.insert(sw);
      waiters_mutex.unlock();

      return false;
    };
    virtual void delete_waiter(Switch * sw)
    {
        waiters_mutex.lock();
        waiters.erase(sw);
        waiters_mutex.unlock();
     };
     int nwaiters()
     {
        waiters_mutex.lock();
        int size = waiters.size();
        waiters_mutex.unlock();
        return size;
      };
      virtual void serve();
      virtual void wait()
      {
        done.wait_for_on();
      };
      virtual bool poll()
      {
        return done.is_on();
      };
      virtual ~SimDiskRequest()
      {
        wait();
      };
    };

  void SimDiskRequest::serve()
    {
      off_t my_offset = file->my_page_file_offset + offset;
      void *mem=mmap(NULL,bytes,PROT_READ | PROT_WRITE, MAP_SHARED|MAP_ANON ,-1, my_offset);
      if(mem == 0 )
	  myfunction_error
      else if(mem == MAP_FAILED)
      {
	  std::cerr << "Mapping failed." << endl;
	  std::cerr << "Page size: " << sysconf(_SC_PAGESIZE) <<" offset modulo page size: " << ( my_offset % sysconf(_SC_PAGESIZE) ) <<endl;
	  abort();
      }
      else
      {
	   if(type==READ)
	   {
	     myifcheck(memcpy(buffer,mem,bytes))
	     else
             myifcheck(munmap((char *)mem,bytes))
	   }
           else
           {
	      myifcheck(memcpy(mem,buffer,bytes))
	      else
              myifcheck(munmap((char *)mem,bytes))
           }
      }

      done.on();

      waiters_mutex.lock();
      // << notification >>
      for(set<Switch *>::iterator i=waiters.begin();i!=waiters.end();i++)
	(*i)->on();
      waiters_mutex.unlock();

      double delay =file->get_delay(offset,bytes);
      int seconds_to_wait = (int)floor(delay);
      //cout <<"Waiting " << delay <<" seconds."<< endl;
      if(seconds_to_wait)
	sleep(seconds_to_wait);

      usleep((unsigned long)((delay-seconds_to_wait)*1000000.));
      
    }

  void SimDiskFile::aread(void * buffer, off_t pos, size_t bytes, Request * & req)
    {
      req = new SimDiskRequest(this,buffer,pos,bytes,Request::READ);
      if(!req)
	myfunction_error;
    };
  void SimDiskFile::awrite(void * buffer, off_t pos, size_t bytes, Request * & req)
    {
      req = new SimDiskRequest(this,buffer,pos,bytes,Request::WRITE);
      if(!req)
	myfunction_error;
    };
  

}


#endif
