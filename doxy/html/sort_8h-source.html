<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: sort.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>sort.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef SORT_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define SORT_HEADER</span>
00003 <span class="preprocessor"></span><span class="comment">/***************************************************************************</span>
00004 <span class="comment"> *            sort.h</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Fri Jan 17 11:26:42 2003</span>
00007 <span class="comment"> *  Copyright  2003  Roman Dementiev</span>
00008 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00009 <span class="comment"> ****************************************************************************/</span>
00010 
00011 <span class="preprocessor">#include &lt;list&gt;</span>
00012 
00013 <span class="preprocessor">#include "../mng/mng.h"</span>
00014 <span class="preprocessor">#include "../common/rand.h"</span>
00015 <span class="preprocessor">#include "../mng/adaptor.h"</span>
00016 <span class="preprocessor">#include "../common/simple_vector.h"</span>
00017 <span class="preprocessor">#include "../common/switch.h"</span>
00018 <span class="preprocessor">#include "interleaved_alloc.h"</span>
00019 <span class="preprocessor">#include "intksort.h"</span>
00020 <span class="preprocessor">#include "adaptor.h"</span>
00021 <span class="preprocessor">#include "async_schedule.h"</span>
00022 <span class="preprocessor">#include "../mng/block_prefetcher.h"</span>
00023 <span class="preprocessor">#include "../mng/buf_writer.h"</span>
00024 <span class="preprocessor">#include "run_cursor.h"</span>
00025 <span class="preprocessor">#include "loosertree.h"</span>
00026 <span class="preprocessor">#include "inmemsort.h"</span>
00027 
00028 <span class="comment">//#define SORT_OPT_PREFETCHING</span>
00029 <span class="comment">//#define INTERLEAVED_ALLOC</span>
00030 
00031 __STXXL_BEGIN_NAMESPACE
00032 
00035 
00036 
<a name="l00039"></a><a class="code" href="namespacestxxl_1_1sort__local.html">00039</a> <span class="keyword">namespace </span>sort_local
00040 {
00041         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIDTp_,<span class="keyword">typename</span> ValTp_&gt;
00042         <span class="keyword">struct </span>trigger_entry
00043         {
00044                 <span class="keyword">typedef</span> BIDTp_ bid_type;
00045                 <span class="keyword">typedef</span> ValTp_ value_type;
00046 
00047                 bid_type bid;
00048                 value_type value;
00049         
00050                 operator bid_type()
00051                 {
00052                         <span class="keywordflow">return</span> bid;
00053                 };
00054         };
00055         
00056         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIDTp_,<span class="keyword">typename</span> ValTp_,<span class="keyword">typename</span> ValueCmp_&gt;
00057         <span class="keyword">struct </span>trigger_entry_cmp
00058         {
00059                 <span class="keyword">typedef</span> trigger_entry&lt;BIDTp_,ValTp_&gt; trigger_entry_type;
00060                 ValueCmp_ cmp;
00061                 trigger_entry_cmp(ValueCmp_ c): cmp(c) { }
00062                 trigger_entry_cmp(<span class="keyword">const</span> trigger_entry_cmp &amp; a): cmp(a.cmp) { }
00063                 <span class="keywordtype">bool</span> operator ()(<span class="keyword">const</span> trigger_entry_type &amp; a,<span class="keyword">const</span> trigger_entry_type &amp; b)<span class="keyword"> const</span>
00064 <span class="keyword">                </span>{
00065                         <span class="keywordflow">return</span> cmp(a.value, b.value);
00066                 };
00067         };
00068         
00069         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> block_type,
00070                                           <span class="keyword">typename</span> prefetcher_type,
00071                                                 <span class="keyword">typename</span> value_cmp&gt;
00072         <span class="keyword">struct </span>run_cursor2_cmp
00073         {
00074                 <span class="keyword">typedef</span> run_cursor2&lt;block_type,prefetcher_type&gt; cursor_type;
00075                 value_cmp cmp;
00076                 
00077                 run_cursor2_cmp(value_cmp c):cmp(c) {   }
00078                 run_cursor2_cmp(<span class="keyword">const</span> run_cursor2_cmp &amp; a):cmp(a.cmp) { }
00079                 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator  () (<span class="keyword">const</span> cursor_type &amp; a, <span class="keyword">const</span> cursor_type &amp; b)
00080                 {
00081                         <span class="keywordflow">if</span> (UNLIKELY (b.empty ()))
00082                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;    <span class="comment">// sentinel emulation</span>
00083                         <span class="keywordflow">if</span> (UNLIKELY (a.empty ()))
00084                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">//sentinel emulation</span>
00085 
00086                         <span class="keywordflow">return</span> (cmp(a.current (),b.current()));
00087                 };
00088         };
00089 
00090         
00091 <span class="keyword">template</span> &lt;
00092                                         <span class="keyword">typename</span> block_type,
00093                                         <span class="keyword">typename</span> run_type,
00094                                         <span class="keyword">typename</span> input_bid_iterator,
00095                                         <span class="keyword">typename</span> value_cmp&gt;
00096 <span class="keywordtype">void</span>
00097 create_runs(
00098                 input_bid_iterator it,
00099                 run_type ** runs,
00100                 <span class="keywordtype">int</span> nruns,
00101                 <span class="keywordtype">int</span> _m,
00102                 value_cmp cmp,
00103     <span class="keywordtype">unsigned</span> _first_element_offset,
00104     <span class="keywordtype">unsigned</span> _last_element_offset)
00105 {
00106         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type type;
00107         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00108         
00109         <span class="keywordtype">int</span> m2 = _m / 2;
00110         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *bm = block_manager::get_instance();
00111         block_type *Blocks1 = <span class="keyword">new</span> block_type[m2];
00112         block_type *Blocks2 = <span class="keyword">new</span> block_type[m2];
00113         <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> * read_reqs1 = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a>[m2];
00114   request_ptr * read_reqs2 = <span class="keyword">new</span> request_ptr[m2];
00115         request_ptr * write_reqs = <span class="keyword">new</span> request_ptr[m2];
00116         bid_type * bids = <span class="keyword">new</span> bid_type[m2];
00117         run_type * run;
00118 
00119         disk_queues::get_instance ()-&gt;set_priority_op(disk_queue::WRITE);
00120 
00121         <span class="keywordtype">int</span> i;
00122         <span class="keywordtype">int</span> k = 0;
00123         <span class="keywordtype">int</span> run_size = 0,next_run_size=0;
00124         
00125         assert(nruns &gt;= 2);
00126   
00127   run = runs[0];
00128         run_size = run-&gt;size ();
00129   <span class="keywordflow">for</span>(i = 0; i &lt; run_size; i++)
00130   {
00131     bids[i] = *(it++);
00132     read_reqs1[i] = Blocks1[i].read(bids[i]);
00133   }
00134   
00135   <span class="keywordflow">for</span> (i = _first_element_offset?1:0; i &lt; run_size; i++)
00136                         bm-&gt;<a class="code" href="group__mnglayer.html#a16">delete_block</a>(bids[i]);
00137   
00138         <span class="keywordflow">for</span>(k=0; k &lt; nruns-1; k++)
00139         {
00140                 run = runs[k];
00141                 run_size = run-&gt;size ();
00142     next_run_size = runs[k+1]-&gt;size();
00143 
00144     <span class="keywordflow">if</span>(_last_element_offset &amp;&amp; k == nruns - 2)
00145     {
00146       <span class="keywordflow">for</span>(i = 1; i &lt; next_run_size; i++)
00147       {
00148           bids[i] = *(it++);
00149           read_reqs2[i] = Blocks2[i].read(bids[i]);
00150       }
00151       
00152       read_reqs2[0] = Blocks2[0].read(*(it++));
00153       
00154       <span class="keywordflow">for</span> (i = 1; i &lt; next_run_size ; i++)
00155         bm-&gt;<a class="code" href="group__mnglayer.html#a16">delete_block</a>(bids[i]);
00156     }
00157     <span class="keywordflow">else</span>
00158     {
00159       <span class="keywordflow">for</span>(i = 0; i &lt; next_run_size; i++)
00160       {
00161           bids[i] = *(it++);
00162           read_reqs2[i] = Blocks2[i].read(bids[i]);
00163       }
00164       <span class="keywordflow">for</span> (i = 0; i &lt; next_run_size; i++)
00165         bm-&gt;<a class="code" href="group__mnglayer.html#a16">delete_block</a>(bids[i]);
00166     }
00167 
00168                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(read_reqs1, run_size);
00169 
00170                 <span class="keywordflow">if</span>(block_type::has_filler)
00171                       <a class="code" href="group__stlalgo.html#a12">std::sort</a>(
00172                               TwoToOneDimArrayRowAdaptor&lt; block_type,
00173                     <span class="keyword">typename</span> block_type::value_type,
00174                     block_type::size &gt; (Blocks1,k?0:_first_element_offset ),
00175                               TwoToOneDimArrayRowAdaptor&lt; block_type,
00176                     <span class="keyword">typename</span> block_type::value_type,block_type::size &gt; (Blocks1, 
00177                     run_size*block_type::size )
00178                               ,cmp);
00179                 <span class="keywordflow">else</span> 
00180                         <a class="code" href="group__stlalgo.html#a12">std::sort</a>(Blocks1[0].elem + (k?0:_first_element_offset), Blocks1[run_size].elem, cmp);
00181 
00182                 <span class="keywordflow">if</span>(k)
00183                         <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs, m2);
00184 
00185                 <span class="keywordflow">for</span> (i = 0; i &lt; m2; i++)
00186                 {
00187                         (*run)[i].value = Blocks1[i][(k?0:_first_element_offset)];
00188                         write_reqs[i] = Blocks1[i].write ((*run)[i].bid);
00189                 }
00190                 std::swap (Blocks1, Blocks2);
00191     std::swap (read_reqs1, read_reqs2);
00192         }
00193 
00194   run = runs[k];
00195         run_size = run-&gt;size ();
00196   <a class="code" href="group__iolayer.html#a3">wait_all</a>(read_reqs1, run_size);
00197   <span class="keywordflow">if</span>(_last_element_offset)
00198   {
00199     memmove(Blocks1[0].elem + block_type::size - _last_element_offset,
00200             Blocks1[0].elem,
00201             _last_element_offset);
00202   }
00203   <span class="keywordflow">if</span>(block_type::has_filler)
00204                       <a class="code" href="group__stlalgo.html#a12">std::sort</a>(  
00205                               TwoToOneDimArrayRowAdaptor&lt; block_type,
00206                     <span class="keyword">typename</span> block_type::value_type,block_type::size &gt; (Blocks1,
00207                         _last_element_offset?(block_type::size - _last_element_offset):0),
00208                               TwoToOneDimArrayRowAdaptor&lt; block_type,
00209                     <span class="keyword">typename</span> block_type::value_type,block_type::size &gt; (Blocks1, 
00210                         run_size*block_type::size ),
00211                         cmp);
00212                 <span class="keywordflow">else</span> 
00213                         <a class="code" href="group__stlalgo.html#a12">std::sort</a>(Blocks1[0].elem + (_last_element_offset?(block_type::size - _last_element_offset):0), 
00214                 Blocks1[run_size].elem, cmp);
00215   
00216   <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs, m2);
00217   <span class="keywordflow">for</span> (i = 0; i &lt; run_size; i++)
00218         {
00219                         (*run)[i].value = Blocks1[i][_last_element_offset?(block_type::size - _last_element_offset):0];
00220                         write_reqs[i] = Blocks1[i].write ((*run)[i].bid);
00221         }
00222         <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs, run_size);
00223 
00224 
00225         <span class="keyword">delete</span> [] Blocks1;
00226         <span class="keyword">delete</span> [] Blocks2;
00227         <span class="keyword">delete</span> [] read_reqs1;
00228   <span class="keyword">delete</span> [] read_reqs2;
00229         <span class="keyword">delete</span> [] write_reqs;
00230         <span class="keyword">delete</span> [] bids;
00231         
00232 }
00233 
00234         
00235         
00236 <span class="keyword">template</span> &lt; <span class="keyword">typename</span> block_type,<span class="keyword">typename</span> run_type , <span class="keyword">typename</span> value_cmp&gt;
00237 <span class="keywordtype">void</span> merge_runs(run_type ** in_runs, <span class="keywordtype">int</span> nruns, run_type * out_run,<span class="keywordtype">unsigned</span>  _m,value_cmp cmp,
00238                 <span class="keywordtype">unsigned</span> _first_element_offset,<span class="keywordtype">unsigned</span> _last_element_offset)
00239 {
00240         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00241         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type value_type;
00242         <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__prefetcher.html">block_prefetcher&lt;block_type,typename run_type::iterator&gt;</a> prefetcher_type;
00243         <span class="keyword">typedef</span> run_cursor2&lt;block_type,prefetcher_type&gt; run_cursor_type;
00244         <span class="keyword">typedef</span> run_cursor2_cmp&lt;block_type,prefetcher_type,value_cmp&gt; run_cursor2_cmp_type;
00245         
00246         <span class="keywordtype">int</span> i;
00247         run_type consume_seq(out_run-&gt;size());
00248 
00249         <span class="keywordtype">int</span> * prefetch_seq = <span class="keyword">new</span> <span class="keywordtype">int</span>[out_run-&gt;size()];
00250 
00251         <span class="keyword">typename</span> run_type::iterator copy_start = consume_seq.begin ();
00252         <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00253         {
00254                 <span class="comment">// TODO: try to avoid copy</span>
00255                 copy_start = std::copy(
00256                                                 in_runs[i]-&gt;begin (),
00257                                                 in_runs[i]-&gt;end (),
00258                                                 copy_start      );
00259         }
00260         
00261         <a class="code" href="group__stlalgo.html#a12">std::sort</a>(consume_seq.begin (), consume_seq.end (),
00262                                         trigger_entry_cmp&lt;bid_type,value_type,value_cmp&gt;(cmp));
00263 
00264         <span class="keywordtype">int</span> disks_number = config::get_instance ()-&gt;disks_number ();
00265         
00266 <span class="preprocessor">        #ifdef PLAY_WITH_OPT_PREF</span>
00267 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">int</span> n_write_buffers = 4 * disks_number;
00268 <span class="preprocessor">        #else</span>
00269 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">int</span> n_prefetch_buffers = std::max( 2 * disks_number , (3 * (<span class="keywordtype">int</span>(_m) - nruns) / 4));
00270         <span class="keyword">const</span> <span class="keywordtype">int</span> n_write_buffers = std::max( 2 * disks_number , <span class="keywordtype">int</span>(_m) - nruns - n_prefetch_buffers );
00271         <span class="comment">// heuristic</span>
00272         <span class="keyword">const</span> <span class="keywordtype">int</span> n_opt_prefetch_buffers = 2 * disks_number + (3*(n_prefetch_buffers - 2 * disks_number))/10;
00273 <span class="preprocessor">        #endif</span>
00274 <span class="preprocessor"></span>        
00275 <span class="preprocessor">        #ifdef SORT_OPT_PREFETCHING</span>
00276 <span class="preprocessor"></span>        compute_prefetch_schedule(
00277                         consume_seq,
00278                         prefetch_seq,
00279                         n_opt_prefetch_buffers,
00280                         disks_number );
00281 <span class="preprocessor">        #else</span>
00282 <span class="preprocessor"></span>        <span class="keywordflow">for</span>(i=0;i&lt;out_run-&gt;size();i++)
00283                 prefetch_seq[i] = i;
00284 <span class="preprocessor">        #endif</span>
00285 <span class="preprocessor"></span>        
00286         prefetcher_type prefetcher(     consume_seq.begin(),
00287                                                                                                                         consume_seq.end(),
00288                                                                                                                         prefetch_seq,
00289                                                                                                                         nruns + n_prefetch_buffers);
00290         
00291         <a class="code" href="classstxxl_1_1buffered__writer.html">buffered_writer&lt;block_type&gt;</a> writer(n_write_buffers,n_write_buffers/2);
00292         
00293         <span class="keywordtype">int</span> out_run_size = out_run-&gt;size ();
00294 
00295         looser_tree&lt;run_cursor_type,
00296                                                         run_cursor2_cmp_type,
00297                                                         block_type::size&gt; loosers (&amp;prefetcher, nruns,run_cursor2_cmp_type(cmp)
00298               );
00299 
00300 
00301         block_type *out_buffer = writer.<a class="code" href="classstxxl_1_1buffered__writer.html#a1">get_free_block</a>();
00302 
00303         <span class="keywordflow">for</span> (i = 0; i &lt; out_run_size; i++)
00304         {
00305                 loosers.multi_merge(out_buffer-&gt;elem);
00306                 (*out_run)[i].value = *(out_buffer-&gt;elem);
00307                 out_buffer = writer.<a class="code" href="classstxxl_1_1buffered__writer.html#a2">write</a>(out_buffer,(*out_run)[i].bid);
00308         }
00309         
00310         <span class="keyword">delete</span> [] prefetch_seq;
00311 
00312         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *bm = block_manager::get_instance ();
00313         <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00314         {
00315                 <span class="keywordtype">unsigned</span> sz = in_runs[i]-&gt;size ();
00316                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; sz; j++)
00317                         bm-&gt;<a class="code" href="group__mnglayer.html#a16">delete_block</a> ((*in_runs[i])[j].bid);
00318         }
00319         
00320 }
00321 
00322 
00323 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> block_type,
00324                                         <span class="keyword">typename</span> alloc_strategy,
00325                                         <span class="keyword">typename</span> input_bid_iterator,
00326                                         <span class="keyword">typename</span> value_cmp&gt;
00327 simple_vector&lt; trigger_entry&lt;typename block_type::bid_type,typename block_type::value_type&gt; &gt; * 
00328         sort_blocks(  input_bid_iterator input_bids,
00329                 <span class="keywordtype">unsigned</span> _n,
00330                 <span class="keywordtype">unsigned</span> _m,
00331                 value_cmp cmp,
00332                 <span class="keywordtype">unsigned</span> _first_element_offset = 0,
00333                 <span class="keywordtype">unsigned</span> _last_element_offset = 0)
00334 {
00335         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type type;
00336         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00337         <span class="keyword">typedef</span> trigger_entry&lt; bid_type,type &gt; trigger_entry_type;
00338         <span class="keyword">typedef</span> simple_vector&lt; trigger_entry_type &gt; run_type;
00339         <span class="keyword">typedef</span> <span class="keyword">typename</span> interleaved_alloc_traits&lt;alloc_strategy&gt;::strategy interleaved_alloc_strategy;
00340         
00341         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m2 = _m / 2;
00342         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> full_runs = _n / m2;
00343         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> partial_runs = ((_n % m2) ? 1 : 0);
00344         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nruns = full_runs + partial_runs;
00345         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00346         
00347         <a class="code" href="classstxxl_1_1config.html">config</a> *cfg = config::get_instance();
00348         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *mng = block_manager::get_instance ();
00349         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ndisks = cfg-&gt;<a class="code" href="classstxxl_1_1config.html#a0">disks_number</a> ();
00350         
00351         <span class="comment">//STXXL_VERBOSE ("n=" &lt;&lt; _n &lt;&lt; " nruns=" &lt;&lt; nruns &lt;&lt; "=" &lt;&lt; full_runs &lt;&lt; "+"</span>
00352         <span class="comment">//         &lt;&lt; partial_runs) </span>
00353         
00354 <span class="preprocessor">#ifdef STXXL_IO_STATS</span>
00355 <span class="preprocessor"></span>        <a class="code" href="classstxxl_1_1stats.html">stats</a> *iostats = stats::get_instance();
00356         iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a7">reset</a>();
00357 <span class="preprocessor">#endif</span>
00358 <span class="preprocessor"></span>        
00359         <span class="keywordtype">double</span> begin = stxxl_timestamp (), after_runs_creation, end;
00360 
00361         run_type **runs = <span class="keyword">new</span> run_type *[nruns];
00362 
00363         <span class="keywordflow">for</span> (i = 0; i &lt; full_runs; i++)
00364                 runs[i] = <span class="keyword">new</span> run_type(m2);
00365 
00366         
00367                 <span class="keywordflow">if</span> (partial_runs)
00368                         runs[i] = <span class="keyword">new</span> run_type (_n - full_runs * m2);
00369                 
00370                 <span class="keywordflow">for</span>(i=0;i&lt;nruns;i++)
00371                 {
00372                         mng-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(        alloc_strategy(0,ndisks),
00373                                                                 trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(runs[i]-&gt;begin()),
00374                                                                 trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(runs[i]-&gt;end())        );
00375                 }
00376         
00377         create_runs&lt; block_type,
00378                                                          run_type,
00379                                                          input_bid_iterator,
00380                                                          value_cmp &gt; (input_bids, runs, nruns,_m,cmp,
00381                             _first_element_offset,_last_element_offset);
00382 
00383         after_runs_creation = stxxl_timestamp ();
00384 
00385 <span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00386 <span class="preprocessor"></span>        <span class="keywordtype">double</span> io_wait_after_rf = stxxl::wait_time_counter;
00387 <span class="preprocessor">#endif</span>
00388 <span class="preprocessor"></span>
00389         disk_queues::get_instance ()-&gt;set_priority_op (disk_queue::WRITE);
00390 
00391         <span class="comment">// Optimal merging: merge r = pow(nruns,1/ceil(log(nruns)/log(m))) at once</span>
00392                 
00393         <span class="keyword">const</span> <span class="keywordtype">int</span> merge_factor = static_cast&lt;int&gt;(ceil(pow(nruns,1./ceil(log(nruns)/log(_m)))));
00394         run_type **new_runs;
00395         
00396         <span class="keywordflow">while</span>(nruns &gt; 1)
00397         {
00398                 <span class="keywordtype">int</span> new_nruns = div_and_round_up(nruns,merge_factor);
00399                 STXXL_VERBOSE(<span class="stringliteral">"Starting new merge phase: nruns: "</span>&lt;&lt;nruns&lt;&lt;
00400                         <span class="stringliteral">" opt_merge_factor: "</span>&lt;&lt;merge_factor&lt;&lt;<span class="stringliteral">" m:"</span>&lt;&lt;_m&lt;&lt;<span class="stringliteral">" new_nruns: "</span>&lt;&lt;new_nruns)
00401                 
00402                 new_runs = <span class="keyword">new</span> run_type *[new_nruns];
00403                 
00404                 <span class="keywordtype">int</span> runs_left = nruns;
00405                 <span class="keywordtype">int</span> cur_out_run = 0;
00406                 <span class="keywordtype">int</span> blocks_in_new_run = 0;
00407                 
00408                 <span class="keywordflow">while</span>(runs_left &gt; 0)
00409                 {
00410                         <span class="keywordtype">int</span> runs2merge = STXXL_MIN(runs_left,merge_factor);
00411                         blocks_in_new_run = 0;
00412                         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = nruns - runs_left; i &lt; (nruns - runs_left + runs2merge);i++)
00413                                 blocks_in_new_run += runs[i]-&gt;size();
00414                         <span class="comment">// allocate run</span>
00415                         new_runs[cur_out_run++] = <span class="keyword">new</span> run_type(blocks_in_new_run);
00416                         runs_left -= runs2merge;
00417                 }
00418                 <span class="comment">// allocate blocks for the new runs</span>
00419                 mng-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>( interleaved_alloc_strategy(new_nruns, 0, ndisks),
00420                                                  RunsToBIDArrayAdaptor2&lt;block_type::raw_size,run_type&gt; (new_runs,0,new_nruns,blocks_in_new_run),
00421                                                  RunsToBIDArrayAdaptor2&lt;block_type::raw_size,run_type&gt; (new_runs,_n,new_nruns,blocks_in_new_run));
00422                 <span class="comment">// merge all</span>
00423                 runs_left = nruns;
00424                 cur_out_run = 0;
00425                 <span class="keywordflow">while</span>(runs_left &gt; 0)
00426                 {
00427                                 <span class="keywordtype">int</span> runs2merge = STXXL_MIN(runs_left,merge_factor);
00428                                 STXXL_VERBOSE(<span class="stringliteral">"Merging "</span>&lt;&lt;runs2merge&lt;&lt;<span class="stringliteral">" runs"</span>)
00429                                 merge_runs&lt;block_type,run_type&gt; (runs + nruns - runs_left, 
00430                                                 runs2merge ,*(new_runs + (cur_out_run++)),_m,cmp,
00431             _first_element_offset,_last_element_offset);
00432                                 runs_left -= runs2merge;
00433                 }
00434                 
00435                 nruns = new_nruns;
00436                 <span class="keyword">delete</span> [] runs;
00437                 runs = new_runs;
00438         }
00439   
00440         run_type * result = *runs;
00441         <span class="keyword">delete</span> [] runs;
00442         
00443         
00444         end = stxxl_timestamp ();
00445   (<span class="keywordtype">void</span>)(begin);
00446 
00447         STXXL_VERBOSE (<span class="stringliteral">"Elapsed time        : "</span> &lt;&lt; end - begin &lt;&lt; <span class="stringliteral">" s. Run creation time: "</span> &lt;&lt; 
00448         after_runs_creation - begin &lt;&lt; <span class="stringliteral">" s"</span>)
00449 #ifdef STXXL_IO_STATS
00450         STXXL_VERBOSE (<span class="stringliteral">"reads               : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a0">get_reads</a> ()) 
00451         STXXL_VERBOSE (<span class="stringliteral">"writes              : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a1">get_writes</a> ())
00452         STXXL_VERBOSE (<span class="stringliteral">"read time           : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a2">get_read_time</a> () &lt;&lt; <span class="stringliteral">" s"</span>) 
00453         STXXL_VERBOSE (<span class="stringliteral">"write time          : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a3">get_write_time</a> () &lt;&lt;<span class="stringliteral">" s"</span>)
00454         STXXL_VERBOSE (<span class="stringliteral">"parallel read time  : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a4">get_pread_time</a> () &lt;&lt; <span class="stringliteral">" s"</span>)
00455         STXXL_VERBOSE (<span class="stringliteral">"parallel write time : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a5">get_pwrite_time</a> () &lt;&lt; <span class="stringliteral">" s"</span>)
00456         STXXL_VERBOSE (<span class="stringliteral">"parallel io time    : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a6">get_pio_time</a> () &lt;&lt; <span class="stringliteral">" s"</span>)
00457 <span class="preprocessor">#endif</span>
00458 <span class="preprocessor"></span><span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00459 <span class="preprocessor"></span>        STXXL_VERBOSE (<span class="stringliteral">"Time in I/O wait(rf): "</span> &lt;&lt; io_wait_after_rf &lt;&lt; <span class="stringliteral">" s"</span>)
00460         STXXL_VERBOSE (<span class="stringliteral">"Time in I/O wait    : "</span> &lt;&lt; stxxl::wait_time_counter &lt;&lt; <span class="stringliteral">" s"</span>)
00461 #endif
00462         
00463         <span class="keywordflow">return</span> result;
00464 }
00465 
00466 };
00467 
00468 
00476 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExtIterator_,<span class="keyword">typename</span> StrictWeakOrdering_&gt;
<a name="l00477"></a><a class="code" href="group__stlalgo.html#a12">00477</a> <span class="keywordtype">void</span> <a class="code" href="group__stlalgo.html#a12">sort</a>(ExtIterator_ first, ExtIterator_ last,StrictWeakOrdering_ cmp,<span class="keywordtype">unsigned</span> M)
00478 {
00479         <span class="keyword">typedef</span> simple_vector&lt; sort_local::trigger_entry&lt;<span class="keyword">typename</span> ExtIterator_::bid_type, 
00480                 <span class="keyword">typename</span> ExtIterator_::vector_type::value_type&gt; &gt; run_type;
00481         
00482         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::vector_type::value_type value_type;
00483         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::block_type block_type;
00484         
00485         <span class="keywordtype">unsigned</span> n=0;
00486         block_manager *mng = block_manager::get_instance ();
00487         
00488         first.flush();
00489         
00490         <span class="keywordflow">if</span>((last - first)*<span class="keyword">sizeof</span>(value_type) &lt; M)
00491         {
00492                 stl_in_memory_sort(first,last,cmp);
00493         }
00494         <span class="keywordflow">else</span>
00495         {
00496                 <span class="keywordflow">if</span>(first.block_offset()) 
00497                 {
00498                         <span class="keywordflow">if</span>(last.block_offset())   <span class="comment">// first and last element are</span>
00499                                                                                                                                 <span class="comment">// not first elemetns of their block</span>
00500                         {
00501                                 <span class="keyword">typename</span> ExtIterator_::block_type * first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00502                                 <span class="keyword">typename</span> ExtIterator_::block_type * last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00503                                 <span class="keyword">typename</span> ExtIterator_::bid_type first_bid,last_bid;
00504                                 request_ptr req;
00505                                 
00506                                 req = first_block-&gt;read(*first.bid());
00507                                 mng-&gt;new_blocks( FR(), &amp;first_bid,(&amp;first_bid) + 1); <span class="comment">// try to overlap</span>
00508                                 mng-&gt;new_blocks( FR(), &amp;last_bid,(&amp;last_bid) + 1);
00509                                 req-&gt;wait();
00510                                 
00511                         
00512                                 req = last_block-&gt;read(*last.bid());
00513                                 
00514                                 <span class="keywordtype">unsigned</span> i=0;
00515                                 <span class="keywordflow">for</span>(;i&lt;first.block_offset();i++)
00516                                 {
00517                                         first_block-&gt;elem[i] = cmp.min_value();
00518                                 }
00519                                 
00520                                 req-&gt;wait();
00521                                 
00522                                 
00523                                 req = first_block-&gt;write(first_bid);
00524                                 <span class="keywordflow">for</span>(i=last.block_offset(); i &lt; block_type::size;i++)
00525                                 {
00526                                         last_block-&gt;elem[i] = cmp.max_value();
00527                                 }
00528                                 
00529                                 req-&gt;wait();
00530                                 
00531                                 
00532                                 req = last_block-&gt;write(last_bid);
00533                                 
00534                                 n=last.bid() - first.bid() + 1;
00535                                 
00536                                 std::swap(first_bid,*first.bid());
00537                                 std::swap(last_bid,*last.bid());
00538                                 
00539                                 req-&gt;wait();
00540                                 
00541                                 
00542                                 <span class="keyword">delete</span> first_block;
00543                                 <span class="keyword">delete</span> last_block;
00544 
00545                                 run_type * out =
00546                                                 sort_local::sort_blocks&lt;        
00547                                                                                                         <span class="keyword">typename</span> ExtIterator_::block_type,
00548                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00549                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator&gt;
00550                                                                                                                  (first.bid(),n,M/block_type::raw_size,cmp);
00551                                         
00552                                 
00553                                 first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00554                                 last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00555                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00556                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00557                                 request_ptr * reqs = <span class="keyword">new</span> request_ptr [2];
00558                                 
00559                                 reqs[0] = first_block-&gt;read(first_bid);
00560                                 reqs[1] = sorted_first_block-&gt;read((*(out-&gt;begin())).bid);
00561                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00562                                 
00563                                 reqs[0] = last_block-&gt;read(last_bid);
00564                                 reqs[1] = sorted_last_block-&gt;read( ((*out)[out-&gt;size() - 1]).bid);
00565                                 
00566                                 <span class="keywordflow">for</span>(i=first.block_offset();i&lt;block_type::size;i++)
00567                                 {
00568                                         first_block-&gt;elem[i] = sorted_first_block-&gt;elem[i];
00569                                 }
00570                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00571                                 
00572                                 req = first_block-&gt;write(first_bid);
00573                                 
00574                                 <span class="keywordflow">for</span>(i=0;i&lt;last.block_offset();i++)
00575                                 {
00576                                         last_block-&gt;elem[i] = sorted_last_block-&gt;elem[i];
00577                                 }
00578                                 
00579                                 req-&gt;wait();
00580                                 
00581                                 req = last_block-&gt;write(last_bid);
00582                                 
00583                                 mng-&gt;delete_block(out-&gt;begin()-&gt;bid);
00584                                 mng-&gt;delete_block((*out)[out-&gt;size() - 1].bid);
00585                                 
00586                                 *first.bid() = first_bid;
00587                                 *last.bid() = last_bid; 
00588                                 
00589                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin(); it++;
00590                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first.bid(); cur_bid ++;
00591                                 
00592                                 <span class="keywordflow">for</span>(;cur_bid != last.bid(); cur_bid++,it++)
00593                                 {
00594                                         *cur_bid = (*it).bid;
00595                                 }
00596                                 
00597                                 <span class="keyword">delete</span> first_block;
00598                                 <span class="keyword">delete</span> sorted_first_block;
00599                                 <span class="keyword">delete</span> sorted_last_block;
00600                                 <span class="keyword">delete</span> [] reqs;
00601                                 <span class="keyword">delete</span> out;
00602                                 
00603                                 req-&gt;wait();
00604                                 
00605                                 
00606                                 <span class="keyword">delete</span> last_block;
00607                         }
00608                         <span class="keywordflow">else</span>
00609                         {
00610                                 <span class="comment">// first element is</span>
00611                                 <span class="comment">// not the first element of its block</span>
00612                                 <span class="keyword">typename</span> ExtIterator_::block_type * first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00613                                 <span class="keyword">typename</span> ExtIterator_::bid_type first_bid;
00614                                 request_ptr req;
00615                                 
00616                                 req = first_block-&gt;read(*first.bid());
00617                                 mng-&gt;new_blocks( FR(), &amp;first_bid,(&amp;first_bid) + 1); <span class="comment">// try to overlap</span>
00618                                 req-&gt;wait();
00619                                 
00620                                 
00621                                 <span class="keywordtype">unsigned</span> i=0;
00622                                 <span class="keywordflow">for</span>(;i&lt;first.block_offset();i++)
00623                                 {
00624                                         first_block-&gt;elem[i] = cmp.min_value();
00625                                 }
00626                                 
00627                                 req = first_block-&gt;write(first_bid);
00628                                 
00629                                 n=last.bid() - first.bid();
00630                                 
00631                                 std::swap(first_bid,*first.bid());
00632                                 
00633                                 req-&gt;wait();
00634                                 
00635                                 
00636                                 <span class="keyword">delete</span> first_block;
00637 
00638                                 run_type * out =
00639                                                 sort_local::sort_blocks&lt;
00640                                                                                                         <span class="keyword">typename</span> ExtIterator_::block_type,
00641                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00642                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator &gt;
00643                                                                                                                  (first.bid(),n,M/block_type::raw_size,cmp);
00644                                         
00645                                 
00646                                 first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00647                                 
00648                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00649         
00650                                 request_ptr * reqs = <span class="keyword">new</span> request_ptr[2];
00651                                 
00652                                 reqs[0] = first_block-&gt;read(first_bid);
00653                                 reqs[1] = sorted_first_block-&gt;read((*(out-&gt;begin())).bid);
00654                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00655                                 
00656                                 <span class="keywordflow">for</span>(i=first.block_offset();i&lt;block_type::size;i++)
00657                                 {
00658                                         first_block-&gt;elem[i] = sorted_first_block-&gt;elem[i];
00659                                 }
00660                                 
00661                                 req = first_block-&gt;write(first_bid);
00662                                 
00663                                 mng-&gt;delete_block(out-&gt;begin()-&gt;bid);
00664                                 
00665                                 *first.bid() = first_bid;
00666                                 
00667                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin(); it++;
00668                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first.bid(); cur_bid ++;
00669                                 
00670                                 <span class="keywordflow">for</span>(;cur_bid != last.bid(); cur_bid++,it++)
00671                                 {
00672                                         *cur_bid = (*it).bid;
00673                                 }
00674                                 
00675                                 *cur_bid = (*it).bid;
00676                                 
00677                                 <span class="keyword">delete</span> sorted_first_block;
00678                                 <span class="keyword">delete</span> [] reqs;
00679                                 <span class="keyword">delete</span> out;
00680                                 
00681                                 req-&gt;wait();
00682                                 
00683                                 <span class="keyword">delete</span> first_block;
00684         
00685                         }
00686                 
00687                 }
00688                 <span class="keywordflow">else</span>
00689                 {
00690                         <span class="keywordflow">if</span>(last.block_offset()) <span class="comment">// last is</span>
00691                                                                                                                                 <span class="comment">// not the first element of its block</span>
00692                         {
00693                                 <span class="keyword">typename</span> ExtIterator_::block_type * last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00694                                 <span class="keyword">typename</span> ExtIterator_::bid_type last_bid;
00695                                 request_ptr req;
00696                                 <span class="keywordtype">unsigned</span> i;
00697                                 
00698                                 req = last_block-&gt;read(*last.bid());
00699                                 mng-&gt;new_blocks( FR(), &amp;last_bid,(&amp;last_bid) + 1);
00700                                 req-&gt;wait();
00701                                 
00702                         
00703                                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=last.block_offset(); i &lt; block_type::size;i++)
00704                                 {
00705                                         last_block-&gt;elem[i] = cmp.max_value();
00706                                 }
00707                                 
00708                                 req = last_block-&gt;write(last_bid);
00709                                 
00710                                 n=last.bid() - first.bid() + 1;
00711                                 
00712                                 std::swap(last_bid,*last.bid());
00713                                 
00714                                 req-&gt;wait();
00715                                 
00716                                 
00717                                 <span class="keyword">delete</span> last_block;
00718 
00719                                 run_type * out =
00720                                                 sort_local::sort_blocks&lt;        
00721                                                                                                         <span class="keyword">typename</span> ExtIterator_::block_type,
00722                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00723                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator&gt;
00724                                                                                                                  (first.bid(),n,M/block_type::raw_size,cmp);
00725                                         
00726                                 
00727                                 last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00728                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00729                                 request_ptr * reqs = <span class="keyword">new</span> request_ptr [2];
00730                                 
00731                                 reqs[0] = last_block-&gt;read(last_bid);
00732                                 reqs[1] = sorted_last_block-&gt;read( ((*out)[out-&gt;size() - 1]).bid);
00733                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00734                                 
00735                                 <span class="keywordflow">for</span>(i=0;i&lt;last.block_offset();i++)
00736                                 {
00737                                         last_block-&gt;elem[i] = sorted_last_block-&gt;elem[i];
00738                                 }
00739                                 
00740                                 req = last_block-&gt;write(last_bid);
00741                                 
00742                                 mng-&gt;delete_block((*out)[out-&gt;size() - 1].bid);
00743                                 
00744                                 *last.bid() = last_bid; 
00745                                 
00746                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin();
00747                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first.bid();
00748                                 
00749                                 <span class="keywordflow">for</span>(;cur_bid != last.bid(); cur_bid++,it++)
00750                                 {
00751                                         *cur_bid = (*it).bid;
00752                                 }
00753                                 
00754                                 <span class="keyword">delete</span> sorted_last_block;
00755                                 <span class="keyword">delete</span> [] reqs;
00756                                 <span class="keyword">delete</span> out;
00757                                 
00758                                 req-&gt;wait();
00759                                 
00760                                 <span class="keyword">delete</span> last_block;
00761                         }
00762                         <span class="keywordflow">else</span>
00763                         {
00764                                 <span class="comment">// first and last element are first elements of their of blocks </span>
00765                                 n = last.bid() - first.bid();
00766                                 
00767                                 run_type * out =
00768                                                 sort_local::sort_blocks&lt;        <span class="keyword">typename</span> ExtIterator_::block_type,
00769                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00770                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator &gt;
00771                                                                                                                  (first.bid(),n,M/block_type::raw_size,cmp);
00772                                 
00773                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin();
00774                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first.bid();
00775                                 
00776                                 <span class="keywordflow">for</span>(;cur_bid != last.bid(); cur_bid++,it++)
00777                                 {
00778                                         *cur_bid = (*it).bid;
00779                                 }
00780                                 
00781                         }
00782                 }
00783         }
00784 };
00785 
00787 
00788 __STXXL_END_NAMESPACE
00789 
00790 
00791 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Nov 21 15:28:12 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
