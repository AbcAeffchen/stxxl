<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>sort.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>sort.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef SORT_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define SORT_HEADER</span>
00003 <span class="preprocessor"></span><span class="comment">/***************************************************************************</span>
00004 <span class="comment"> *            sort.h</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Fri Jan 17 11:26:42 2003</span>
00007 <span class="comment"> *  Copyright  2003  Roman Dementiev</span>
00008 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00009 <span class="comment"> ****************************************************************************/</span>
00010 
00011 <span class="preprocessor">#include &lt;list&gt;</span>
00012 
00013 <span class="preprocessor">#include "../mng/mng.h"</span>
00014 <span class="preprocessor">#include "../common/rand.h"</span>
00015 <span class="preprocessor">#include "../mng/adaptor.h"</span>
00016 <span class="preprocessor">#include "../common/simple_vector.h"</span>
00017 <span class="preprocessor">#include "../common/switch.h"</span>
00018 <span class="preprocessor">#include "interleaved_alloc.h"</span>
00019 <span class="preprocessor">#include "intksort.h"</span>
00020 <span class="preprocessor">#include "adaptor.h"</span>
00021 <span class="preprocessor">#include "async_schedule.h"</span>
00022 <span class="preprocessor">#include "../mng/block_prefetcher.h"</span>
00023 <span class="preprocessor">#include "../mng/buf_writer.h"</span>
00024 <span class="preprocessor">#include "run_cursor.h"</span>
00025 <span class="preprocessor">#include "loosertree.h"</span>
00026 <span class="preprocessor">#include "inmemsort.h"</span>
00027 
00028 <span class="comment">//#define SORT_OPT_PREFETCHING</span>
00029 <span class="comment">//#define INTERLEAVED_ALLOC</span>
00030 
00031 __STXXL_BEGIN_NAMESPACE
00032 
00035 
00036 
00038 <span class="keyword">namespace </span>sort_local
00039 {
00040         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIDTp_,<span class="keyword">typename</span> ValTp_&gt;
00041         <span class="keyword">struct </span>trigger_entry
00042         {
00043                 <span class="keyword">typedef</span> BIDTp_ bid_type;
00044                 <span class="keyword">typedef</span> ValTp_ value_type;
00045 
00046                 bid_type bid;
00047                 value_type value;
00048         
00049                 operator bid_type()
00050                 {
00051                         <span class="keywordflow">return</span> bid;
00052                 };
00053         };
00054         
00055         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIDTp_,<span class="keyword">typename</span> ValTp_,<span class="keyword">typename</span> ValueCmp_&gt;
00056         <span class="keyword">struct </span>trigger_entry_cmp
00057         {
00058                 <span class="keyword">typedef</span> trigger_entry&lt;BIDTp_,ValTp_&gt; trigger_entry_type;
00059                 ValueCmp_ cmp;
00060                 trigger_entry_cmp(ValueCmp_ c): cmp(c) { }
00061                 trigger_entry_cmp(<span class="keyword">const</span> trigger_entry_cmp &amp; a): cmp(a.cmp) { }
00062                 <span class="keywordtype">bool</span> operator ()(<span class="keyword">const</span> trigger_entry_type &amp; a,<span class="keyword">const</span> trigger_entry_type &amp; b)<span class="keyword"> const</span>
00063 <span class="keyword">                </span>{
00064                         <span class="keywordflow">return</span> cmp(a.value, b.value);
00065                 };
00066         };
00067         
00068         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> block_type,
00069                                           <span class="keyword">typename</span> prefetcher_type,
00070                                                 <span class="keyword">typename</span> value_cmp&gt;
00071         <span class="keyword">struct </span>run_cursor2_cmp
00072         {
00073                 <span class="keyword">typedef</span> run_cursor2&lt;block_type,prefetcher_type&gt; cursor_type;
00074                 value_cmp cmp;
00075                 
00076                 run_cursor2_cmp(value_cmp c):cmp(c) {   }
00077                 run_cursor2_cmp(<span class="keyword">const</span> run_cursor2_cmp &amp; a):cmp(a.cmp) { }
00078                 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator  () (<span class="keyword">const</span> cursor_type &amp; a, <span class="keyword">const</span> cursor_type &amp; b)
00079                 {
00080                         <span class="keywordflow">if</span> (UNLIKELY (b.empty ()))
00081                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;    <span class="comment">// sentinel emulation</span>
00082                         <span class="keywordflow">if</span> (UNLIKELY (a.empty ()))
00083                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">//sentinel emulation</span>
00084 
00085                         <span class="keywordflow">return</span> (cmp(a.current (),b.current()));
00086                 };
00087         };
00088 
00089         
00090 <span class="keyword">template</span> &lt;
00091                                         <span class="keyword">typename</span> block_type,
00092                                         <span class="keyword">typename</span> run_type,
00093                                         <span class="keyword">typename</span> input_bid_iterator,
00094                                         <span class="keyword">typename</span> value_cmp&gt;
00095 <span class="keywordtype">void</span>
00096 create_runs(
00097                 input_bid_iterator it,
00098                 run_type ** runs,
00099                 <span class="keywordtype">int</span> nruns,
00100                 <span class="keywordtype">int</span> _m,
00101                 value_cmp cmp,
00102     <span class="keywordtype">unsigned</span> _first_element_offset,
00103     <span class="keywordtype">unsigned</span> _last_element_offset)
00104 {
00105         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type type;
00106         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00107         
00108         <span class="keywordtype">int</span> m2 = _m / 2;
00109         block_manager *bm = block_manager::get_instance ();
00110         block_type *Blocks1 = <span class="keyword">new</span> block_type[m2];
00111         block_type *Blocks2 = <span class="keyword">new</span> block_type[m2];
00112         request_ptr * read_reqs1 = <span class="keyword">new</span> request_ptr[m2];
00113   request_ptr * read_reqs2 = <span class="keyword">new</span> request_ptr[m2];
00114         request_ptr * write_reqs = <span class="keyword">new</span> request_ptr[m2];
00115         bid_type * bids = <span class="keyword">new</span> bid_type[m2];
00116         run_type * run;
00117 
00118         <span class="comment">//  STXXL_VERBOSE("Creating runs")</span>
00119         disk_queues::get_instance ()-&gt;set_priority_op(disk_queue::WRITE);
00120 
00121         <span class="keywordtype">int</span> i;
00122         <span class="keywordtype">int</span> k = 0;
00123         <span class="keywordtype">int</span> run_size = 0,next_run_size=0;
00124         
00125         assert(nruns &gt;= 2);
00126   
00127   run = runs[0];
00128         run_size = run-&gt;size ();
00129   <span class="keywordflow">for</span>(i = 0; i &lt; run_size; i++)
00130   {
00131     bids[i] = *(it++);
00132     read_reqs1[i] = Blocks1[i].read(bids[i]);
00133   }
00134   
00135   <span class="keywordflow">for</span> (i = _first_element_offset?1:0; i &lt; run_size; i++)
00136                         bm-&gt;delete_block(bids[i]);
00137   
00138         <span class="keywordflow">for</span>(k=0; k &lt; nruns-1; k++)
00139         {
00140                 run = runs[k];
00141                 run_size = run-&gt;size ();
00142     next_run_size = runs[k+1]-&gt;size();
00143 
00144     <span class="keywordflow">if</span>(_last_element_offset &amp;&amp; k == nruns - 2)
00145     {
00146       <span class="keywordflow">for</span>(i = 1; i &lt; next_run_size; i++)
00147       {
00148           bids[i] = *(it++);
00149           read_reqs2[i] = Blocks2[i].read(bids[i]);
00150       }
00151       
00152       read_reqs2[0] = Blocks2[0].read(*(it++));
00153       
00154       <span class="keywordflow">for</span> (i = 1; i &lt; next_run_size ; i++)
00155         bm-&gt;delete_block(bids[i]);
00156     }
00157     <span class="keywordflow">else</span>
00158     {
00159       <span class="keywordflow">for</span>(i = 0; i &lt; next_run_size; i++)
00160       {
00161           bids[i] = *(it++);
00162           read_reqs2[i] = Blocks2[i].read(bids[i]);
00163       }
00164       <span class="keywordflow">for</span> (i = 0; i &lt; next_run_size; i++)
00165         bm-&gt;delete_block(bids[i]);
00166     }
00167 
00168                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(read_reqs1, run_size);
00169 
00170                 <span class="keywordflow">if</span>(block_type::has_filler)
00171                       <a class="code" href="group__stlalgo.html#a12">std::sort</a>(
00172                               TwoToOneDimArrayRowAdaptor&lt; block_type,
00173                     <span class="keyword">typename</span> block_type::value_type,block_type::size &gt; (Blocks1,k?0:_first_element_offset ),
00174                               TwoToOneDimArrayRowAdaptor&lt; block_type,
00175                     <span class="keyword">typename</span> block_type::value_type,block_type::size &gt; (Blocks1, run_size*block_type::size )
00176                               ,cmp);
00177                 <span class="keywordflow">else</span> 
00178                         <a class="code" href="group__stlalgo.html#a12">std::sort</a>(Blocks1[0].elem + (k?0:_first_element_offset), Blocks1[run_size].elem, cmp);
00179 
00180                 <span class="keywordflow">if</span>(k)
00181                         <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs, m2);
00182 
00183                 <span class="keywordflow">for</span> (i = 0; i &lt; m2; i++)
00184                 {
00185                         (*run)[i].value = Blocks1[i][(k?0:_first_element_offset)];
00186                         write_reqs[i] = Blocks1[i].write ((*run)[i].bid);
00187                 }
00188                 std::swap (Blocks1, Blocks2);
00189     std::swap (read_reqs1, read_reqs2);
00190         }
00191 
00192   run = runs[k];
00193         run_size = run-&gt;size ();
00194   <a class="code" href="group__iolayer.html#a3">wait_all</a>(read_reqs1, run_size);
00195   <span class="keywordflow">if</span>(_last_element_offset)
00196   {
00197     memmove(Blocks1[0].elem + block_type::size - _last_element_offset,
00198             Blocks1[0].elem,
00199             _last_element_offset);
00200   }
00201   <span class="keywordflow">if</span>(block_type::has_filler)
00202                       <a class="code" href="group__stlalgo.html#a12">std::sort</a>(  
00203                               TwoToOneDimArrayRowAdaptor&lt; block_type,
00204                     <span class="keyword">typename</span> block_type::value_type,block_type::size &gt; (Blocks1,
00205                         _last_element_offset?(block_type::size - _last_element_offset):0),
00206                               TwoToOneDimArrayRowAdaptor&lt; block_type,
00207                     <span class="keyword">typename</span> block_type::value_type,block_type::size &gt; (Blocks1, 
00208                         run_size*block_type::size ),
00209                         cmp);
00210                 <span class="keywordflow">else</span> 
00211                         <a class="code" href="group__stlalgo.html#a12">std::sort</a>(Blocks1[0].elem + (_last_element_offset?(block_type::size - _last_element_offset):0), 
00212                 Blocks1[run_size].elem, cmp);
00213   
00214   <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs, m2);
00215   <span class="keywordflow">for</span> (i = 0; i &lt; run_size; i++)
00216         {
00217                         (*run)[i].value = Blocks1[i][_last_element_offset?(block_type::size - _last_element_offset):0];
00218                         write_reqs[i] = Blocks1[i].write ((*run)[i].bid);
00219         }
00220         <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs, run_size);
00221 
00222 
00223         <span class="keyword">delete</span> [] Blocks1;
00224         <span class="keyword">delete</span> [] Blocks2;
00225         <span class="keyword">delete</span> [] read_reqs1;
00226   <span class="keyword">delete</span> [] read_reqs2;
00227         <span class="keyword">delete</span> [] write_reqs;
00228         <span class="keyword">delete</span> [] bids;
00229         
00230 }
00231 
00232         
00233         
00234 <span class="keyword">template</span> &lt; <span class="keyword">typename</span> block_type,<span class="keyword">typename</span> run_type , <span class="keyword">typename</span> value_cmp&gt;
00235 <span class="keywordtype">void</span> merge_runs(run_type ** in_runs, <span class="keywordtype">int</span> nruns, run_type * out_run,<span class="keywordtype">unsigned</span>  _m,value_cmp cmp,
00236                 <span class="keywordtype">unsigned</span> _first_element_offset,<span class="keywordtype">unsigned</span> _last_element_offset)
00237 {
00238         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00239         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type value_type;
00240         <span class="keyword">typedef</span> block_prefetcher&lt;block_type,typename run_type::iterator&gt; prefetcher_type;
00241         <span class="keyword">typedef</span> run_cursor2&lt;block_type,prefetcher_type&gt; run_cursor_type;
00242         <span class="keyword">typedef</span> run_cursor2_cmp&lt;block_type,prefetcher_type,value_cmp&gt; run_cursor2_cmp_type;
00243         
00244         <span class="keywordtype">int</span> i;
00245         run_type consume_seq(out_run-&gt;size());
00246 
00247         <span class="keywordtype">int</span> * prefetch_seq = <span class="keyword">new</span> <span class="keywordtype">int</span>[out_run-&gt;size()];
00248 
00249         <span class="keyword">typename</span> run_type::iterator copy_start = consume_seq.begin ();
00250         <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00251         {
00252                 <span class="comment">// TODO: try to avoid copy</span>
00253                 copy_start = std::copy(
00254                                                 in_runs[i]-&gt;begin (),
00255                                                 in_runs[i]-&gt;end (),
00256                                                 copy_start      );
00257         }
00258         
00259         <a class="code" href="group__stlalgo.html#a12">std::sort</a>(consume_seq.begin (), consume_seq.end (),
00260                                         trigger_entry_cmp&lt;bid_type,value_type,value_cmp&gt;(cmp));
00261 
00262         <span class="keywordtype">int</span> disks_number = config::get_instance ()-&gt;disks_number ();
00263         
00264 <span class="preprocessor">        #ifdef PLAY_WITH_OPT_PREF</span>
00265 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">int</span> n_write_buffers = 4 * disks_number;
00266 <span class="preprocessor">        #else</span>
00267 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">int</span> n_prefetch_buffers = std::max( 2 * disks_number , (3 * (<span class="keywordtype">int</span>(_m) - nruns) / 4));
00268         <span class="keyword">const</span> <span class="keywordtype">int</span> n_write_buffers = std::max( 2 * disks_number , <span class="keywordtype">int</span>(_m) - nruns - n_prefetch_buffers );
00269         <span class="comment">// heuristic</span>
00270         <span class="keyword">const</span> <span class="keywordtype">int</span> n_opt_prefetch_buffers = 2 * disks_number + (3*(n_prefetch_buffers - 2 * disks_number))/10;
00271 <span class="preprocessor">        #endif</span>
00272 <span class="preprocessor"></span>        
00273 <span class="preprocessor">        #ifdef SORT_OPT_PREFETCHING</span>
00274 <span class="preprocessor"></span>        compute_prefetch_schedule(
00275                         consume_seq,
00276                         prefetch_seq,
00277                         n_opt_prefetch_buffers,
00278                         disks_number );
00279 <span class="preprocessor">        #else</span>
00280 <span class="preprocessor"></span>        <span class="keywordflow">for</span>(i=0;i&lt;out_run-&gt;size();i++)
00281                 prefetch_seq[i] = i;
00282 <span class="preprocessor">        #endif</span>
00283 <span class="preprocessor"></span>        
00284         prefetcher_type prefetcher(     consume_seq.begin(),
00285                                                                                                                         consume_seq.end(),
00286                                                                                                                         prefetch_seq,
00287                                                                                                                         nruns + n_prefetch_buffers);
00288         
00289         buffered_writer&lt;block_type&gt; writer(n_write_buffers,n_write_buffers/2);
00290         
00291         <span class="keywordtype">int</span> out_run_size = out_run-&gt;size ();
00292 
00293         looser_tree&lt;run_cursor_type,
00294                                                         run_cursor2_cmp_type,
00295                                                         block_type::size&gt; loosers (&amp;prefetcher, nruns,run_cursor2_cmp_type(cmp)
00296               );
00297 
00298 
00299         block_type *out_buffer = writer.get_free_block();
00300 
00301         <span class="keywordflow">for</span> (i = 0; i &lt; out_run_size; i++)
00302         {
00303                 loosers.multi_merge(out_buffer-&gt;elem);
00304                 (*out_run)[i].value = *(out_buffer-&gt;elem);
00305                 out_buffer = writer.write(out_buffer,(*out_run)[i].bid);
00306         }
00307         
00308         <span class="keyword">delete</span> [] prefetch_seq;
00309 
00310         block_manager *bm = block_manager::get_instance ();
00311         <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00312         {
00313                 <span class="keywordtype">unsigned</span> sz = in_runs[i]-&gt;size ();
00314                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; sz; j++)
00315                         bm-&gt;delete_block ((*in_runs[i])[j].bid);
00316         }
00317         
00318 }
00319 
00320 
00321 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> block_type,
00322                                         <span class="keyword">typename</span> alloc_strategy,
00323                                         <span class="keyword">typename</span> input_bid_iterator,
00324                                         <span class="keyword">typename</span> value_cmp&gt;
00325 simple_vector&lt; trigger_entry&lt;typename block_type::bid_type,typename block_type::value_type&gt; &gt; * 
00326         sort_blocks(  input_bid_iterator input_bids,
00327                 <span class="keywordtype">unsigned</span> _n,
00328                 <span class="keywordtype">unsigned</span> _m,
00329                 value_cmp cmp,
00330                 <span class="keywordtype">unsigned</span> _first_element_offset = 0,
00331                 <span class="keywordtype">unsigned</span> _last_element_offset = 0)
00332 {
00333         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type type;
00334         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00335         <span class="keyword">typedef</span> trigger_entry&lt; bid_type,type &gt; trigger_entry_type;
00336         <span class="keyword">typedef</span> simple_vector&lt; trigger_entry_type &gt; run_type;
00337         <span class="keyword">typedef</span> <span class="keyword">typename</span> interleaved_alloc_traits&lt;alloc_strategy&gt;::strategy interleaved_alloc_strategy;
00338         
00339         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m2 = _m / 2;
00340         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> full_runs = _n / m2;
00341         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> partial_runs = ((_n % m2) ? 1 : 0);
00342         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nruns = full_runs + partial_runs;
00343         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00344         
00345         config *cfg = config::get_instance();
00346         block_manager *mng = block_manager::get_instance ();
00347         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ndisks = cfg-&gt;disks_number ();
00348         
00349         <span class="comment">//STXXL_VERBOSE ("n=" &lt;&lt; _n &lt;&lt; " nruns=" &lt;&lt; nruns &lt;&lt; "=" &lt;&lt; full_runs &lt;&lt; "+"</span>
00350         <span class="comment">//         &lt;&lt; partial_runs) </span>
00351         
00352 <span class="preprocessor">#ifdef STXXL_IO_STATS</span>
00353 <span class="preprocessor"></span>        stats *iostats = stats::get_instance();
00354         iostats-&gt;reset();
00355 <span class="preprocessor">#endif</span>
00356 <span class="preprocessor"></span>        
00357         <span class="keywordtype">double</span> begin = stxxl_timestamp (), after_runs_creation, end;
00358 
00359         run_type **runs = <span class="keyword">new</span> run_type *[nruns];
00360 
00361         <span class="keywordflow">for</span> (i = 0; i &lt; full_runs; i++)
00362                 runs[i] = <span class="keyword">new</span> run_type(m2);
00363 
00364         
00365                 <span class="keywordflow">if</span> (partial_runs)
00366                         runs[i] = <span class="keyword">new</span> run_type (_n - full_runs * m2);
00367                 
00368                 <span class="keywordflow">for</span>(i=0;i&lt;nruns;i++)
00369                 {
00370                         mng-&gt;new_blocks(        alloc_strategy(0,ndisks),
00371                                                                                                 trigger_entry_iterator&lt;trigger_entry_type,block_type::raw_size&gt;(runs[i]-&gt;begin()),
00372                                                                                                 trigger_entry_iterator&lt;trigger_entry_type,block_type::raw_size&gt;(runs[i]-&gt;end()) );
00373                 }
00374         
00375         create_runs&lt; block_type,
00376                                                          run_type,
00377                                                          input_bid_iterator,
00378                                                          value_cmp &gt; (input_bids, runs, nruns,_m,cmp,
00379                             _first_element_offset,_last_element_offset);
00380 
00381         after_runs_creation = stxxl_timestamp ();
00382 
00383 <span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00384 <span class="preprocessor"></span>        <span class="keywordtype">double</span> io_wait_after_rf = stxxl::wait_time_counter;
00385 <span class="preprocessor">#endif</span>
00386 <span class="preprocessor"></span>
00387         disk_queues::get_instance ()-&gt;set_priority_op (disk_queue::WRITE);
00388 
00389         <span class="comment">// Optimal merging: merge r = pow(nruns,1/ceil(log(nruns)/log(m))) at once</span>
00390                 
00391         <span class="keyword">const</span> <span class="keywordtype">int</span> merge_factor = static_cast&lt;int&gt;(ceil(pow(nruns,1./ceil(log(nruns)/log(_m)))));
00392         run_type **new_runs;
00393         
00394         <span class="keywordflow">while</span>(nruns &gt; 1)
00395         {
00396                 <span class="keywordtype">int</span> new_nruns = div_and_round_up(nruns,merge_factor);
00397                 STXXL_VERBOSE(<span class="stringliteral">"Starting new merge phase: nruns: "</span>&lt;&lt;nruns&lt;&lt;
00398                         <span class="stringliteral">" opt_merge_factor: "</span>&lt;&lt;merge_factor&lt;&lt;<span class="stringliteral">" m:"</span>&lt;&lt;_m&lt;&lt;<span class="stringliteral">" new_nruns: "</span>&lt;&lt;new_nruns)
00399                 
00400                 new_runs = <span class="keyword">new</span> run_type *[new_nruns];
00401                 
00402                 <span class="keywordtype">int</span> runs_left = nruns;
00403                 <span class="keywordtype">int</span> cur_out_run = 0;
00404                 <span class="keywordtype">int</span> blocks_in_new_run = 0;
00405                 
00406                 <span class="keywordflow">while</span>(runs_left &gt; 0)
00407                 {
00408                         <span class="keywordtype">int</span> runs2merge = STXXL_MIN(runs_left,merge_factor);
00409                         blocks_in_new_run = 0;
00410                         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = nruns - runs_left; i &lt; (nruns - runs_left + runs2merge);i++)
00411                                 blocks_in_new_run += runs[i]-&gt;size();
00412                         <span class="comment">// allocate run</span>
00413                         new_runs[cur_out_run++] = <span class="keyword">new</span> run_type(blocks_in_new_run);
00414                         runs_left -= runs2merge;
00415                 }
00416                 <span class="comment">// allocate blocks in the new runs</span>
00417                 mng-&gt;new_blocks( interleaved_alloc_strategy(new_nruns, 0, ndisks),
00418                                                  RunsToBIDArrayAdaptor2&lt;block_type::raw_size,run_type&gt; (new_runs,0,new_nruns,blocks_in_new_run),
00419                                                  RunsToBIDArrayAdaptor2&lt;block_type::raw_size,run_type&gt; (new_runs,_n,new_nruns,blocks_in_new_run));
00420                 <span class="comment">// merge all</span>
00421                 runs_left = nruns;
00422                 cur_out_run = 0;
00423                 <span class="keywordflow">while</span>(runs_left &gt; 0)
00424                 {
00425                                 <span class="keywordtype">int</span> runs2merge = STXXL_MIN(runs_left,merge_factor);
00426                                 STXXL_VERBOSE(<span class="stringliteral">"Merging "</span>&lt;&lt;runs2merge&lt;&lt;<span class="stringliteral">" runs"</span>)
00427                                 merge_runs&lt;block_type,run_type&gt; (runs + nruns - runs_left, 
00428                                                 runs2merge ,*(new_runs + (cur_out_run++)),_m,cmp,
00429             _first_element_offset,_last_element_offset);
00430                                 runs_left -= runs2merge;
00431                 }
00432                 
00433                 nruns = new_nruns;
00434                 <span class="keyword">delete</span> [] runs;
00435                 runs = new_runs;
00436         }
00437   
00438         run_type * result = *runs;
00439         <span class="keyword">delete</span> [] runs;
00440         
00441         
00442         end = stxxl_timestamp ();
00443   (void)(begin);
00444 
00445         STXXL_VERBOSE (<span class="stringliteral">"Elapsed time        : "</span> &lt;&lt; end - begin &lt;&lt; <span class="stringliteral">" s. Run creation time: "</span> &lt;&lt; 
00446         after_runs_creation - begin &lt;&lt; <span class="stringliteral">" s"</span>)
00447 #ifdef STXXL_IO_STATS
00448         STXXL_VERBOSE (<span class="stringliteral">"reads               : "</span> &lt;&lt; iostats-&gt;get_reads ()) 
00449         STXXL_VERBOSE (<span class="stringliteral">"writes              : "</span> &lt;&lt; iostats-&gt;get_writes ())
00450         STXXL_VERBOSE (<span class="stringliteral">"read time           : "</span> &lt;&lt; iostats-&gt;get_read_time () &lt;&lt; <span class="stringliteral">" s"</span>) 
00451         STXXL_VERBOSE (<span class="stringliteral">"write time          : "</span> &lt;&lt; iostats-&gt;get_write_time () &lt;&lt;<span class="stringliteral">" s"</span>)
00452         STXXL_VERBOSE (<span class="stringliteral">"parallel read time  : "</span> &lt;&lt; iostats-&gt;get_pread_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00453         STXXL_VERBOSE (<span class="stringliteral">"parallel write time : "</span> &lt;&lt; iostats-&gt;get_pwrite_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00454         STXXL_VERBOSE (<span class="stringliteral">"parallel io time    : "</span> &lt;&lt; iostats-&gt;get_pio_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00455 <span class="preprocessor">#endif</span>
00456 <span class="preprocessor"></span><span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00457 <span class="preprocessor"></span>        STXXL_VERBOSE (<span class="stringliteral">"Time in I/O wait(rf): "</span> &lt;&lt; io_wait_after_rf &lt;&lt; <span class="stringliteral">" s"</span>)
00458         STXXL_VERBOSE (<span class="stringliteral">"Time in I/O wait    : "</span> &lt;&lt; stxxl::wait_time_counter &lt;&lt; <span class="stringliteral">" s"</span>)
00459 #endif
00460         
00461         <span class="keywordflow">return</span> result;
00462 }
00463 
00464 };
00465 
00466 
<a name="l00475"></a><a class="code" href="group__stlalgo.html#a12">00475</a> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExtIterator_,<span class="keyword">typename</span> StrictWeakOrdering_&gt;
00476 <span class="keywordtype">void</span> <a class="code" href="group__stlalgo.html#a12">sort</a>(ExtIterator_ first, ExtIterator_ last,StrictWeakOrdering_ cmp,<span class="keywordtype">unsigned</span> M)
00477 {
00478         <span class="keyword">typedef</span> simple_vector&lt; sort_local::trigger_entry&lt;<span class="keyword">typename</span> ExtIterator_::bid_type, 
00479                 <span class="keyword">typename</span> ExtIterator_::vector_type::value_type&gt; &gt; run_type;
00480         
00481         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::vector_type::value_type value_type;
00482         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::block_type block_type;
00483         
00484         <span class="keywordtype">unsigned</span> n=0;
00485         block_manager *mng = block_manager::get_instance ();
00486         
00487         first.flush();
00488         
00489         <span class="keywordflow">if</span>((last - first)*<span class="keyword">sizeof</span>(value_type) &lt; M)
00490         {
00491                 stl_in_memory_sort(first,last,cmp);
00492         }
00493         <span class="keywordflow">else</span>
00494         {
00495                 <span class="keywordflow">if</span>(first.block_offset()) 
00496                 {
00497                         <span class="keywordflow">if</span>(last.block_offset())   <span class="comment">// first and last element are</span>
00498                                                                                                                                 <span class="comment">// not first elemetns of their block</span>
00499                         {
00500                                 <span class="keyword">typename</span> ExtIterator_::block_type * first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00501                                 <span class="keyword">typename</span> ExtIterator_::block_type * last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00502                                 <span class="keyword">typename</span> ExtIterator_::bid_type first_bid,last_bid;
00503                                 request_ptr req;
00504                                 
00505                                 req = first_block-&gt;read(*first.bid());
00506                                 mng-&gt;new_blocks( FR(), &amp;first_bid,(&amp;first_bid) + 1); <span class="comment">// try to overlap</span>
00507                                 mng-&gt;new_blocks( FR(), &amp;last_bid,(&amp;last_bid) + 1);
00508                                 req-&gt;wait();
00509                                 
00510                         
00511                                 req = last_block-&gt;read(*last.bid());
00512                                 
00513                                 <span class="keywordtype">unsigned</span> i=0;
00514                                 <span class="keywordflow">for</span>(;i&lt;first.block_offset();i++)
00515                                 {
00516                                         first_block-&gt;elem[i] = cmp.min_value();
00517                                 }
00518                                 
00519                                 req-&gt;wait();
00520                                 
00521                                 
00522                                 req = first_block-&gt;write(first_bid);
00523                                 <span class="keywordflow">for</span>(i=last.block_offset(); i &lt; block_type::size;i++)
00524                                 {
00525                                         last_block-&gt;elem[i] = cmp.max_value();
00526                                 }
00527                                 
00528                                 req-&gt;wait();
00529                                 
00530                                 
00531                                 req = last_block-&gt;write(last_bid);
00532                                 
00533                                 n=last.bid() - first.bid() + 1;
00534                                 
00535                                 std::swap(first_bid,*first.bid());
00536                                 std::swap(last_bid,*last.bid());
00537                                 
00538                                 req-&gt;wait();
00539                                 
00540                                 
00541                                 <span class="keyword">delete</span> first_block;
00542                                 <span class="keyword">delete</span> last_block;
00543 
00544                                 run_type * out =
00545                                                 sort_local::sort_blocks&lt;        
00546                                                                                                         <span class="keyword">typename</span> ExtIterator_::block_type,
00547                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00548                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator&gt;
00549                                                                                                                  (first.bid(),n,M/block_type::raw_size,cmp);
00550                                         
00551                                 
00552                                 first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00553                                 last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00554                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00555                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00556                                 request_ptr * reqs = <span class="keyword">new</span> request_ptr [2];
00557                                 
00558                                 reqs[0] = first_block-&gt;read(first_bid);
00559                                 reqs[1] = sorted_first_block-&gt;read((*(out-&gt;begin())).bid);
00560                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00561                                 
00562                                 reqs[0] = last_block-&gt;read(last_bid);
00563                                 reqs[1] = sorted_last_block-&gt;read( ((*out)[out-&gt;size() - 1]).bid);
00564                                 
00565                                 <span class="keywordflow">for</span>(i=first.block_offset();i&lt;block_type::size;i++)
00566                                 {
00567                                         first_block-&gt;elem[i] = sorted_first_block-&gt;elem[i];
00568                                 }
00569                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00570                                 
00571                                 req = first_block-&gt;write(first_bid);
00572                                 
00573                                 <span class="keywordflow">for</span>(i=0;i&lt;last.block_offset();i++)
00574                                 {
00575                                         last_block-&gt;elem[i] = sorted_last_block-&gt;elem[i];
00576                                 }
00577                                 
00578                                 req-&gt;wait();
00579                                 
00580                                 req = last_block-&gt;write(last_bid);
00581                                 
00582                                 mng-&gt;delete_block(out-&gt;begin()-&gt;bid);
00583                                 mng-&gt;delete_block((*out)[out-&gt;size() - 1].bid);
00584                                 
00585                                 *first.bid() = first_bid;
00586                                 *last.bid() = last_bid; 
00587                                 
00588                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin(); it++;
00589                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first.bid(); cur_bid ++;
00590                                 
00591                                 <span class="keywordflow">for</span>(;cur_bid != last.bid(); cur_bid++,it++)
00592                                 {
00593                                         *cur_bid = (*it).bid;
00594                                 }
00595                                 
00596                                 <span class="keyword">delete</span> first_block;
00597                                 <span class="keyword">delete</span> sorted_first_block;
00598                                 <span class="keyword">delete</span> sorted_last_block;
00599                                 <span class="keyword">delete</span> [] reqs;
00600                                 <span class="keyword">delete</span> out;
00601                                 
00602                                 req-&gt;wait();
00603                                 
00604                                 
00605                                 <span class="keyword">delete</span> last_block;
00606                         }
00607                         <span class="keywordflow">else</span>
00608                         {
00609                                 <span class="comment">// first element is</span>
00610                                 <span class="comment">// not the first element of its block</span>
00611                                 <span class="keyword">typename</span> ExtIterator_::block_type * first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00612                                 <span class="keyword">typename</span> ExtIterator_::bid_type first_bid;
00613                                 request_ptr req;
00614                                 
00615                                 req = first_block-&gt;read(*first.bid());
00616                                 mng-&gt;new_blocks( FR(), &amp;first_bid,(&amp;first_bid) + 1); <span class="comment">// try to overlap</span>
00617                                 req-&gt;wait();
00618                                 
00619                                 
00620                                 <span class="keywordtype">unsigned</span> i=0;
00621                                 <span class="keywordflow">for</span>(;i&lt;first.block_offset();i++)
00622                                 {
00623                                         first_block-&gt;elem[i] = cmp.min_value();
00624                                 }
00625                                 
00626                                 req = first_block-&gt;write(first_bid);
00627                                 
00628                                 n=last.bid() - first.bid();
00629                                 
00630                                 std::swap(first_bid,*first.bid());
00631                                 
00632                                 req-&gt;wait();
00633                                 
00634                                 
00635                                 <span class="keyword">delete</span> first_block;
00636 
00637                                 run_type * out =
00638                                                 sort_local::sort_blocks&lt;
00639                                                                                                         <span class="keyword">typename</span> ExtIterator_::block_type,
00640                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00641                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator &gt;
00642                                                                                                                  (first.bid(),n,M/block_type::raw_size,cmp);
00643                                         
00644                                 
00645                                 first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00646                                 
00647                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00648         
00649                                 request_ptr * reqs = <span class="keyword">new</span> request_ptr[2];
00650                                 
00651                                 reqs[0] = first_block-&gt;read(first_bid);
00652                                 reqs[1] = sorted_first_block-&gt;read((*(out-&gt;begin())).bid);
00653                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00654                                 
00655                                 <span class="keywordflow">for</span>(i=first.block_offset();i&lt;block_type::size;i++)
00656                                 {
00657                                         first_block-&gt;elem[i] = sorted_first_block-&gt;elem[i];
00658                                 }
00659                                 
00660                                 req = first_block-&gt;write(first_bid);
00661                                 
00662                                 mng-&gt;delete_block(out-&gt;begin()-&gt;bid);
00663                                 
00664                                 *first.bid() = first_bid;
00665                                 
00666                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin(); it++;
00667                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first.bid(); cur_bid ++;
00668                                 
00669                                 <span class="keywordflow">for</span>(;cur_bid != last.bid(); cur_bid++,it++)
00670                                 {
00671                                         *cur_bid = (*it).bid;
00672                                 }
00673                                 
00674                                 *cur_bid = (*it).bid;
00675                                 
00676                                 <span class="keyword">delete</span> sorted_first_block;
00677                                 <span class="keyword">delete</span> [] reqs;
00678                                 <span class="keyword">delete</span> out;
00679                                 
00680                                 req-&gt;wait();
00681                                 
00682                                 <span class="keyword">delete</span> first_block;
00683         
00684                         }
00685                 
00686                 }
00687                 <span class="keywordflow">else</span>
00688                 {
00689                         <span class="keywordflow">if</span>(last.block_offset()) <span class="comment">// last is</span>
00690                                                                                                                                 <span class="comment">// not the first element of its block</span>
00691                         {
00692                                 <span class="keyword">typename</span> ExtIterator_::block_type * last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00693                                 <span class="keyword">typename</span> ExtIterator_::bid_type last_bid;
00694                                 request_ptr req;
00695                                 <span class="keywordtype">unsigned</span> i;
00696                                 
00697                                 req = last_block-&gt;read(*last.bid());
00698                                 mng-&gt;new_blocks( FR(), &amp;last_bid,(&amp;last_bid) + 1);
00699                                 req-&gt;wait();
00700                                 
00701                         
00702                                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=last.block_offset(); i &lt; block_type::size;i++)
00703                                 {
00704                                         last_block-&gt;elem[i] = cmp.max_value();
00705                                 }
00706                                 
00707                                 req = last_block-&gt;write(last_bid);
00708                                 
00709                                 n=last.bid() - first.bid() + 1;
00710                                 
00711                                 std::swap(last_bid,*last.bid());
00712                                 
00713                                 req-&gt;wait();
00714                                 
00715                                 
00716                                 <span class="keyword">delete</span> last_block;
00717 
00718                                 run_type * out =
00719                                                 sort_local::sort_blocks&lt;        
00720                                                                                                         <span class="keyword">typename</span> ExtIterator_::block_type,
00721                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00722                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator&gt;
00723                                                                                                                  (first.bid(),n,M/block_type::raw_size,cmp);
00724                                         
00725                                 
00726                                 last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00727                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00728                                 request_ptr * reqs = <span class="keyword">new</span> request_ptr [2];
00729                                 
00730                                 reqs[0] = last_block-&gt;read(last_bid);
00731                                 reqs[1] = sorted_last_block-&gt;read( ((*out)[out-&gt;size() - 1]).bid);
00732                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00733                                 
00734                                 <span class="keywordflow">for</span>(i=0;i&lt;last.block_offset();i++)
00735                                 {
00736                                         last_block-&gt;elem[i] = sorted_last_block-&gt;elem[i];
00737                                 }
00738                                 
00739                                 req = last_block-&gt;write(last_bid);
00740                                 
00741                                 mng-&gt;delete_block((*out)[out-&gt;size() - 1].bid);
00742                                 
00743                                 *last.bid() = last_bid; 
00744                                 
00745                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin();
00746                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first.bid();
00747                                 
00748                                 <span class="keywordflow">for</span>(;cur_bid != last.bid(); cur_bid++,it++)
00749                                 {
00750                                         *cur_bid = (*it).bid;
00751                                 }
00752                                 
00753                                 <span class="keyword">delete</span> sorted_last_block;
00754                                 <span class="keyword">delete</span> [] reqs;
00755                                 <span class="keyword">delete</span> out;
00756                                 
00757                                 req-&gt;wait();
00758                                 
00759                                 <span class="keyword">delete</span> last_block;
00760                         }
00761                         <span class="keywordflow">else</span>
00762                         {
00763                                 <span class="comment">// first and last element are first elements of their of blocks </span>
00764                                 n = last.bid() - first.bid();
00765                                 
00766                                 run_type * out =
00767                                                 sort_local::sort_blocks&lt;        <span class="keyword">typename</span> ExtIterator_::block_type,
00768                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00769                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator &gt;
00770                                                                                                                  (first.bid(),n,M/block_type::raw_size,cmp);
00771                                 
00772                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin();
00773                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first.bid();
00774                                 
00775                                 <span class="keywordflow">for</span>(;cur_bid != last.bid(); cur_bid++,it++)
00776                                 {
00777                                         *cur_bid = (*it).bid;
00778                                 }
00779                                 
00780                         }
00781                 }
00782         }
00783 };
00784 
00786 
00787 __STXXL_END_NAMESPACE
00788 
00789 
00790 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Jul 1 11:08:36 2003 for &lt;stxxl&gt; by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
