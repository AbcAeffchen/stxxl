<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ksort.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>ksort.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef KSORT_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define KSORT_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            ksort.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Fri Oct  4 19:18:04 2002</span>
00008 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 <span class="preprocessor">#include &lt;list&gt;</span>
00013 
00014 <span class="preprocessor">#include "../mng/mng.h"</span>
00015 <span class="preprocessor">#include "../common/rand.h"</span>
00016 <span class="preprocessor">#include "../mng/adaptor.h"</span>
00017 <span class="preprocessor">#include "../common/simple_vector.h"</span>
00018 <span class="preprocessor">#include "../common/switch.h"</span>
00019 <span class="preprocessor">#include "interleaved_alloc.h"</span>
00020 <span class="preprocessor">#include "intksort.h"</span>
00021 <span class="preprocessor">#include "adaptor.h"</span>
00022 <span class="preprocessor">#include "async_schedule.h"</span>
00023 <span class="preprocessor">#include "../mng/block_prefetcher.h"</span>
00024 <span class="preprocessor">#include "../mng/buf_writer.h"</span>
00025 <span class="preprocessor">#include "run_cursor.h"</span>
00026 <span class="preprocessor">#include "loosertree.h"</span>
00027 <span class="preprocessor">#include "inmemsort.h"</span>
00028 
00029 <span class="comment">//#define SORT_OPT_PREFETCHING</span>
00030 <span class="comment">//#define INTERLEAVED_ALLOC</span>
00031 
00032 <span class="preprocessor">#define OPT_MERGING</span>
00033 <span class="preprocessor"></span>
00034 __STXXL_BEGIN_NAMESPACE
00035 
00038 
00043 
00044 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _BIDTp,<span class="keyword">typename</span> _KeyTp&gt;
00045 <span class="keyword">struct </span>trigger_entry
00046 {
00047         <span class="keyword">typedef</span> _BIDTp bid_type;
00048         <span class="keyword">typedef</span> _KeyTp key_type;
00049 
00050         bid_type bid;
00051         key_type key;
00052         
00053         operator bid_type()
00054         {
00055                 <span class="keywordflow">return</span> bid;
00056         };
00057 };
00058 
00059 
00060 
00061 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _BIDTp,<span class="keyword">typename</span> _KeyTp&gt;
00062 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt; (const trigger_entry&lt;_BIDTp,_KeyTp&gt; &amp; a, 
00063                                                                                                 <span class="keyword">const</span> trigger_entry&lt;_BIDTp,_KeyTp&gt; &amp; b)
00064 {
00065         <span class="keywordflow">return</span> (a.key &lt; b.key);
00066 };
00067 
00068 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _BIDTp,<span class="keyword">typename</span> _KeyTp&gt;
00069 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt; (<span class="keyword">const</span> trigger_entry&lt;_BIDTp,_KeyTp&gt; &amp; a,
00070                                                                                                 <span class="keyword">const</span> trigger_entry&lt;_BIDTp,_KeyTp&gt; &amp; b)
00071 {
00072         <span class="keywordflow">return</span> (a.key &gt; b.key);
00073 };
00074 
00075 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00076 <span class="keyword">struct </span>type_key
00077 {
00078         <span class="keyword">typedef</span> <span class="keyword">typename</span> type::key_type key_type;
00079         key_type key;
00080         type * ptr;
00081         
00082         type_key() {};
00083         type_key(key_type k, type * p):key (k), ptr (p)
00084         {
00085         };
00086 };
00087 
00088 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00089 <span class="keywordtype">bool</span> operator  &lt; (const type_key&lt;type&gt; &amp; a, <span class="keyword">const</span> type_key&lt;type&gt; &amp; b)
00090 {
00091                 <span class="keywordflow">return</span> a.key &lt; b.key;
00092 }
00093 
00094 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00095 <span class="keywordtype">bool</span> operator  &gt; (<span class="keyword">const</span> type_key&lt;type&gt; &amp; a, <span class="keyword">const</span> type_key&lt;type&gt; &amp; b)
00096 {
00097                 <span class="keywordflow">return</span> a.key &gt; b.key;
00098 }
00099 
00100 
00101 
00102 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> block_type,<span class="keyword">typename</span> bid_type&gt;
00103 <span class="keyword">struct </span>write_completion_handler
00104 {
00105         block_type * block;
00106         bid_type bid;
00107         request_ptr * req;
00108         <span class="keywordtype">void</span> operator () (request * completed_req)
00109         {
00110                 *req = block-&gt;read(bid);
00111         }
00112 };
00113 
00114 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_key_,
00115                                         <span class="keyword">typename</span> block_type,
00116                                         <span class="keyword">typename</span> run_type,
00117                                         <span class="keyword">typename</span> input_bid_iterator,
00118                                         <span class="keyword">typename</span> key_extractor&gt;
00119 <span class="keyword">inline</span> <span class="keywordtype">void</span> write_out(
00120                                         type_key_ *begin,
00121                                         type_key_ * end,
00122                                         block_type *&amp; cur_blk,
00123                                         <span class="keyword">const</span> block_type * end_blk,
00124                                         <span class="keywordtype">int</span> &amp; out_block,
00125                                         <span class="keywordtype">int</span> &amp; out_pos,
00126                                         run_type &amp; run,
00127                                         write_completion_handler&lt;block_type,typename block_type::bid_type&gt; *&amp; next_read,
00128                                         request_ptr * write_reqs,
00129                                         request_ptr * read_reqs,
00130                                         input_bid_iterator &amp; it,
00131                                         key_extractor keyobj)
00132 {
00133         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00134         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::type type;
00135         
00136         block_manager *bm = block_manager::get_instance ();
00137         type * elem = cur_blk-&gt;elem;
00138         <span class="keywordflow">for</span> (type_key_ * p = begin; p &lt; end; p++)
00139         {
00140                 elem[out_pos++] = *(p-&gt;ptr);
00141                 
00142                 <span class="keywordflow">if</span> (out_pos &gt;= block_type::size)
00143                 {
00144                         run[out_block].key = keyobj(*(cur_blk-&gt;elem));
00145                         
00146                         <span class="keywordflow">if</span> (cur_blk &lt; end_blk)
00147                         {
00148                                         next_read-&gt;block = cur_blk;
00149                                         next_read-&gt;req = read_reqs + out_block;
00150                                         read_reqs[out_block] = NULL;
00151                                         bm-&gt;delete_block( next_read-&gt;bid = *(it++) );
00152                                                                                                                                                                                                                                                                 
00153                                         write_reqs[out_block] = cur_blk-&gt;write (        
00154                                                         run[out_block].bid,
00155                                                                           <span class="comment">// postpone read of block from next run</span>
00156                                                         *(next_read++));  <span class="comment">// after write of block from this run</span>
00157                                         
00158                         }
00159                         <span class="keywordflow">else</span>
00160                         {
00161                                 write_reqs[out_block] = cur_blk-&gt;write (run[out_block].bid);
00162                         }
00163                                                                                 
00164                         cur_blk++;
00165                         elem = cur_blk-&gt;elem;
00166                         out_block++;
00167                         out_pos = 0;
00168                 }
00169         }
00170 }
00171 
00172 <span class="keyword">template</span> &lt;
00173                                         <span class="keyword">typename</span> block_type,
00174                                         <span class="keyword">typename</span> run_type,
00175                                         <span class="keyword">typename</span> input_bid_iterator,
00176                                         <span class="keyword">typename</span> key_extractor&gt;
00177 <span class="keywordtype">void</span>
00178 create_runs(
00179                 input_bid_iterator it,
00180                 run_type ** runs,
00181                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nruns,
00182                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> m2,
00183                 key_extractor keyobj)
00184 {
00185         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type type;
00186         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00187         <span class="keyword">typedef</span> type_key&lt;type&gt; type_key_;
00188         <span class="keyword">typedef</span> <span class="keyword">typename</span> type_key_::key_type key_type;
00189         
00190         block_manager *bm = block_manager::get_instance ();
00191         block_type *Blocks1 = <span class="keyword">new</span> block_type[m2];
00192         block_type *Blocks2 = <span class="keyword">new</span> block_type[m2];
00193         type_key_ *refs1 = <span class="keyword">new</span> type_key_[m2 * Blocks1-&gt;size];
00194         type_key_ *refs2 = <span class="keyword">new</span> type_key_[m2 * Blocks1-&gt;size];
00195         request_ptr * read_reqs = <span class="keyword">new</span> request_ptr[m2];
00196         request_ptr * write_reqs = <span class="keyword">new</span> request_ptr[m2];
00197         write_completion_handler&lt;block_type,bid_type&gt; * next_run_reads = 
00198                 <span class="keyword">new</span> write_completion_handler&lt;block_type,bid_type&gt;[m2];
00199         
00200         run_type *run;
00201         run = *runs;
00202         <span class="keywordtype">int</span> run_size = (*runs)-&gt;size ();
00203         key_type offset = 0;
00204         <span class="keyword">const</span> <span class="keywordtype">int</span> log_k1 = static_cast&lt;int&gt;(ceil(log2(m2 * block_type::size * <span class="keyword">sizeof</span>(type_key_)/STXXL_L2_SIZE)));
00205         <span class="keyword">const</span> <span class="keywordtype">int</span> log_k2 = int(log2(m2 * Blocks1-&gt;size)) - log_k1 - 1;
00206         STXXL_VERBOSE(<span class="stringliteral">"log_k1: "</span>&lt;&lt;log_k1&lt;&lt;<span class="stringliteral">" log_k2:"</span>&lt;&lt;log_k2)
00207         <span class="keyword">const</span> <span class="keywordtype">int</span> k1 = 1 &lt;&lt; log_k1;
00208         <span class="keyword">const</span> <span class="keywordtype">int</span> k2 = 1 &lt;&lt; log_k2;
00209         <span class="keywordtype">int</span> *bucket1 = <span class="keyword">new</span> <span class="keywordtype">int</span>[k1];
00210         <span class="keywordtype">int</span> *bucket2 = <span class="keyword">new</span> <span class="keywordtype">int</span>[k2];
00211         <span class="keywordtype">int</span> i;
00212         
00213         disk_queues::get_instance ()-&gt;set_priority_op (disk_queue::WRITE);
00214         
00215         <span class="keywordflow">for</span> (i = 0; i &lt; run_size; i++)
00216         {
00217                 bid_type bid = *(it++);
00218                 read_reqs[i] = Blocks1[i].read(bid);
00219                 bm-&gt;delete_block(bid);
00220         }
00221         
00222         <span class="keywordtype">unsigned</span> k = 0;
00223         <span class="keyword">const</span> <span class="keywordtype">int</span> shift1 = <span class="keyword">sizeof</span>(<span class="keyword">typename</span> block_type::value_type::key_type)*8 - log_k1;
00224         <span class="keyword">const</span> <span class="keywordtype">int</span> shift2 = shift1 - log_k2;
00225 
00226         <span class="keywordflow">for</span> (; k &lt; nruns; k++)
00227         {
00228                 run = runs[k];
00229                 run_size = run-&gt;size ();
00230                 
00231                 std::fill(bucket1,bucket1 + k1,0);
00232 
00233                 type_key_ * ref_ptr = refs1;
00234                 <span class="keywordflow">for</span> (i = 0; i &lt; run_size; i++)
00235                 {
00236                         <span class="keywordflow">if</span>(k)
00237                                 write_reqs[i]-&gt;wait();
00238         
00239                         read_reqs[i]-&gt;wait();
00240 
00241                         classify_block(Blocks1[i].begin(),Blocks1[i].end(),ref_ptr,bucket1,offset,shift1,keyobj);
00242                 }
00243                                 
00244                 exclusive_prefix_sum(bucket1, k1);
00245                 classify(refs1, refs1 + run_size * Blocks1-&gt;size, refs2, bucket1,
00246                           offset, shift1);
00247                 
00248                 <span class="keywordtype">int</span> out_block = 0;
00249                 <span class="keywordtype">int</span> out_pos = 0;
00250                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> next_run_size = (k &lt; nruns - 1)?(runs[k + 1]-&gt;size ()):0;
00251                 
00252                 <span class="comment">// recurse on each bucket</span>
00253                 type_key_ *c = refs2;
00254                 type_key_ *d = refs1;
00255                 block_type *cur_blk = Blocks2;
00256                 block_type *end_blk = Blocks2 + next_run_size;
00257                 write_completion_handler&lt;block_type,bid_type&gt; * next_read = next_run_reads;
00258                 
00259                 <span class="keywordflow">for</span> (i = 0; i &lt; k1; i++)
00260                 {
00261                         type_key_ *cEnd = refs2 + bucket1[i];
00262                         type_key_ *dEnd = refs1 + bucket1[i];
00263                         
00264                         l1sort(c, cEnd, d, bucket2, k2,
00265                                 offset + (key_type(1)&lt;&lt;key_type(shift1)) * key_type(i) , shift2); <span class="comment">// key_type,key_type,... paranoia </span>
00266                         
00267                         write_out(
00268                                                         d,dEnd,cur_blk,end_blk,
00269                                                         out_block,out_pos,*run,next_read,
00270                                                         write_reqs,read_reqs,it,keyobj);
00271                         
00272                         c = cEnd;
00273                         d = dEnd;
00274                 }
00275 
00276                 std::swap (Blocks1, Blocks2);
00277         }
00278         
00279         <a class="code" href="group__iolayer.html#a3">wait_all</a> (write_reqs, m2);
00280 
00281         <span class="keyword">delete</span> [] bucket1;
00282         <span class="keyword">delete</span> [] bucket2;
00283         <span class="keyword">delete</span> [] refs1;
00284         <span class="keyword">delete</span> [] refs2;
00285         <span class="keyword">delete</span> [] Blocks1;
00286         <span class="keyword">delete</span> [] Blocks2;
00287         <span class="keyword">delete</span> [] next_run_reads;
00288         <span class="keyword">delete</span> [] read_reqs;
00289         <span class="keyword">delete</span> [] write_reqs;
00290 }
00291 
00292 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> block_type,
00293                                         <span class="keyword">typename</span> prefetcher_type,
00294                                         <span class="keyword">typename</span> key_extractor&gt;
00295 <span class="keyword">struct </span>run_cursor2_cmp
00296 {
00297         <span class="keyword">typedef</span> run_cursor2&lt;block_type,prefetcher_type&gt; cursor_type;
00298         key_extractor keyobj;
00299         run_cursor2_cmp(key_extractor keyobj_) { keyobj = keyobj_; }
00300         <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator  () (<span class="keyword">const</span> cursor_type &amp; a, <span class="keyword">const</span> cursor_type &amp; b)
00301         {
00302                 <span class="keywordflow">if</span> (UNLIKELY (b.empty ()))
00303                         <span class="keywordflow">return</span> <span class="keyword">true</span>;    <span class="comment">// sentinel emulation</span>
00304                 <span class="keywordflow">if</span> (UNLIKELY (a.empty ()))
00305                         <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">//sentinel emulation</span>
00306 
00307                 <span class="keywordflow">return</span> (keyobj(a.current()) &lt; keyobj(b.current ()));
00308         };
00309         <span class="keyword">private</span>:
00310         run_cursor2_cmp() {};
00311 };
00312 
00313 
00314 <span class="comment">//#include "loosertree.h"</span>
00315 
00316 <span class="keyword">template</span> &lt; <span class="keyword">typename</span> block_type,<span class="keyword">typename</span> run_type, <span class="keyword">typename</span> key_extractor&gt;
00317 <span class="keywordtype">void</span> merge_runs(run_type ** in_runs, <span class="keywordtype">unsigned</span> nruns, run_type * out_run,<span class="keywordtype">unsigned</span>  _m, key_extractor keyobj)
00318 {
00319         <span class="keyword">typedef</span> block_prefetcher&lt;block_type,typename run_type::iterator&gt; prefetcher_type;
00320         <span class="keyword">typedef</span> run_cursor2&lt;block_type,prefetcher_type&gt; run_cursor_type;
00321         
00322         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00323         run_type consume_seq(out_run-&gt;size());
00324 
00325         <span class="keywordtype">int</span> * prefetch_seq = <span class="keyword">new</span> <span class="keywordtype">int</span>[out_run-&gt;size()];
00326 
00327         <span class="keyword">typename</span> run_type::iterator copy_start = consume_seq.begin ();
00328         <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00329         {
00330                 <span class="comment">// TODO: try to avoid copy</span>
00331                 copy_start = std::copy(
00332                                                 in_runs[i]-&gt;begin (),
00333                                                 in_runs[i]-&gt;end (),
00334                                                 copy_start      );
00335         }
00336         <a class="code" href="group__stlalgo.html#a12">std::sort</a> (consume_seq.begin (), consume_seq.end ());
00337 
00338         <span class="keywordtype">unsigned</span> disks_number = config::get_instance()-&gt;disks_number ();
00339         
00340 <span class="preprocessor">        #ifdef PLAY_WITH_OPT_PREF</span>
00341 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">int</span> n_write_buffers = 4 * disks_number;
00342 <span class="preprocessor">        #else</span>
00343 <span class="preprocessor"></span>        <span class="keyword">const</span> <span class="keywordtype">int</span> n_prefetch_buffers = std::max( 2 * disks_number , (3 * (<span class="keywordtype">int</span>(_m) - nruns) / 4));
00344         <span class="keyword">const</span> <span class="keywordtype">int</span> n_write_buffers = std::max( 2 * disks_number , <span class="keywordtype">int</span>(_m) - nruns - n_prefetch_buffers );
00345         <span class="comment">// heuristic</span>
00346         <span class="keyword">const</span> <span class="keywordtype">int</span> n_opt_prefetch_buffers = 2 * disks_number + (3*(n_prefetch_buffers - 2 * disks_number))/10;
00347 <span class="preprocessor">        #endif</span>
00348 <span class="preprocessor"></span>        
00349 <span class="preprocessor">        #ifdef SORT_OPT_PREFETCHING</span>
00350 <span class="preprocessor"></span>        compute_prefetch_schedule(
00351                         consume_seq,
00352                         prefetch_seq,
00353                         n_opt_prefetch_buffers,
00354                         disks_number );
00355 <span class="preprocessor">        #else</span>
00356 <span class="preprocessor"></span>        <span class="keywordflow">for</span>(i=0;i&lt;out_run-&gt;size();i++)
00357                 prefetch_seq[i] = i;
00358 <span class="preprocessor">        #endif</span>
00359 <span class="preprocessor"></span>        
00360         
00361         prefetcher_type prefetcher(     consume_seq.begin(),
00362                                                                                                                         consume_seq.end(),
00363                                                                                                                         prefetch_seq,
00364                                                                                                                         nruns + n_prefetch_buffers);
00365         
00366         buffered_writer&lt;block_type&gt; writer(n_write_buffers,n_write_buffers/2);
00367         
00368         <span class="keywordtype">unsigned</span> out_run_size = out_run-&gt;size();
00369 
00370         run_cursor2_cmp&lt;block_type,prefetcher_type,key_extractor&gt; cmp(keyobj);
00371         looser_tree&lt;
00372                                                         run_cursor_type,
00373                                                         run_cursor2_cmp&lt;block_type,prefetcher_type,key_extractor&gt;,
00374                                                         block_type::size&gt; loosers (&amp;prefetcher, nruns, cmp);
00375 
00376 
00377         block_type *out_buffer = writer.get_free_block();
00378 
00379         <span class="keywordflow">for</span> (i = 0; i &lt; out_run_size; i++)
00380         {
00381                 loosers.multi_merge (out_buffer-&gt;elem);
00382                 (*out_run)[i].key = keyobj(out_buffer-&gt;elem[0]);
00383                 out_buffer = writer.write(out_buffer,(*out_run)[i].bid);
00384         }
00385         
00386         <span class="keyword">delete</span> [] prefetch_seq;
00387 
00388         block_manager *bm = block_manager::get_instance ();
00389         <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00390         {
00391                 <span class="keywordtype">unsigned</span> sz = in_runs[i]-&gt;size ();
00392                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; sz; j++)
00393                         bm-&gt;delete_block((*in_runs[i])[j].bid);
00394                 <span class="keyword">delete</span> in_runs[i];
00395         }
00396 }
00397 
00398 
00399 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> block_type,
00400                                         <span class="keyword">typename</span> alloc_strategy,
00401                                         <span class="keyword">typename</span> input_bid_iterator,
00402                                         <span class="keyword">typename</span> key_extractor&gt;
00403 
00404 simple_vector&lt; trigger_entry&lt;typename block_type::bid_type,typename block_type::value_type::key_type&gt; &gt; * 
00405         ksort_blocks(input_bid_iterator input_bids,<span class="keywordtype">unsigned</span> _n,<span class="keywordtype">unsigned</span> _m,key_extractor keyobj)
00406 {
00407         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type type;
00408         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00409         <span class="keyword">typedef</span> trigger_entry&lt; bid_type,typename type::key_type&gt; trigger_entry_type;
00410         <span class="keyword">typedef</span> simple_vector&lt; trigger_entry_type &gt; run_type;
00411         <span class="keyword">typedef</span> <span class="keyword">typename</span> interleaved_alloc_traits&lt;alloc_strategy&gt;::strategy interleaved_alloc_strategy;
00412         
00413         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m2 = div_and_round_up(_m,2);
00414   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m2_rf = m2 * block_type::raw_size / 
00415     (block_type::raw_size + block_type::size*<span class="keyword">sizeof</span>(type_key&lt;type&gt;));
00416   STXXL_VERBOSE(<span class="stringliteral">"Reducing number of blocks in a run from "</span>&lt;&lt; m2 &lt;&lt; <span class="stringliteral">" to "</span>&lt;&lt;
00417     m2_rf&lt;&lt;<span class="stringliteral">" due to key size: "</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">typename</span> type::key_type)&lt;&lt;<span class="stringliteral">" bytes"</span>)
00418   m2 = m2_rf;
00419         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> full_runs = _n / m2;
00420         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> partial_runs = ((_n % m2) ? 1 : 0);
00421         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nruns = full_runs + partial_runs;
00422         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00423         
00424         config *cfg = config::get_instance ();
00425         block_manager *mng = block_manager::get_instance ();
00426         <span class="keywordtype">int</span> ndisks = cfg-&gt;disks_number ();
00427         
00428         STXXL_VERBOSE (<span class="stringliteral">"n="</span> &lt;&lt; _n &lt;&lt; <span class="stringliteral">" nruns="</span> &lt;&lt; nruns &lt;&lt; <span class="stringliteral">"="</span> &lt;&lt; full_runs &lt;&lt; <span class="stringliteral">"+"</span> &lt;&lt; partial_runs) 
00429         
00430 #ifdef STXXL_IO_STATS
00431         stats *iostats = stats::get_instance ();
00432         iostats-&gt;reset ();
00433 <span class="preprocessor">#endif</span>
00434 <span class="preprocessor"></span>        
00435         <span class="keywordtype">double</span> begin = stxxl_timestamp (), after_runs_creation, end;
00436   (void)(begin);
00437 
00438         run_type **runs = <span class="keyword">new</span> run_type *[nruns];
00439 
00440         <span class="keywordflow">for</span> (i = 0; i &lt; full_runs; i++)
00441                 runs[i] = <span class="keyword">new</span> run_type (m2);
00442 
00443 <span class="preprocessor">#ifdef INTERLEAVED_ALLOC</span>
00444 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (partial_runs)
00445         {
00446                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last_run_size = _n - full_runs * m2;
00447                 runs[i] = <span class="keyword">new</span> run_type (last_run_size);
00448 
00449                 mng-&gt;new_blocks (interleaved_alloc_strategy (nruns, 0, ndisks),
00450                                  RunsToBIDArrayAdaptor2 &lt; block_type::raw_size,run_type &gt;
00451                                  (runs, 0, nruns, last_run_size),
00452                                  RunsToBIDArrayAdaptor2 &lt; block_type::raw_size,run_type &gt;
00453                                  (runs, _n, nruns, last_run_size));
00454 
00455         }
00456         <span class="keywordflow">else</span>
00457                 mng-&gt;new_blocks (interleaved_alloc_strategy (nruns, 0, ndisks),
00458                                  RunsToBIDArrayAdaptor &lt; block_type::raw_size,run_type &gt;
00459                                  (runs, 0, nruns),
00460                                  RunsToBIDArrayAdaptor &lt; block_type::raw_size,run_type &gt;
00461                                  (runs, _n, nruns));
00462 <span class="preprocessor">#else</span>
00463 <span class="preprocessor"></span>        
00464                 <span class="keywordflow">if</span> (partial_runs)
00465                         runs[i] = <span class="keyword">new</span> run_type (_n - full_runs * m2);
00466                 
00467                 <span class="keywordflow">for</span>(i=0;i&lt;nruns;i++)
00468                 {
00469                         mng-&gt;new_blocks(        alloc_strategy(0,ndisks),
00470                                                                                                 trigger_entry_iterator&lt;trigger_entry_type,block_type::raw_size&gt;(runs[i]-&gt;begin()),
00471                                                                                                 trigger_entry_iterator&lt;trigger_entry_type,block_type::raw_size&gt;(runs[i]-&gt;end()) );
00472                 }
00473 <span class="preprocessor">#endif</span>
00474 <span class="preprocessor"></span>          
00475         create_runs&lt; block_type,
00476                                                          run_type,
00477                                                          input_bid_iterator,
00478                                                          key_extractor&gt; (input_bids, runs, nruns,m2,keyobj);
00479 
00480         after_runs_creation = stxxl_timestamp ();
00481                 
00482 <span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00483 <span class="preprocessor"></span>        <span class="keywordtype">double</span> io_wait_after_rf = stxxl::wait_time_counter;
00484 <span class="preprocessor">#endif</span>
00485 <span class="preprocessor"></span>
00486         disk_queues::get_instance ()-&gt;set_priority_op (disk_queue::WRITE);
00487     
00488         <span class="comment">// Optimal merging: merge r = pow(nruns,1/ceil(log(nruns)/log(m))) at once</span>
00489                 
00490         <span class="keyword">const</span> <span class="keywordtype">int</span> merge_factor = static_cast&lt;int&gt;(ceil(pow(nruns,1./ceil(log(nruns)/log(_m)))));
00491         run_type **new_runs;
00492         
00493         <span class="keywordflow">while</span>(nruns &gt; 1)
00494         {
00495                 <span class="keywordtype">int</span> new_nruns = div_and_round_up(nruns,merge_factor);
00496                 STXXL_VERBOSE(<span class="stringliteral">"Starting new merge phase: nruns: "</span>&lt;&lt;nruns&lt;&lt;
00497                         <span class="stringliteral">" opt_merge_factor: "</span>&lt;&lt;merge_factor&lt;&lt;<span class="stringliteral">" m:"</span>&lt;&lt;_m&lt;&lt;<span class="stringliteral">" new_nruns: "</span>&lt;&lt;new_nruns)
00498                 
00499                 new_runs = <span class="keyword">new</span> run_type *[new_nruns];
00500                 
00501                 <span class="keywordtype">int</span> runs_left = nruns;
00502                 <span class="keywordtype">int</span> cur_out_run = 0;
00503                 <span class="keywordtype">int</span> blocks_in_new_run = 0;
00504                 
00505                 <span class="keywordflow">while</span>(runs_left &gt; 0)
00506                 {
00507                         <span class="keywordtype">int</span> runs2merge = STXXL_MIN(runs_left,merge_factor);
00508                         blocks_in_new_run = 0;
00509                         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = nruns - runs_left; i &lt; (nruns - runs_left + runs2merge);i++)
00510                                 blocks_in_new_run += runs[i]-&gt;size();
00511                         <span class="comment">// allocate run</span>
00512                         new_runs[cur_out_run++] = <span class="keyword">new</span> run_type(blocks_in_new_run);
00513                         runs_left -= runs2merge;
00514                 }
00515                 <span class="comment">// allocate blocks in the new runs</span>
00516                 mng-&gt;new_blocks( interleaved_alloc_strategy(new_nruns, 0, ndisks),
00517                                                  RunsToBIDArrayAdaptor2&lt;block_type::raw_size,run_type&gt; (new_runs,0,new_nruns,blocks_in_new_run),
00518                                                  RunsToBIDArrayAdaptor2&lt;block_type::raw_size,run_type&gt; (new_runs,_n,new_nruns,blocks_in_new_run));
00519                 <span class="comment">// merge all</span>
00520                 runs_left = nruns;
00521                 cur_out_run = 0;
00522                 <span class="keywordflow">while</span>(runs_left &gt; 0)
00523                 {
00524                                 <span class="keywordtype">int</span> runs2merge = STXXL_MIN(runs_left,merge_factor);
00525                                 STXXL_VERBOSE(<span class="stringliteral">"Merging "</span>&lt;&lt;runs2merge&lt;&lt;<span class="stringliteral">" runs"</span>)
00526                                 merge_runs&lt;block_type,run_type,key_extractor&gt; (runs + nruns - runs_left, 
00527                                                 runs2merge ,*(new_runs + (cur_out_run++)),_m,keyobj);
00528                                 runs_left -= runs2merge;
00529                 }
00530                 
00531                 nruns = new_nruns;
00532                 <span class="keyword">delete</span> [] runs;
00533                 runs = new_runs;
00534         }
00535         
00536         
00537         run_type * result = *runs;
00538         <span class="keyword">delete</span> [] runs;
00539         
00540         end = stxxl_timestamp ();
00541 
00542         STXXL_VERBOSE (<span class="stringliteral">"Elapsed time        : "</span> &lt;&lt; end - begin &lt;&lt; <span class="stringliteral">" s. Run creation time: "</span> &lt;&lt; 
00543         after_runs_creation - begin &lt;&lt; <span class="stringliteral">" s"</span>)
00544 #ifdef STXXL_IO_STATS
00545         STXXL_VERBOSE (<span class="stringliteral">"reads               : "</span> &lt;&lt; iostats-&gt;get_reads ()) 
00546         STXXL_VERBOSE (<span class="stringliteral">"writes              : "</span> &lt;&lt; iostats-&gt;get_writes ())
00547         STXXL_VERBOSE (<span class="stringliteral">"read time           : "</span> &lt;&lt; iostats-&gt;get_read_time () &lt;&lt; <span class="stringliteral">" s"</span>) 
00548         STXXL_VERBOSE (<span class="stringliteral">"write time          : "</span> &lt;&lt; iostats-&gt;get_write_time () &lt;&lt;<span class="stringliteral">" s"</span>)
00549         STXXL_VERBOSE (<span class="stringliteral">"parallel read time  : "</span> &lt;&lt; iostats-&gt;get_pread_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00550         STXXL_VERBOSE (<span class="stringliteral">"parallel write time : "</span> &lt;&lt; iostats-&gt;get_pwrite_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00551         STXXL_VERBOSE (<span class="stringliteral">"parallel io time    : "</span> &lt;&lt; iostats-&gt;get_pio_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00552 <span class="preprocessor">#endif</span>
00553 <span class="preprocessor"></span><span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00554 <span class="preprocessor"></span>        STXXL_VERBOSE (<span class="stringliteral">"Time in I/O wait(rf): "</span> &lt;&lt; io_wait_after_rf &lt;&lt; <span class="stringliteral">" s"</span>)
00555         STXXL_VERBOSE (<span class="stringliteral">"Time in I/O wait    : "</span> &lt;&lt; stxxl::wait_time_counter &lt;&lt; <span class="stringliteral">" s"</span>)
00556 #endif
00557         
00558         <span class="keywordflow">return</span> result; 
00559 }
00560 
00561 
00562 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> record_type, <span class="keyword">typename</span> key_extractor&gt;
00563 <span class="keyword">class </span>key_comparison
00564 {
00565   key_comparison() {}
00566   key_extractor ke;
00567 <span class="keyword">public</span>:
00568   key_comparison(key_extractor ke_): ke(ke_){}
00569   <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> record_type &amp; a, <span class="keyword">const</span> record_type &amp; b)
00570   {
00571     <span class="keywordflow">return</span> ke(a) &lt; ke(b);
00572   }
00573 };
00574 
00575 
<a name="l00583"></a><a class="code" href="group__stlalgo.html#a8">00583</a> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExtIterator_,<span class="keyword">typename</span> KeyExtractor_&gt;
00584 <span class="keywordtype">void</span> <a class="code" href="group__stlalgo.html#a8">ksort</a>(ExtIterator_ first_, ExtIterator_ last_,KeyExtractor_ keyobj,<span class="keywordtype">unsigned</span> M__)
00585 {
00586         <span class="keyword">typedef</span> simple_vector&lt; trigger_entry&lt;<span class="keyword">typename</span> ExtIterator_::bid_type,
00587       <span class="keyword">typename</span> KeyExtractor_::key_type&gt; &gt; run_type;
00588         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::vector_type::value_type value_type;
00589         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::block_type block_type;
00590         
00591         <span class="keywordtype">unsigned</span> n=0;
00592         block_manager *mng = block_manager::get_instance ();
00593         
00594         first_.flush();
00595         
00596         <span class="keywordflow">if</span>((last_ - first_)*<span class="keyword">sizeof</span>(value_type) &lt; M__)
00597         {
00598                 stl_in_memory_sort(first_,last_,key_comparison&lt;value_type,KeyExtractor_&gt;(keyobj));
00599         }
00600         <span class="keywordflow">else</span>
00601         {
00602                 <span class="keywordflow">if</span>(first_.block_offset()) 
00603                 {
00604                         <span class="keywordflow">if</span>(last_.block_offset()) <span class="comment">// first and last element reside </span>
00605                                                                                                                                 <span class="comment">// not in the beginning of the block</span>
00606                         {
00607                                 <span class="keyword">typename</span> ExtIterator_::block_type * first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00608                                 <span class="keyword">typename</span> ExtIterator_::block_type * last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00609                                 <span class="keyword">typename</span> ExtIterator_::bid_type first_bid,last_bid;
00610                                 request_ptr req;
00611                                 
00612                                 req = first_block-&gt;read(*first_.bid());
00613                                 mng-&gt;new_blocks( FR(), &amp;first_bid,(&amp;first_bid) + 1); <span class="comment">// try to overlap</span>
00614                                 mng-&gt;new_blocks( FR(), &amp;last_bid,(&amp;last_bid) + 1);
00615                                 req-&gt;wait();
00616                                 
00617                         
00618                                 req = last_block-&gt;read(*last_.bid());
00619                                 
00620                                 <span class="keywordtype">unsigned</span> i=0;
00621                                 <span class="keywordflow">for</span>(;i&lt;first_.block_offset();i++)
00622                                 {
00623                                         first_block-&gt;elem[i] = keyobj.min_value();
00624                                 }
00625                                 
00626                                 req-&gt;wait();
00627                                 
00628                                 req = first_block-&gt;write(first_bid);
00629                                 <span class="keywordflow">for</span>(i=last_.block_offset(); i &lt; block_type::size;i++)
00630                                 {
00631                                         last_block-&gt;elem[i] = keyobj.max_value();
00632                                 }
00633                                 
00634                                 req-&gt;wait();
00635                                 
00636                                 req = last_block-&gt;write(last_bid);
00637                                 
00638                                 n=last_.bid() - first_.bid() + 1;
00639                                 
00640                                 std::swap(first_bid,*first_.bid());
00641                                 std::swap(last_bid,*last_.bid());
00642                                 
00643                                 req-&gt;wait();
00644                                 
00645                                 <span class="keyword">delete</span> first_block;
00646                                 <span class="keyword">delete</span> last_block;
00647 
00648                                 run_type * out =
00649                                                 ksort_blocks&lt;   
00650                                                                                                         <span class="keyword">typename</span> ExtIterator_::block_type,
00651                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00652                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator ,
00653                                                                                                         KeyExtractor_&gt;
00654                                                                                                                  (first_.bid(),n,M__/block_type::raw_size,keyobj);
00655                                         
00656                                 
00657                                 first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00658                                 last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00659                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00660                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00661                                 request_ptr * reqs = <span class="keyword">new</span> request_ptr [2];
00662                                 
00663                                 reqs[0] = first_block-&gt;read(first_bid);
00664                                 reqs[1] = sorted_first_block-&gt;read((*(out-&gt;begin())).bid);
00665                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00666                                 
00667                                 reqs[0] = last_block-&gt;read(last_bid);
00668                                 reqs[1] = sorted_last_block-&gt;read( ((*out)[out-&gt;size() - 1]).bid);
00669                                 
00670                                 <span class="keywordflow">for</span>(i=first_.block_offset();i&lt;block_type::size;i++)
00671                                 {
00672                                         first_block-&gt;elem[i] = sorted_first_block-&gt;elem[i];
00673                                 }
00674                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00675                                 
00676                                 req = first_block-&gt;write(first_bid);
00677                                 
00678                                 <span class="keywordflow">for</span>(i=0;i&lt;last_.block_offset();i++)
00679                                 {
00680                                         last_block-&gt;elem[i] = sorted_last_block-&gt;elem[i];
00681                                 }
00682                                 
00683                                 req-&gt;wait();
00684                                 
00685                                 
00686                                 req = last_block-&gt;write(last_bid);
00687                                 
00688                                 mng-&gt;delete_block(out-&gt;begin()-&gt;bid);
00689                                 mng-&gt;delete_block((*out)[out-&gt;size() - 1].bid);
00690                                 
00691                                 *first_.bid() = first_bid;
00692                                 *last_.bid() = last_bid; 
00693                                 
00694                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin(); it++;
00695                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first_.bid(); cur_bid ++;
00696                                 
00697                                 <span class="keywordflow">for</span>(;cur_bid != last_.bid(); cur_bid++,it++)
00698                                 {
00699                                         *cur_bid = (*it).bid;
00700                                 }
00701                                 
00702                                 <span class="keyword">delete</span> first_block;
00703                                 <span class="keyword">delete</span> sorted_first_block;
00704                                 <span class="keyword">delete</span> sorted_last_block;
00705                                 <span class="keyword">delete</span> [] reqs;
00706                                 <span class="keyword">delete</span> out;
00707                                 
00708                                 req-&gt;wait();
00709                                 
00710                                 <span class="keyword">delete</span> last_block;
00711                         }
00712                         <span class="keywordflow">else</span>
00713                         {
00714                                 <span class="comment">// first element resides</span>
00715                                 <span class="comment">// not in the beginning of the block</span>
00716                                 
00717                                 <span class="keyword">typename</span> ExtIterator_::block_type * first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00718                                 <span class="keyword">typename</span> ExtIterator_::bid_type first_bid;
00719                                 request_ptr req;
00720                                 
00721                                 req = first_block-&gt;read(*first_.bid());
00722                                 mng-&gt;new_blocks( FR(), &amp;first_bid,(&amp;first_bid) + 1); <span class="comment">// try to overlap</span>
00723                                 req-&gt;wait();
00724                                 
00725                                 
00726                                 <span class="keywordtype">unsigned</span> i=0;
00727                                 <span class="keywordflow">for</span>(;i&lt;first_.block_offset();i++)
00728                                 {
00729                                         first_block-&gt;elem[i] = keyobj.min_value();
00730                                 }
00731                                 
00732                                 req = first_block-&gt;write(first_bid);
00733                                 
00734                                 n=last_.bid() - first_.bid();
00735                                 
00736                                 std::swap(first_bid,*first_.bid());
00737                                 
00738                                 req-&gt;wait();
00739                                 
00740                                 <span class="keyword">delete</span> first_block;
00741 
00742                                 run_type * out =
00743                                                 ksort_blocks&lt;
00744                                                                                                         <span class="keyword">typename</span> ExtIterator_::block_type,
00745                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00746                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator,
00747                                                                                                         KeyExtractor_&gt;
00748                                                                                                                  (first_.bid(),n,M__/block_type::raw_size,keyobj);
00749                                         
00750                                 
00751                                 first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00752                                 
00753                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_first_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00754         
00755                                 request_ptr * reqs = <span class="keyword">new</span> request_ptr [2];
00756                                 
00757                                 reqs[0] = first_block-&gt;read(first_bid);
00758                                 reqs[1] = sorted_first_block-&gt;read((*(out-&gt;begin())).bid);
00759                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00760                                 
00761                                 <span class="keywordflow">for</span>(i=first_.block_offset();i&lt;block_type::size;i++)
00762                                 {
00763                                         first_block-&gt;elem[i] = sorted_first_block-&gt;elem[i];
00764                                 }
00765                                 
00766                                 req = first_block-&gt;write(first_bid);
00767                                 
00768                                 mng-&gt;delete_block(out-&gt;begin()-&gt;bid);
00769                                 
00770                                 *first_.bid() = first_bid;
00771                                 
00772                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin(); it++;
00773                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first_.bid(); cur_bid ++;
00774                                 
00775                                 <span class="keywordflow">for</span>(;cur_bid != last_.bid(); cur_bid++,it++)
00776                                 {
00777                                         *cur_bid = (*it).bid;
00778                                 }
00779                                 
00780                                 *cur_bid = (*it).bid;
00781                                 
00782                                 <span class="keyword">delete</span> sorted_first_block;
00783                                 <span class="keyword">delete</span> [] reqs;
00784                                 <span class="keyword">delete</span> out;
00785                                 
00786                                 req-&gt;wait();
00787                                 
00788                                 <span class="keyword">delete</span> first_block;
00789                                 
00790                         }
00791                         
00792                 }
00793                 <span class="keywordflow">else</span>
00794                 {
00795                         <span class="keywordflow">if</span>(last_.block_offset()) <span class="comment">// last element resides</span>
00796                                                                                                                                 <span class="comment">// not in the beginning of the block</span>
00797                         {
00798                                 <span class="keyword">typename</span> ExtIterator_::block_type * last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00799                                 <span class="keyword">typename</span> ExtIterator_::bid_type last_bid;
00800                                 request_ptr req;
00801                                 <span class="keywordtype">unsigned</span> i;
00802                                 
00803                                 req = last_block-&gt;read(*last_.bid());
00804                                 mng-&gt;new_blocks( FR(), &amp;last_bid,(&amp;last_bid) + 1);
00805                                 req-&gt;wait();
00806                         
00807                                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=last_.block_offset(); i &lt; block_type::size;i++)
00808                                 {
00809                                         last_block-&gt;elem[i] = keyobj.max_value();
00810                                 }
00811                                 
00812                                 req = last_block-&gt;write(last_bid);
00813                                 
00814                                 n=last_.bid() - first_.bid() + 1;
00815                                 
00816                                 std::swap(last_bid,*last_.bid());
00817                                 
00818                                 req-&gt;wait();
00819                                 
00820                                 <span class="keyword">delete</span> last_block;
00821 
00822                                 run_type * out =
00823                                                 ksort_blocks&lt;   
00824                                                                                                         <span class="keyword">typename</span> ExtIterator_::block_type,
00825                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00826                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator,
00827                                                                                                         KeyExtractor_&gt;
00828                                                                                                                  (first_.bid(),n,M__/block_type::raw_size,keyobj);
00829                                         
00830                                 
00831                                 last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00832                                 <span class="keyword">typename</span> ExtIterator_::block_type * sorted_last_block = <span class="keyword">new</span> <span class="keyword">typename</span> ExtIterator_::block_type;
00833                                 request_ptr * reqs = <span class="keyword">new</span> request_ptr [2];
00834                                 
00835                                 reqs[0] = last_block-&gt;read(last_bid);
00836                                 reqs[1] = sorted_last_block-&gt;read( ((*out)[out-&gt;size() - 1]).bid);
00837                                 <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,2);
00838                                 
00839                                 <span class="keywordflow">for</span>(i=0;i&lt;last_.block_offset();i++)
00840                                 {
00841                                         last_block-&gt;elem[i] = sorted_last_block-&gt;elem[i];
00842                                 }
00843                                 
00844                                 req = last_block-&gt;write(last_bid);
00845                                 
00846                                 mng-&gt;delete_block((*out)[out-&gt;size() - 1].bid);
00847                                 
00848                                 *last_.bid() = last_bid; 
00849                                 
00850                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin();
00851                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first_.bid();
00852                                 
00853                                 <span class="keywordflow">for</span>(;cur_bid != last_.bid(); cur_bid++,it++)
00854                                 {
00855                                         *cur_bid = (*it).bid;
00856                                 }
00857                                 
00858                                 <span class="keyword">delete</span> sorted_last_block;
00859                                 <span class="keyword">delete</span> [] reqs;
00860                                 <span class="keyword">delete</span> out;
00861                                 
00862                                 req-&gt;wait();
00863                                 
00864                                 <span class="keyword">delete</span> last_block;
00865                         }
00866                         <span class="keywordflow">else</span>
00867                         {
00868                                 <span class="comment">// first and last element resine in the beginning of blocks </span>
00869                                 n = last_.bid() - first_.bid();
00870                                 
00871                                 run_type * out =
00872                                                 ksort_blocks&lt;   
00873                                                                                                         <span class="keyword">typename</span> ExtIterator_::block_type,
00874                                                                                                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy,
00875                                                                                                         <span class="keyword">typename</span> ExtIterator_::bids_container_iterator,
00876                                                                                                         KeyExtractor_&gt;
00877                                                                                                                  (first_.bid(),n,M__/block_type::raw_size,keyobj);
00878                                 
00879                                 <span class="keyword">typename</span> run_type::iterator it = out-&gt;begin();
00880                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator cur_bid = first_.bid();
00881                                 
00882                                 <span class="keywordflow">for</span>(;cur_bid != last_.bid(); cur_bid++,it++)
00883                                 {
00884                                         *cur_bid = (*it).bid;
00885                                 }
00886                                 
00887                         }
00888                 }
00889                 
00890         }
00891 };
00892 
00893 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> record_type&gt;
00894 <span class="keyword">struct </span>ksort_defaultkey
00895 {
00896   <span class="keyword">typedef</span> <span class="keyword">typename</span> record_type::key_type key_type;
00897   key_type operator() (<span class="keyword">const</span> record_type &amp; obj)
00898   {
00899     <span class="keywordflow">return</span> obj.key();
00900   }
00901   record_type max_value()
00902   {
00903     <span class="keywordflow">return</span> record_type::max_value();
00904   }
00905   record_type min_value()
00906   {
00907     <span class="keywordflow">return</span> record_type::min_value();
00908   }
00909 };
00910   
00911 
<a name="l00918"></a><a class="code" href="group__stlalgo.html#a9">00918</a> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExtIterator_&gt;
00919 <span class="keywordtype">void</span> <a class="code" href="group__stlalgo.html#a8">ksort</a>(ExtIterator_ first_, ExtIterator_ last_,<span class="keywordtype">unsigned</span> M__)
00920 {
00921   <a class="code" href="group__stlalgo.html#a8">ksort</a>(first_,last_,
00922     ksort_defaultkey&lt;typename ExtIterator_::vector_type::value_type&gt;(),M__);
00923 }
00924 
00925 
00927 
00928 __STXXL_END_NAMESPACE
00929 
00930 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Jul 1 11:08:35 2003 for &lt;stxxl&gt; by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
