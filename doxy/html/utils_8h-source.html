<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>utils.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>utils.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef MYUTILS_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define MYUTILS_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            utils.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Sat Aug 24 23:54:29 2002</span>
00008 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 
00013 <span class="preprocessor">#include &lt;iostream&gt;</span>
00014 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00015 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00016 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00017 <span class="preprocessor">#include &lt;string.h&gt;</span>
00018 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00019 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00020 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00021 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00022 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00023 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00024 <span class="preprocessor">#include &lt;math.h&gt;</span>
00025 <span class="preprocessor">#include &lt;vector&gt;</span>
00026 <span class="preprocessor">#include &lt;string&gt;</span>
00027 
00028 <span class="preprocessor">#define __STXXL_BEGIN_NAMESPACE namespace stxxl {</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define __STXXL_END_NAMESPACE }</span>
00030 <span class="preprocessor"></span>
00031 
00032 
00033 __STXXL_BEGIN_NAMESPACE
00034 
00035 <span class="comment">//#define assert(x)  </span>
00036 
00037 <span class="preprocessor">#define __STXXL_STRING(x) #x</span>
00038 <span class="preprocessor"></span>
00039 <span class="preprocessor">#define STXXL_MSG(x) { std::cout &lt;&lt; x &lt;&lt; std::endl; std::cout.flush(); };</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_ERRMSG(x) { std::cerr &lt;&lt; x &lt;&lt; std::endl; std::cerr.flush(); };</span>
00041 <span class="preprocessor"></span>  
00042 
00043 <span class="preprocessor">#if STXXL_VERBOSE_LEVEL &gt; 0</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_VERBOSE1(x) { std::cout &lt;&lt; x &lt;&lt; std::endl; std::cerr.flush(); };</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_VERBOSE1(x)  </span>
00047 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00048 <span class="preprocessor"></span>  
00049 <span class="preprocessor">#define STXXL_VERBOSE(x) STXXL_VERBOSE1(x) </span>
00050 <span class="preprocessor"></span>
00051 <span class="preprocessor">#if STXXL_VERBOSE_LEVEL &gt; 1</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_VERBOSE2(x) { std::cout &lt;&lt; x &lt;&lt; std::endl; std::cerr.flush(); };</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_VERBOSE2(x) </span>
00055 <span class="preprocessor"></span><span class="preprocessor">#endif  </span>
00056 <span class="preprocessor"></span>
00057 <span class="preprocessor">#if STXXL_VERBOSE_LEVEL &gt; 2</span>
00058 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_VERBOSE3(x) { std::cout &lt;&lt; x &lt;&lt; std::endl; std::cerr.flush(); };</span>
00059 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_VERBOSE3(x) </span>
00061 <span class="preprocessor"></span><span class="preprocessor">#endif    </span>
00062 <span class="preprocessor"></span>  
00063   
00064 <span class="keyword">inline</span> <span class="keywordtype">void</span>
00065 stxxl_perror (<span class="keyword">const</span> <span class="keywordtype">char</span> *errmsg, <span class="keywordtype">int</span> errcode)
00066 {
00067         std::cerr &lt;&lt; errmsg &lt;&lt; <span class="stringliteral">" error code "</span> &lt;&lt; errcode;
00068         std::cerr &lt;&lt; <span class="stringliteral">" : "</span> &lt;&lt; strerror (errcode) &lt;&lt; std::endl;
00069 
00070         exit (errcode);
00071 }
00072 
00073 <span class="preprocessor">#define STXXL_DEBUG_ON</span>
00074 <span class="preprocessor"></span>
00075 <span class="preprocessor">#ifdef STXXL_DEBUG_ON</span>
00076 <span class="preprocessor"></span>
00077 <span class="preprocessor">#define stxxl_error(errmsg) { perror(errmsg); exit(errno); }</span>
00078 <span class="preprocessor"></span>
00079 <span class="preprocessor">#define stxxl_function_error stxxl_error(__PRETTY_FUNCTION__)</span>
00080 <span class="preprocessor"></span>
00081 <span class="preprocessor">#define stxxl_nassert(expr) { int ass_res=expr; if(ass_res) {  std::cerr &lt;&lt; "Error in function: " &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; " ";  stxxl_perror(__STXXL_STRING(expr),ass_res); }}</span>
00082 <span class="preprocessor"></span>
00083 <span class="preprocessor">#define stxxl_ifcheck(expr) if((expr)&lt;0) { std::cerr&lt;&lt;"Error in function "&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;" "; stxxl_error(__STXXL_STRING(expr));}</span>
00084 <span class="preprocessor"></span>
00085 <span class="preprocessor">#define stxxl_debug(expr) expr</span>
00086 <span class="preprocessor"></span>
00087 <span class="preprocessor">#else</span>
00088 <span class="preprocessor"></span>
00089 <span class="preprocessor">#define stxxl_error(errmsg) ;</span>
00090 <span class="preprocessor"></span>
00091 <span class="preprocessor">#define stxxl_function_error ;</span>
00092 <span class="preprocessor"></span>
00093 <span class="preprocessor">#define stxxl_nassert(expr) expr;</span>
00094 <span class="preprocessor"></span>
00095 <span class="preprocessor">#define stxxl_ifcheck(expr) expr; if(0) {}</span>
00096 <span class="preprocessor"></span>
00097 <span class="preprocessor">#define stxxl_debug(expr) ;</span>
00098 <span class="preprocessor"></span>
00099 <span class="preprocessor">#endif</span>
00100 <span class="preprocessor"></span>
00101 <span class="comment">// returns number of seconds from ...</span>
00102 <span class="keyword">inline</span> <span class="keywordtype">double</span>
00103 stxxl_timestamp ()
00104 {
00105         <span class="keyword">struct </span>timeval tp;
00106         gettimeofday (&amp;tp, NULL);
00107         <span class="keywordflow">return</span> double (tp.tv_sec) + tp.tv_usec / 1000000.;
00108 }
00109 
00110 
00111 <span class="keyword">inline</span>
00112         std::string
00113 stxxl_tmpfilename (std::string dir, std::string prefix)
00114 {
00115         <span class="comment">//stxxl_debug(cerr &lt;&lt;" TMP:"&lt;&lt; dir.c_str() &lt;&lt;":"&lt;&lt; prefix.c_str()&lt;&lt; endl);</span>
00116         <span class="keywordtype">int</span> rnd;
00117         <span class="keywordtype">char</span> buffer[1024];
00118         std::string result;
00119         <span class="keyword">struct </span>stat st;
00120 
00121         <span class="keywordflow">do</span>
00122         {
00123 
00124                 rnd = rand ();
00125                 sprintf (buffer, <span class="stringliteral">"%u"</span>, rnd);
00126                 result = dir + prefix + buffer;
00127 
00128         }
00129         <span class="keywordflow">while</span> (!lstat (result.c_str (), &amp;st));
00130 
00131         <span class="keywordflow">if</span> (errno != ENOENT)
00132                 stxxl_function_error
00133                         <span class="comment">//  char * temp_name = tempnam(dir.c_str(),prefix.c_str());</span>
00134                         <span class="comment">//  if(!temp_name)</span>
00135                         <span class="comment">//    stxxl_function_error</span>
00136                         <span class="comment">//  std::string result(temp_name);</span>
00137                         <span class="comment">//  free(temp_name);</span>
00138                         <span class="comment">//  stxxl_debug(cerr &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; ":" &lt;&lt;result &lt;&lt; endl);</span>
00139                         <span class="keywordflow">return</span> result;
00140 }
00141 
00142 <span class="keyword">inline</span>
00143         std::vector &lt;
00144         std::string &gt;
00145 split (<span class="keyword">const</span> std::string &amp; str, <span class="keyword">const</span> std::string &amp; sep)
00146 {
00147         std::vector &lt; std::string &gt; result;
00148         <span class="keywordflow">if</span> (str.empty ())
00149                 <span class="keywordflow">return</span> result;
00150 
00151         std::string::size_type CurPos (0), LastPos (0);
00152         <span class="keywordflow">while</span> (1)
00153         {
00154                 CurPos = str.find (sep, LastPos);
00155                 <span class="keywordflow">if</span> (CurPos == std::string::npos)
00156                         <span class="keywordflow">break</span>;
00157 
00158                 std::string sub =
00159                         str.substr (LastPos,
00160                                     std::string::size_type (CurPos -
00161                                                             LastPos));
00162                 <span class="keywordflow">if</span> (sub.size ())
00163                         result.push_back (sub);
00164 
00165                 LastPos = CurPos + sep.size ();
00166         };
00167 
00168         std::string sub = str.substr (LastPos);
00169         <span class="keywordflow">if</span> (sub.size ())
00170                 result.push_back (sub);
00171 
00172         <span class="keywordflow">return</span> result;
00173 };
00174 
00175 <span class="preprocessor">#define str2int(str) atoi(str.c_str())</span>
00176 <span class="preprocessor"></span>
00177 <span class="keyword">inline</span>
00178         std::string
00179 int2str (<span class="keywordtype">int</span> i)
00180 {
00181         <span class="keywordtype">char</span> buf[32];
00182         sprintf (buf, <span class="stringliteral">"%d"</span>, i);
00183         <span class="keywordflow">return</span> std::string (buf);
00184 }
00185 
00186 <span class="preprocessor">#define STXXL_MIN(a,b) ( std::min(a,b) )</span>
00187 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_MAX(a,b) ( std::max(a,b) )</span>
00188 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_L2_SIZE  (512*1024)</span>
00189 <span class="preprocessor"></span>
00190 <span class="preprocessor">#define div_and_round_up(a,b) ( (a)/(b) + !(!((a)%(b))))</span>
00191 <span class="preprocessor"></span>
00192 <span class="preprocessor">#define log2(x) (log(x)/log(2.))</span>
00193 <span class="preprocessor"></span>
00194 
00195 <span class="comment">//#define HAVE_BUILTIN_EXPECT</span>
00196 
00197 
00198 <span class="preprocessor">#ifdef HAVE_BUILTIN_EXPECT</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define LIKELY(c)   __builtin_expect((c), 1)</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00201 <span class="preprocessor"></span><span class="preprocessor">#define LIKELY(c)   c</span>
00202 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00203 <span class="preprocessor"></span>
00204 <span class="preprocessor">#ifdef HAVE_BUILTIN_EXPECT</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#define UNLIKELY(c)   __builtin_expect((c), 0)</span>
00206 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00207 <span class="preprocessor"></span><span class="preprocessor">#define UNLIKELY(c)   c</span>
00208 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00209 <span class="preprocessor"></span>
00210 <span class="comment">//#define COUNT_WAIT_TIME</span>
00211 
00212 <span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#define START_COUNT_WAIT_TIME   double count_wait_begin = stxxl_timestamp();</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define END_COUNT_WAIT_TIME             stxxl::wait_time_counter+= (stxxl_timestamp() - count_wait_begin);</span>
00215 <span class="preprocessor"></span>
00216 <span class="preprocessor">#define reset_io_wait_time() stxxl::wait_time_counter = 0.0;</span>
00217 <span class="preprocessor"></span>
00218 <span class="preprocessor">#define io_wait_time() (stxxl::wait_time_counter)</span>
00219 <span class="preprocessor"></span>
00220 
00221 <span class="preprocessor">#else</span>
00222 <span class="preprocessor"></span><span class="preprocessor">#define START_COUNT_WAIT_TIME</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#define END_COUNT_WAIT_TIME</span>
00224 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> reset_io_wait_time()
00225 {
00226 };
00227 
00228 <span class="keyword">inline</span> <span class="keywordtype">double</span> io_wait_time()
00229 {
00230         <span class="keywordflow">return</span> -1.0;
00231 };
00232 
00233 <span class="preprocessor">#endif</span>
00234 <span class="preprocessor"></span>
00235 
00236 <span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> int64;
00237 
00238 
00239 <span class="comment">/* since STD library lacks following functions in opposite to STL */</span>    
00240 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Tp&gt;
00241 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(_Tp&amp; __a, _Tp&amp; __b)
00242 { 
00243     _Tp __tmp = __a;
00244     __a = __b;
00245     __b = __tmp;
00246 }
00247 
00248 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIter&gt;
00249 <span class="keywordtype">bool</span> is_sorted(_ForwardIter __first, _ForwardIter __last)
00250 {
00251      <span class="keywordflow">if</span> (__first == __last)
00252           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00253 
00254      _ForwardIter __next = __first;
00255      <span class="keywordflow">for</span> (++__next; __next != __last; __first = __next, ++__next) {
00256       <span class="keywordflow">if</span> (*__next &lt; *__first)
00257             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00258        }
00259 
00260     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00261 }
00262 
00263 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _ForwardIter, <span class="keyword">class</span> _StrictWeakOrdering&gt;
00264 <span class="keywordtype">bool</span> is_sorted(_ForwardIter __first, _ForwardIter __last,
00265                                _StrictWeakOrdering __comp)
00266 {
00267         <span class="keywordflow">if</span> (__first == __last)
00268                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00269 
00270         _ForwardIter __next = __first;
00271         <span class="keywordflow">for</span> (++__next; __next != __last; __first = __next, ++__next) {
00272                 <span class="keywordflow">if</span> (__comp(*__next, *__first))
00273                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00274         }
00275         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00276         
00277 }
00278 
00279 __STXXL_END_NAMESPACE
00280 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Jul 1 11:08:36 2003 for &lt;stxxl&gt; by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
