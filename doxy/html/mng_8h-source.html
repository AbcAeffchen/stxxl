<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: mng.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>mng.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef MNG_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define MNG_HEADER</span>
00003 <span class="preprocessor"></span><span class="comment">/***************************************************************************</span>
00004 <span class="comment"> *            mng.h</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Sat Aug 24 23:55:27 2002</span>
00007 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00008 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00009 <span class="comment"> ****************************************************************************/</span>
00010 
00011 <span class="preprocessor">#include "../io/io.h"</span>
00012 <span class="preprocessor">#include "../common/rand.h"</span>
00013 <span class="preprocessor">#include "../common/aligned_alloc.h"</span>
00014 
00015 
00016 <span class="preprocessor">#include &lt;iostream&gt;</span>
00017 <span class="preprocessor">#include &lt;fstream&gt;</span>
00018 <span class="preprocessor">#include &lt;vector&gt;</span>
00019 <span class="preprocessor">#include &lt;list&gt;</span>
00020 <span class="preprocessor">#include &lt;map&gt;</span>
00021 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00022 <span class="preprocessor">#include &lt;string&gt;</span>
00023 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00024 
00025 
00026 __STXXL_BEGIN_NAMESPACE
00027 
00032 
00034         
00036         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE &gt; 
<a name="l00037"></a><a class="code" href="structstxxl_1_1BID.html">00037</a>   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1BID.html">BID</a>
00038         {
00039                 <span class="keyword">enum</span> 
00040                 {
00041                         size = SIZE  
00042                 };
<a name="l00043"></a><a class="code" href="structstxxl_1_1BID.html#o0">00043</a>                 <a class="code" href="classstxxl_1_1file.html">file</a> * storage; 
<a name="l00044"></a><a class="code" href="structstxxl_1_1BID.html#o1">00044</a>                 off_t offset; 
00045     <a class="code" href="structstxxl_1_1BID.html">BID</a>():storage(NULL),offset(0) {}
00046     <span class="keywordtype">bool</span> valid()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> storage; }
00047         };
00048 
00050         
00052         <span class="keyword">template</span> &lt;&gt; 
<a name="l00053"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html">00053</a>   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1BID.html">BID</a>&lt;0&gt;
00054         {
<a name="l00055"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html#o0">00055</a>                 <a class="code" href="classstxxl_1_1file.html">file</a> * storage; 
<a name="l00056"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html#o1">00056</a>                 off_t offset; 
<a name="l00057"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html#o2">00057</a>     <span class="keywordtype">unsigned</span> size;  
00058     <a class="code" href="structstxxl_1_1BID.html">BID</a>():storage(NULL),offset(0),size(0) {}
00059     <a class="code" href="structstxxl_1_1BID.html">BID</a>(<a class="code" href="classstxxl_1_1file.html">file</a> * f, off_t o, <span class="keywordtype">unsigned</span> s) : storage(f), offset(o), size(s) {}
00060     <span class="keywordtype">bool</span> valid()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> storage; }
00061         };
00062   
00063   <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> blk_sz&gt;
00064   <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> BID&lt;blk_sz&gt; &amp; a, <span class="keyword">const</span> BID&lt;blk_sz&gt; &amp; b)
00065   {
00066       <span class="keywordflow">return</span> (a.storage == b.storage) &amp;&amp; (a.offset == b.offset) &amp;&amp; (a.size == b.size);
00067   }
00068   
00069   <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> blk_sz&gt;
00070   std::ostream &amp; operator &lt;&lt; (std::ostream &amp; s, const BID&lt;blk_sz&gt; &amp; bid)
00071   {
00072     s &lt;&lt; <span class="stringliteral">" storage file addr: "</span>&lt;&lt;bid.storage;
00073     s &lt;&lt; <span class="stringliteral">" offset: "</span>&lt;&lt;bid.offset;
00074     s &lt;&lt; <span class="stringliteral">" size: "</span>&lt;&lt;bid.size;
00075     <span class="keywordflow">return</span> s;
00076   }
00077   
00078         
00079         <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> bytes&gt;
00080         <span class="keyword">class </span>filler_struct__
00081         {
00082                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte_type;
00083                 byte_type filler_array_[bytes];
00084         };
00085         
00086         <span class="keyword">template</span> &lt;&gt;
00087         <span class="keyword">class </span>filler_struct__&lt;0&gt;
00088         {
00089                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte_type;
00090         };
00091 
00093     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> Size_&gt;
<a name="l00094"></a><a class="code" href="classstxxl_1_1element__block.html">00094</a>     <span class="keyword">class </span><a class="code" href="classstxxl_1_1element__block.html">element_block</a>
00095     {
00096       <span class="keyword">public</span>:
00097                 <span class="keyword">typedef</span> T type;
00098                 <span class="keyword">typedef</span> T value_type;
00099                 <span class="keyword">typedef</span> T &amp; reference;
00100                 <span class="keyword">typedef</span> <span class="keyword">const</span> T &amp; const_reference;
00101                 <span class="keyword">typedef</span> type * pointer;
00102                 <span class="keyword">typedef</span> pointer iterator;
00103                 <span class="keyword">typedef</span> <span class="keyword">const</span> pointer const_iterator;
00104                 
00105         <span class="keyword">enum</span> 
00106         { 
00107             size = Size_ 
00108         };
00109       
<a name="l00111"></a><a class="code" href="classstxxl_1_1element__block.html#o0">00111</a>                 T elem[size];
00112                 
00113                 <a class="code" href="classstxxl_1_1element__block.html">element_block</a>() {}
00114         
<a name="l00116"></a><a class="code" href="classstxxl_1_1element__block.html#a1">00116</a>                 reference operator [](<span class="keywordtype">int</span> i)
00117                 {
00118                         <span class="keywordflow">return</span> elem[i];
00119                 }
00120 
<a name="l00122"></a><a class="code" href="classstxxl_1_1element__block.html#a2">00122</a>                 iterator begin()
00123                 {
00124                         <span class="keywordflow">return</span> elem;
00125                 }
<a name="l00127"></a><a class="code" href="classstxxl_1_1element__block.html#a3">00127</a>                 const_iterator begin()<span class="keyword"> const</span>
00128 <span class="keyword">                </span>{
00129                         <span class="keywordflow">return</span> elem;
00130                 }
<a name="l00132"></a><a class="code" href="classstxxl_1_1element__block.html#a4">00132</a>                 iterator end()
00133                 {
00134                         <span class="keywordflow">return</span> elem + size;
00135                 }
<a name="l00137"></a><a class="code" href="classstxxl_1_1element__block.html#a5">00137</a>                 const_iterator end()<span class="keyword"> const</span>
00138 <span class="keyword">                </span>{
00139                         <span class="keywordflow">return</span> elem + size;
00140                 }
00141     };
00142     
00144     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T,<span class="keywordtype">unsigned</span> Size_,<span class="keywordtype">unsigned</span> RawSize_, <span class="keywordtype">unsigned</span> NBids_ = 0&gt;
<a name="l00145"></a><a class="code" href="classstxxl_1_1block__w__bids.html">00145</a>     <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__w__bids.html">block_w_bids</a>: <span class="keyword">public</span> <a class="code" href="classstxxl_1_1element__block.html">element_block</a>&lt;T,Size_&gt;
00146     {
00147         <span class="keyword">public</span>:
00148          <span class="keyword">enum</span>
00149         {
00150             raw_size = RawSize_,
00151             nbids = NBids_
00152         };
00153          <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;raw_size&gt;</a> <a class="code" href="structstxxl_1_1BID.html">bid_type</a>;
00154          
<a name="l00156"></a><a class="code" href="classstxxl_1_1block__w__bids.html#o0">00156</a>          <a class="code" href="structstxxl_1_1BID.html">bid_type</a> ref[nbids];
00157                 
<a name="l00159"></a><a class="code" href="classstxxl_1_1block__w__bids.html#a0">00159</a>                  <a class="code" href="structstxxl_1_1BID.html">bid_type</a> &amp; operator ()(<span class="keywordtype">int</span> i)
00160                  {
00161                         <span class="keywordflow">return</span> ref[i];
00162                  }
00163     };
00164 
00165     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T,<span class="keywordtype">unsigned</span> Size_,<span class="keywordtype">unsigned</span> RawSize_&gt;
00166     <span class="keyword">class </span>block_w_bids&lt;T,Size_,RawSize_,0&gt;: <span class="keyword">public</span> element_block&lt;T,Size_&gt;
00167     {
00168         <span class="keyword">public</span>:
00169          <span class="keyword">enum</span>
00170         {
00171             raw_size = RawSize_,
00172             nbids = 0
00173         };
00174          <span class="keyword">typedef</span> BID&lt;raw_size&gt; bid_type;
00175     };    
00176   
00178     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T_,<span class="keywordtype">unsigned</span> RawSize_,<span class="keywordtype">unsigned</span> NBids_,<span class="keyword">class</span> InfoType_ = <span class="keywordtype">void</span>&gt;
<a name="l00179"></a><a class="code" href="classstxxl_1_1block__w__info.html">00179</a>     <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__w__info.html">block_w_info</a> : 
00180         <span class="keyword">public</span> <a class="code" href="classstxxl_1_1block__w__bids.html">block_w_bids</a>&lt;T_,((RawSize_ - sizeof(BID&lt;RawSize_&gt; )*NBids_ - sizeof(InfoType_))/sizeof(T_)),RawSize_,NBids_&gt;
00181     {
00182        <span class="keyword">public</span>:
<a name="l00184"></a><a class="code" href="classstxxl_1_1block__w__info.html#w0">00184</a>         <span class="keyword">typedef</span> InfoType_   <a class="code" href="classstxxl_1_1block__w__info.html#w0">info_type</a>;
00185        
<a name="l00187"></a><a class="code" href="classstxxl_1_1block__w__info.html#o0">00187</a>         <a class="code" href="classstxxl_1_1block__w__info.html#w0">info_type</a> info;
00188         
00189         <span class="keyword">enum</span> { size = ((RawSize_ - <span class="keyword">sizeof</span>(<a class="code" href="structstxxl_1_1BID.html">BID&lt;RawSize_&gt;</a>)*NBids_ - <span class="keyword">sizeof</span>(InfoType_) )/<span class="keyword">sizeof</span>(T_)) };
00190     };
00191     
00192     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T_,<span class="keywordtype">unsigned</span> RawSize_,<span class="keywordtype">unsigned</span> NBids_&gt;
00193     <span class="keyword">class </span>block_w_info&lt;T_,RawSize_,NBids_,void&gt; : 
00194         <span class="keyword">public</span> block_w_bids&lt;T_,((RawSize_ - sizeof(BID&lt;RawSize_&gt;)*NBids_)/sizeof(T_)),RawSize_,NBids_&gt;
00195     {
00196         <span class="keyword">public</span>:
00197         <span class="keyword">typedef</span> <span class="keywordtype">void</span>   info_type;
00198         <span class="keyword">enum</span> {size  = ((RawSize_ - <span class="keyword">sizeof</span>(BID&lt;RawSize_&gt;)*NBids_)/<span class="keyword">sizeof</span>(T_)) };
00199     };
00200     
00202     
00212     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> RawSize_, <span class="keyword">class</span> T_, <span class="keywordtype">unsigned</span> NRef_ = 0, <span class="keyword">class</span> InfoType_ = <span class="keywordtype">void</span>&gt;
<a name="l00213"></a><a class="code" href="classstxxl_1_1typed__block.html">00213</a>     <span class="keyword">class </span><a class="code" href="classstxxl_1_1typed__block.html">typed_block</a> : 
00214         <span class="keyword">public</span> <a class="code" href="classstxxl_1_1block__w__info.html">block_w_info</a>&lt;T_,RawSize_,NRef_,InfoType_&gt;,
00215         <span class="keyword">public</span> filler_struct__&lt;(RawSize_ - sizeof(block_w_info&lt;T_,RawSize_,NRef_,InfoType_&gt;)) &gt;
00216     {
00217       <span class="keyword">public</span>:
00218                 <span class="keyword">typedef</span> T_ type;
00219                 <span class="keyword">typedef</span> T_ value_type;
00220                 <span class="keyword">typedef</span> T_ &amp; reference;
00221                 <span class="keyword">typedef</span> <span class="keyword">const</span> T_ &amp; const_reference;
00222                 <span class="keyword">typedef</span> type * pointer;
00223                 <span class="keyword">typedef</span> pointer iterator;
00224                 <span class="keyword">typedef</span> <span class="keyword">const</span> pointer const_iterator;
00225                 
00226                 <span class="keyword">enum</span> { has_filler = (RawSize_ != <span class="keyword">sizeof</span>(<a class="code" href="classstxxl_1_1block__w__info.html">block_w_info&lt;T_,RawSize_,NRef_,InfoType_&gt;</a>) ) };
00227                 
00228                 <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;RawSize_&gt;</a> <a class="code" href="structstxxl_1_1BID.html">bid_type</a>;
00229                 
00230                 <a class="code" href="classstxxl_1_1typed__block.html">typed_block</a>() {};
00231 
00232                 <span class="keyword">enum</span>
00233                 { 
00234                         raw_size = RawSize_, 
00235                         size = <a class="code" href="classstxxl_1_1block__w__info.html">block_w_info&lt;T_,RawSize_,NRef_,InfoType_&gt;</a>::size 
00236                 };
00237                 
<a name="l00243"></a><a class="code" href="classstxxl_1_1typed__block.html#a1">00243</a>                 <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> write (<span class="keyword">const</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;raw_size&gt;</a> &amp; bid, 
00244                             <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl = <a class="code" href="structstxxl_1_1default__completion__handler.html">default_completion_handler</a>())
00245                 {
00246                         <span class="keywordflow">return</span> bid.<a class="code" href="structstxxl_1_1BID.html#o0">storage</a>-&gt;<a class="code" href="classstxxl_1_1file.html#a1">awrite</a>(
00247                                                 <span class="keyword">this</span>, 
00248                                                 bid.<a class="code" href="structstxxl_1_1BID.html#o1">offset</a>, 
00249                                                 raw_size, 
00250                                             on_cmpl);
00251                 };
00252 
<a name="l00258"></a><a class="code" href="classstxxl_1_1typed__block.html#a2">00258</a>                 <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> read (<span class="keyword">const</span> BID &lt; raw_size &gt; &amp;bid,
00259                            <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl = <a class="code" href="structstxxl_1_1default__completion__handler.html">default_completion_handler</a>())
00260                 {
00261                         <span class="keywordflow">return</span> bid.<a class="code" href="structstxxl_1_1BID.html#o0">storage</a>-&gt;<a class="code" href="classstxxl_1_1file.html#a0">aread</a>(<span class="keyword">this</span>, bid.<a class="code" href="structstxxl_1_1BID.html#o1">offset</a>, raw_size, on_cmpl);
00262                 };
00263                 
00264                 <span class="keywordtype">void</span> *operator      new[] (size_t bytes)
00265                 {
00266                         <span class="keywordflow">return</span> aligned_alloc &lt; BLOCK_ALIGN &gt; (bytes);
00267                 }
00268                 <span class="keywordtype">void</span> *operator      new (size_t bytes)
00269                 {
00270                         <span class="keywordflow">return</span> aligned_alloc &lt; BLOCK_ALIGN &gt; (bytes);
00271                 }
00272                 <span class="keywordtype">void</span> operator      delete (<span class="keywordtype">void</span> *ptr)
00273                 {
00274                         aligned_dealloc &lt; BLOCK_ALIGN &gt; (ptr);
00275                 }
00276                 <span class="keywordtype">void</span> operator      delete[] (<span class="keywordtype">void</span> *ptr)
00277                 {
00278                         aligned_dealloc &lt; BLOCK_ALIGN &gt; (ptr);
00279                 }
00280     };
00281  
00282         
00283 <span class="comment">/*</span>
00284 <span class="comment">template &lt;unsigned BLK_SIZE&gt;</span>
00285 <span class="comment">class BIDArray: public std::vector&lt; BID &lt;BLK_SIZE&gt; &gt;</span>
00286 <span class="comment">{</span>
00287 <span class="comment"> public:</span>
00288 <span class="comment">  BIDArray(std::vector&lt; BID &lt;BLK_SIZE&gt; &gt;::size_type size = 0) : std::vector&lt; BID &lt;BLK_SIZE&gt; &gt;(size) {};</span>
00289 <span class="comment">};</span>
00290 <span class="comment">*/</span>
00291 
00292         <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> BLK_SIZE&gt; 
00293     <span class="keyword">class </span>BIDArray
00294         {
00295         <span class="keyword">protected</span>:
00296                 <span class="keywordtype">unsigned</span> _size;
00297                 BID &lt; BLK_SIZE &gt; *array;
00298         <span class="keyword">public</span>:
00299                 <span class="keyword">typedef</span> BID&lt;BLK_SIZE&gt; &amp; reference;
00300                 <span class="keyword">typedef</span> BID&lt;BLK_SIZE&gt; * iterator;
00301                 <span class="keyword">typedef</span> <span class="keyword">const</span> BID&lt;BLK_SIZE&gt; * const_iterator;
00302                 BIDArray ():_size (0), array (NULL)
00303                 {
00304                 };
00305                 iterator begin ()
00306                 {
00307                         <span class="keywordflow">return</span> array;
00308                 };
00309                 iterator end ()
00310                 {
00311                         <span class="keywordflow">return</span> array + _size;
00312                 };
00313                 
00314           BIDArray (<span class="keywordtype">unsigned</span> size):_size (size)
00315                 {
00316                         array = <span class="keyword">new</span> BID &lt; BLK_SIZE &gt;[size];
00317                 };
00318                 <span class="keywordtype">unsigned</span> size ()
00319                 {
00320                         <span class="keywordflow">return</span> _size;
00321                 };
00322                 reference operator [](<span class="keywordtype">int</span> i)
00323                 {
00324                         <span class="keywordflow">return</span> array[i];
00325                 };
00326                 <span class="keywordtype">void</span> resize (<span class="keywordtype">unsigned</span> newsize)
00327                 {
00328                         <span class="keywordflow">if</span> (array)
00329                         {
00330                                 stxxl_debug (std::cerr &lt;&lt;
00331                                              <span class="stringliteral">"Warning: resizing nonempty BIDArray"</span>
00332                                              &lt;&lt; std::endl;)
00333                                 BID &lt; BLK_SIZE &gt; *tmp = array;
00334                                 array = <span class="keyword">new</span> BID &lt; BLK_SIZE &gt;[newsize];
00335                                 memcpy (array, tmp, <span class="keyword">sizeof</span> (BID &lt;BLK_SIZE &gt;) * STXXL_MIN (_size, newsize));
00336                                 <span class="keyword">delete</span> [] tmp;
00337                                 _size = newsize;
00338                         }
00339                         <span class="keywordflow">else</span>
00340                         {
00341                                 array = <span class="keyword">new</span> BID &lt; BLK_SIZE &gt;[newsize];
00342                                 _size = newsize;
00343                         }
00344                 };
00345                 ~BIDArray ()
00346                 {
00347                         <span class="keywordflow">if</span> (array)
00348                                 <span class="keyword">delete</span>[]array;
00349                 };
00350         };
00351 
00352 
00353         <span class="keyword">class </span>DiskAllocator
00354         {
00355                 <span class="keyword">typedef</span> std::pair &lt; off_t, off_t &gt; place;
00356                 <span class="keyword">struct </span>FirstFit:<span class="keyword">public</span> std::binary_function &lt; place, off_t,bool &gt;
00357                 {
00358                         <span class="keywordtype">bool</span> operator     () (
00359                                                                 <span class="keyword">const</span> place &amp; entry,
00360                                               <span class="keyword">const</span> off_t size)<span class="keyword"> const</span>
00361 <span class="keyword">                        </span>{
00362                                 <span class="keywordflow">return</span> (entry.second &gt;= size);
00363                         }
00364                 };
00365                 <span class="keyword">struct </span>OffCmp
00366                 {
00367                         <span class="keywordtype">bool</span> operator      () (<span class="keyword">const</span> off_t &amp; off1,<span class="keyword">const</span> off_t &amp; off2)
00368                         {
00369                                 <span class="keywordflow">return</span> off1 &lt; off2;
00370                         };
00371                 };
00372 
00373                 DiskAllocator ()
00374                 {
00375                 };
00376         <span class="keyword">protected</span>:
00377                 
00378                 <span class="keyword">typedef</span> std::map &lt; off_t, off_t &gt; sortseq;
00379                 sortseq free_space;
00380                 <span class="comment">//  sortseq used_space;</span>
00381                 off_t free_bytes;
00382                 off_t disk_bytes;
00383         
00384   <span class="keyword">public</span>:
00385                 DiskAllocator (off_t disk_size);
00386 
00387                 off_t get_free_bytes ()<span class="keyword"> const</span>
00388 <span class="keyword">                </span>{
00389                         <span class="keywordflow">return</span> free_bytes;
00390                 };
00391                 off_t get_used_bytes ()<span class="keyword"> const</span>
00392 <span class="keyword">                </span>{
00393                         <span class="keywordflow">return</span> disk_bytes - free_bytes;
00394                 };
00395 
00396                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00397                 <span class="keywordtype">void</span> new_blocks (BIDArray &lt; BLK_SIZE &gt; &amp;bids);
00398                 
00399                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00400                 <span class="keywordtype">void</span> delete_blocks (<span class="keyword">const</span> BIDArray &lt; BLK_SIZE &gt; &amp;bids);
00401                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt; 
00402                 <span class="keywordtype">void</span> delete_block (<span class="keyword">const</span> BID &lt;BLK_SIZE &gt; &amp; bid);
00403         };
00404 
00405   DiskAllocator::DiskAllocator (off_t disk_size):
00406                 free_bytes(disk_size),
00407                 disk_bytes(disk_size)
00408         {
00409                 free_space[0] = disk_size;
00410         }
00411 
00412   
00413   <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00414                 <span class="keywordtype">void</span> DiskAllocator::new_blocks (BIDArray &lt; BLK_SIZE &gt; &amp; bids)
00415         {
00416     STXXL_VERBOSE2(<span class="stringliteral">"DiskAllocator::new_blocks&lt;BLK_SIZE&gt;,  BLK_SIZE = "</span> &lt;&lt; BLK_SIZE
00417       &lt;&lt; <span class="stringliteral">", free:"</span> &lt;&lt; free_bytes &lt;&lt; <span class="stringliteral">" total:"</span>&lt;&lt; disk_bytes)
00418     
00419                 off_t requested_size = 0;
00420     <span class="keywordtype">unsigned</span> i = 0;
00421     <span class="keywordflow">for</span>(;i&lt;bids.size();i++)
00422     {
00423       STXXL_VERBOSE2(<span class="stringliteral">"Asking for a block with size: "</span>&lt;&lt;bids[i].size)
00424       <span class="comment">//assert(bids[i].size);</span>
00425       requested_size += bids[i].size;
00426     }
00427     
00428                 sortseq::iterator space = 
00429                         std::find_if (free_space.begin (), free_space.end (),
00430                                       bind2nd(FirstFit (), requested_size));
00431 
00432                 <span class="keywordflow">if</span> (space != free_space.end ())
00433                 {
00434                         off_t region_pos = (*space).first;
00435                         off_t region_size = (*space).second;
00436                         free_space.erase (space);
00437                         <span class="keywordflow">if</span> (region_size &gt; requested_size)
00438                                 free_space[region_pos + requested_size] = region_size - requested_size;
00439 
00440       bids[0].offset = region_pos;
00441                         <span class="keywordflow">for</span> (i = 1; i &lt; bids.size (); i++)
00442                         {
00443                                 bids[i].offset = bids[i-1].offset + bids[i-1].size;
00444                         }
00445                         free_bytes -= requested_size;
00446                 }
00447                 <span class="keywordflow">else</span>
00448                 {
00449                         STXXL_ERRMSG( <span class="stringliteral">"Allocation error: "</span> &lt;&lt; requested_size &lt;&lt;
00450                                 <span class="stringliteral">" bytes requested, "</span> &lt;&lt; free_bytes &lt;&lt;
00451                                 <span class="stringliteral">" bytes free"</span> )
00452                         abort();
00453                 }
00454         }
00455   
00456 
00457 
00458         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00459                 <span class="keywordtype">void</span> DiskAllocator::delete_block (<span class="keyword">const</span> BID &lt; BLK_SIZE &gt; &amp;bid)
00460         {
00461     STXXL_VERBOSE2(<span class="stringliteral">"DiskAllocator::delete_block&lt;BLK_SIZE&gt;,  BLK_SIZE = "</span> &lt;&lt; BLK_SIZE
00462       &lt;&lt; <span class="stringliteral">", free:"</span> &lt;&lt; free_bytes &lt;&lt; <span class="stringliteral">" total:"</span>&lt;&lt; disk_bytes)
00463     STXXL_VERBOSE2(<span class="stringliteral">"Deallocating a block with size: "</span>&lt;&lt;bid.size)
00464     <span class="comment">//assert(bid.size);</span>
00465                 off_t region_pos = bid.offset;
00466                 off_t region_size = bid.size;
00467                 sortseq::iterator succ = free_space.upper_bound (region_pos);
00468                 sortseq::iterator pred = succ;
00469                 pred--;
00470                 <span class="keywordflow">if</span> (succ != free_space.end ()
00471                     &amp;&amp; (*succ).first == region_pos + region_size)
00472                 {
00473                         <span class="comment">// coalesce with successor</span>
00474                         region_size += (*succ).second;
00475                         free_space.erase (succ);
00476                 }
00477                 <span class="keywordflow">if</span> (pred != free_space.end ()
00478                     &amp;&amp; (*pred).first + (*pred).second == region_pos)
00479                 {
00480                         <span class="comment">// coalesce with predecessor</span>
00481                         region_size += (*pred).second;
00482                         region_pos = (*pred).first;
00483                         free_space.erase (pred);
00484                 }
00485 
00486                 free_space[region_pos] = region_size;
00487                 free_bytes += off_t (bid.size);
00488         }
00489 
00490         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00491                 <span class="keywordtype">void</span> DiskAllocator::delete_blocks (<span class="keyword">const</span> BIDArray &lt; BLK_SIZE &gt; &amp;bids)
00492         {
00493                 STXXL_VERBOSE2(<span class="stringliteral">"DiskAllocator::delete_blocks&lt;BLK_SIZE&gt; BLK_SIZE="</span>&lt;&lt; BLK_SIZE &lt;&lt;
00494       <span class="stringliteral">", free:"</span> &lt;&lt; free_bytes &lt;&lt; <span class="stringliteral">" total:"</span>&lt;&lt; disk_bytes )
00495     
00496     <span class="keywordtype">unsigned</span> i=0;
00497                 <span class="keywordflow">for</span> (; i &lt; bids.size (); i++)
00498                 {
00499                         off_t region_pos = bids[i].offset;
00500                         off_t region_size = bids[i].size;
00501       STXXL_VERBOSE2(<span class="stringliteral">"Deallocating a block with size: "</span>&lt;&lt;region_size)
00502       assert(bids[i].size);
00503       
00504                         sortseq::iterator succ =
00505                                 free_space.upper_bound (region_pos);
00506                         sortseq::iterator pred = succ;
00507                         pred--;
00508 
00509                         <span class="keywordflow">if</span> (succ != free_space.end ()
00510                             &amp;&amp; (*succ).first == region_pos + region_size)
00511                         {
00512                                 <span class="comment">// coalesce with successor</span>
00513 
00514                                 region_size += (*succ).second;
00515                                 free_space.erase (succ);
00516                         }
00517                         <span class="keywordflow">if</span> (pred != free_space.end ()
00518                             &amp;&amp; (*pred).first + (*pred).second == region_pos)
00519                         {
00520                                 <span class="comment">// coalesce with predecessor</span>
00521 
00522                                 region_size += (*pred).second;
00523                                 region_pos = (*pred).first;
00524                                 free_space.erase (pred);
00525                         }
00526 
00527                         free_space[region_pos] = region_size;
00528                 };
00529     <span class="keywordflow">for</span>(;i&lt;bids.size();i++)
00530       free_bytes += off_t(bids[i].size);
00531         }
00532 
<a name="l00535"></a><a class="code" href="classstxxl_1_1config.html">00535</a>         <span class="keyword">class </span><a class="code" href="classstxxl_1_1config.html">config</a>
00536         {
00537                 <span class="keyword">struct </span>DiskEntry
00538                 {
00539                         std::string path;
00540                         std::string io_impl;
00541                         off_t size;
00542                 };
00543                 std::vector &lt; DiskEntry &gt; disks_props;
00544                 
00545                 <a class="code" href="classstxxl_1_1config.html">config</a> (<span class="keyword">const</span> <span class="keywordtype">char</span> *config_path = <span class="stringliteral">"./.stxxl"</span>);
00546          <span class="keyword">public</span>:
<a name="l00549"></a><a class="code" href="classstxxl_1_1config.html#a0">00549</a>                 <span class="keywordtype">unsigned</span> <a class="code" href="classstxxl_1_1config.html#a0">disks_number</a>()
00550                 {
00551                         <span class="keywordflow">return</span> disks_props.size ();
00552                 };
00553                 
00554                 <span class="keywordtype">unsigned</span> ndisks()
00555                 {
00556                         <span class="keywordflow">return</span> disks_props.size ();
00557                 };
00558                 
<a name="l00562"></a><a class="code" href="classstxxl_1_1config.html#a2">00562</a>                 <span class="keyword">const</span> std::string &amp; <a class="code" href="classstxxl_1_1config.html#a2">disk_path</a> (<span class="keywordtype">int</span> disk)
00563                 {
00564                         <span class="keywordflow">return</span> disks_props[disk].path;
00565                 };
<a name="l00569"></a><a class="code" href="classstxxl_1_1config.html#a3">00569</a>                 off_t <a class="code" href="classstxxl_1_1config.html#a3">disk_size</a> (<span class="keywordtype">int</span> disk)
00570                 {
00571                         <span class="keywordflow">return</span> disks_props[disk].size;
00572                 };
<a name="l00575"></a><a class="code" href="classstxxl_1_1config.html#a4">00575</a>                 <span class="keyword">const</span> std::string &amp; <a class="code" href="classstxxl_1_1config.html#a4">disk_io_impl</a> (<span class="keywordtype">int</span> disk)
00576                 {
00577                         <span class="keywordflow">return</span> disks_props[disk].io_impl;
00578                 };
00579 
00582                 <span class="keyword">static</span> <a class="code" href="classstxxl_1_1config.html">config</a> *<a class="code" href="group__mnglayer.html#a10">get_instance</a> ();
00583         <span class="keyword">private</span>:
00584                 <span class="keyword">static</span> <a class="code" href="classstxxl_1_1config.html">config</a> *instance;
00585         };
00586 
00587 
<a name="l00588"></a><a class="code" href="classstxxl_1_1config.html#a10">00588</a>         <a class="code" href="classstxxl_1_1config.html">config</a> *config::get_instance ()
00589         {
00590                 <span class="keywordflow">if</span> (!instance)
00591                 {
00592                         <span class="keywordtype">char</span> *cfg_path = getenv (<span class="stringliteral">"STXXLCFG"</span>);
00593                         <span class="keywordflow">if</span> (cfg_path)
00594                                 instance = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1config.html">config</a> (cfg_path);
00595                         <span class="keywordflow">else</span>
00596                                 instance = <span class="keyword">new</span> config ();
00597                 }
00598 
00599                 <span class="keywordflow">return</span> instance;
00600         }
00601 
00602 
00603         config::config (<span class="keyword">const</span> <span class="keywordtype">char</span> *config_path)
00604         {
00605                 std::ifstream cfg_file (config_path);
00606                 <span class="keywordflow">if</span> (!cfg_file)
00607                 {
00608                         STXXL_ERRMSG(<span class="stringliteral">"Warning: no config file found."</span> )
00609                         STXXL_ERRMSG(<span class="stringliteral">"Using default disk configuration."</span> )
00610                         DiskEntry entry1 = { <span class="stringliteral">"/var/tmp/stxxl"</span>, <span class="stringliteral">"syscall"</span>,
00611                                 100 * 1024 * 1024
00612                         }; <span class="comment">/*</span>
00613 <span class="comment">                        DiskEntry entry2 =</span>
00614 <span class="comment">                                { "/tmp/stxxl1", "mmap", 100 * 1024 * 1024 };</span>
00615 <span class="comment">                        DiskEntry entry3 = { "/tmp/stxxl2", "simdisk",</span>
00616 <span class="comment">                                100 * 1024 * 1024</span>
00617 <span class="comment">                        }; */</span>
00618                         disks_props.push_back (entry1);
00619                         <span class="comment">//disks_props.push_back (entry2);</span>
00620                         <span class="comment">//disks_props.push_back (entry3);</span>
00621                 }
00622                 <span class="keywordflow">else</span>
00623                 {
00624                         std::string line;
00625 
00626                         <span class="keywordflow">while</span> (cfg_file &gt;&gt; line)
00627                         {
00628                                 std::vector &lt; std::string &gt; tmp = split (line, <span class="stringliteral">"="</span>);
00629                                 
00630                                 <span class="keywordflow">if</span>(tmp[0][0] == <span class="charliteral">'#'</span>)
00631                                 {
00632                                 }
00633                                 <span class="keywordflow">else</span>
00634                                 <span class="keywordflow">if</span> (tmp[0] == <span class="stringliteral">"disk"</span>)
00635                                 {
00636                                         tmp = split (tmp[1], <span class="stringliteral">","</span>);
00637                                         DiskEntry entry = { tmp[0], tmp[2],
00638                                                         off_t (str2int (tmp[1])) *
00639                                                         off_t (1024 * 1024)
00640                                         };
00641                                         disks_props.push_back (entry);
00642                                 }
00643                                 <span class="keywordflow">else</span>
00644                                 {
00645                                         std::cerr &lt;&lt; <span class="stringliteral">"Unknown token "</span> &lt;&lt;
00646                                                 tmp[0] &lt;&lt; std::endl;
00647                                 }
00648                         }
00649                         cfg_file.close ();
00650                 }
00651 
00652                 <span class="keywordflow">if</span> (disks_props.empty ())
00653                 {
00654                         STXXL_ERRMSG( <span class="stringliteral">"No disks found in '"</span> &lt;&lt; config_path &lt;&lt; <span class="stringliteral">"' ."</span> )
00655                         abort ();
00656                 }
00657                 <span class="keywordflow">else</span>
00658                 {
00659                         <span class="keywordflow">for</span> (std::vector &lt; DiskEntry &gt;::const_iterator it =
00660                              disks_props.begin (); it != disks_props.end ();
00661                              it++)
00662                         {
00663                                 STXXL_MSG(<span class="stringliteral">"Disk '"</span> &lt;&lt; (*it).path &lt;&lt; <span class="stringliteral">"' is allocated, space: "</span> &lt;&lt;
00664                                         ((*it).size) / (1024 * 1024) &lt;&lt;
00665                                         <span class="stringliteral">" Mb, I/O implementation: "</span> &lt;&lt; (*it).io_impl )
00666                         }
00667                 }
00668         };
00669 
00670         <span class="keyword">class </span>FileCreator
00671         {
00672         <span class="keyword">public</span>:
00673                 <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1file.html">stxxl::file</a> * create (<span class="keyword">const</span> std::string &amp; io_impl,
00674                                               <span class="keyword">const</span> std::string &amp; filename,
00675                                               <span class="keywordtype">int</span> options, <span class="keywordtype">int</span> disk)
00676                 {
00677                         <span class="keywordflow">if</span> (io_impl == <span class="stringliteral">"syscall"</span>)
00678                                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstxxl_1_1syscall__file.html">stxxl::syscall_file</a> (filename,
00679                                                                 options,
00680                                                                 disk);
00681                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (io_impl == <span class="stringliteral">"mmap"</span>)
00682                                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstxxl_1_1mmap__file.html">stxxl::mmap_file</a> (filename,
00683                                                              options, disk);
00684                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (io_impl == <span class="stringliteral">"simdisk"</span>)
00685                                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstxxl_1_1sim__disk__file.html">stxxl::sim_disk_file</a> (filename,
00686                                                                  options,
00687                                                                  disk);
00688 
00689                         STXXL_ERRMSG(<span class="stringliteral">"Unsupported disk I/O implementation "</span> &lt;&lt;
00690                                 io_impl &lt;&lt; <span class="stringliteral">" ."</span> )
00691                         abort ();
00692 
00693                         <span class="keywordflow">return</span> NULL;
00694                 };
00695         };
00696   
00700 
<a name="l00703"></a><a class="code" href="structstxxl_1_1striping.html">00703</a>         <span class="keyword">struct </span><a class="code" href="structstxxl_1_1striping.html">striping</a>
00704         {
00705                 <span class="keywordtype">int</span> begin, diff;
00706                 <a class="code" href="structstxxl_1_1striping.html">striping</a> (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):begin (b), diff (e - b)
00707                 {
00708                 };
00709           <a class="code" href="structstxxl_1_1striping.html">striping</a> ():begin (0)
00710                 {
00711                         diff = config::get_instance ()-&gt;<a class="code" href="classstxxl_1_1config.html#a0">disks_number</a> ();
00712                 };
00713                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00714 <span class="keyword">                </span>{
00715                         <span class="keywordflow">return</span> begin + i % diff;
00716                 };
00717                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00718                 {
00719                         <span class="keywordflow">return</span> <span class="stringliteral">"striping"</span>;
00720                 }
00721         };
00722 
<a name="l00725"></a><a class="code" href="structstxxl_1_1FR.html">00725</a>         <span class="keyword">struct </span><a class="code" href="structstxxl_1_1FR.html">FR</a>:<span class="keyword">public</span> <a class="code" href="structstxxl_1_1striping.html">striping</a>
00726         {
00727                 random_number&lt;random_uniform_fast&gt; rnd;
00728                 <a class="code" href="structstxxl_1_1FR.html">FR</a> (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):<a class="code" href="structstxxl_1_1striping.html">striping</a> (b, e)
00729                 {
00730                 };
00731           <a class="code" href="structstxxl_1_1FR.html">FR</a> ():<a class="code" href="structstxxl_1_1striping.html">striping</a> ()
00732                 {
00733                 };
00734                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00735 <span class="keyword">                </span>{
00736                         <span class="keywordflow">return</span> begin + rnd(diff);
00737                 }
00738                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00739                 {
00740                         <span class="keywordflow">return</span> <span class="stringliteral">"fully randomized striping"</span>;
00741                 }
00742         };
00743 
<a name="l00746"></a><a class="code" href="structstxxl_1_1SR.html">00746</a>         <span class="keyword">struct </span><a class="code" href="structstxxl_1_1SR.html">SR</a>:<span class="keyword">public</span> <a class="code" href="structstxxl_1_1striping.html">striping</a>
00747         {
00748                 random_number&lt;random_uniform_fast&gt; rnd;
00749                 <span class="keywordtype">int</span> offset;
00750                 <a class="code" href="structstxxl_1_1SR.html">SR</a> (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):<a class="code" href="structstxxl_1_1striping.html">striping</a> (b, e)
00751                 {
00752                         offset = rnd(diff);
00753                 };
00754                 <a class="code" href="structstxxl_1_1SR.html">SR</a>():<a class="code" href="structstxxl_1_1striping.html">striping</a> ()
00755                 {
00756                         offset = rnd(diff);
00757                 };
00758                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00759 <span class="keyword">                </span>{
00760                         <span class="keywordflow">return</span> begin + (i + offset) % diff;
00761                 }
00762                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00763                 {
00764                         <span class="keywordflow">return</span> <span class="stringliteral">"simple randomized striping"</span>;
00765                 }
00766         };
00767 
<a name="l00770"></a><a class="code" href="structstxxl_1_1RC.html">00770</a>         <span class="keyword">struct </span><a class="code" href="structstxxl_1_1RC.html">RC</a>:<span class="keyword">public</span> <a class="code" href="structstxxl_1_1striping.html">striping</a>
00771         {
00772                 std::vector&lt;int&gt; perm;
00773                  
00774                 <a class="code" href="structstxxl_1_1RC.html">RC</a> (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):<a class="code" href="structstxxl_1_1striping.html">striping</a> (b, e), perm (diff)
00775                 {
00776                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; diff; i++)
00777                                 perm[i] = i;
00778 
00779                         stxxl::random_number&lt;random_uniform_fast&gt; rnd;
00780                         std::random_shuffle (perm.begin (), perm.end (), rnd);
00781                 }
00782                 <a class="code" href="structstxxl_1_1RC.html">RC</a> ():<a class="code" href="structstxxl_1_1striping.html">striping</a> (), perm (diff)
00783                 {
00784                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; diff; i++)
00785                                 perm[i] = i;
00786 
00787                         random_number&lt;random_uniform_fast&gt; rnd;
00788                         std::random_shuffle (perm.begin (), perm.end (), rnd);
00789                 }
00790                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00791 <span class="keyword">                </span>{
00792                         <span class="keywordflow">return</span> begin + perm[i % diff];
00793                 }
00794                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00795                 {
00796                         <span class="keywordflow">return</span> <span class="stringliteral">"randomized cycling striping"</span>;
00797                 }
00798         };
00799 
<a name="l00802"></a><a class="code" href="structstxxl_1_1single__disk.html">00802</a>         <span class="keyword">struct </span><a class="code" href="structstxxl_1_1single__disk.html">single_disk</a>
00803         {
00804                 <span class="keyword">const</span> <span class="keywordtype">int</span> disk;
00805                 <a class="code" href="structstxxl_1_1single__disk.html">single_disk</a>(<span class="keywordtype">int</span> d):disk(d)
00806                 {
00807                 };
00808           
00809     <a class="code" href="structstxxl_1_1single__disk.html">single_disk</a>():disk(0)
00810                 {
00811                 };
00812                 <span class="keywordtype">int</span> operator() (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00813 <span class="keyword">                </span>{
00814                         <span class="keywordflow">return</span> disk;
00815                 };
00816                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00817                 {
00818                         <span class="keywordflow">return</span> <span class="stringliteral">"single disk"</span>;
00819                 }
00820         };
00821   
00823   
00825   <span class="keyword">template</span> &lt;<span class="keyword">class</span> BaseAllocator_&gt;
<a name="l00826"></a><a class="code" href="structstxxl_1_1offset__allocator.html">00826</a>   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1offset__allocator.html">offset_allocator</a>
00827   {
00828     BaseAllocator_ base;
00829     <span class="keywordtype">int</span> offset;
<a name="l00833"></a><a class="code" href="structstxxl_1_1offset__allocator.html#a0">00833</a>     <a class="code" href="structstxxl_1_1offset__allocator.html#a0">offset_allocator</a>(<span class="keywordtype">int</span> offset_) : base(),offset(offset_) {}
<a name="l00838"></a><a class="code" href="structstxxl_1_1offset__allocator.html#a1">00838</a>     <a class="code" href="structstxxl_1_1offset__allocator.html#a0">offset_allocator</a>(<span class="keywordtype">int</span> offset_,BaseAllocator_ &amp; base_) : base(base_),offset(offset_) {}
00839     <span class="keywordtype">int</span> operator() (<span class="keywordtype">int</span> i)
00840     {
00841       <span class="keywordflow">return</span> base(offset + i);
00842     }
00843   };
00844 
00846   
00848         <span class="keyword">template</span> &lt; <span class="keyword">class</span> bid_it &gt; 
<a name="l00849"></a><a class="code" href="structstxxl_1_1bid__iterator__traits.html">00849</a>   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1bid__iterator__traits.html">bid_iterator_traits</a>
00850         {
00851                 bid_it *a;
00852                 <span class="keyword">enum</span>
00853                 {
00854                         block_size = bid_it::block_size
00855                 };
00856         };
00857 
00858         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz &gt; 
00859   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1bid__iterator__traits.html">bid_iterator_traits</a> &lt;BID &lt;blk_sz &gt; *&gt;
00860         {
00861                 <span class="keyword">enum</span>
00862                 {
00863                         block_size = blk_sz
00864                 };
00865         };
00866 
00867 <span class="comment">/*</span>
00868 <span class="comment">        template &lt; unsigned _blk_sz &gt; struct bid_iterator_traits&lt;</span>
00869 <span class="comment">                std::__normal_iterator&lt; BID&lt;_blk_sz&gt; * ,std::vector&lt; BID&lt;_blk_sz&gt; ,std::allocator&lt;BID&lt;_blk_sz&gt; &gt; &gt;  &gt; &gt;</span>
00870 <span class="comment">                         </span>
00871 <span class="comment">        {</span>
00872 <span class="comment">                enum</span>
00873 <span class="comment">                {</span>
00874 <span class="comment">                        block_size = _blk_sz</span>
00875 <span class="comment">                };      </span>
00876 <span class="comment">        };</span>
00877 <span class="comment">*/</span>
00878 <span class="comment">/*</span>
00879 <span class="comment">        template &lt; unsigned _blk_sz &gt; struct bid_iterator_traits&lt;</span>
00880 <span class="comment">                __gnu_cxx::__normal_iterator&lt; BID&lt;_blk_sz&gt; * ,std::vector&lt; BID&lt;_blk_sz&gt; ,std::allocator&lt;BID&lt;_blk_sz&gt; &gt; &gt;  &gt; &gt;</span>
00881 <span class="comment">        {</span>
00882 <span class="comment">                enum</span>
00883 <span class="comment">                {</span>
00884 <span class="comment">                        block_size = _blk_sz</span>
00885 <span class="comment">                };      </span>
00886 <span class="comment">        };      */</span>
00887   
00888   <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz,<span class="keyword">class</span> X &gt; 
00889   <span class="keyword">struct </span>bid_iterator_traits&lt; __gnu_cxx::__normal_iterator&lt; BID&lt;blk_sz&gt; *,  X&gt; &gt;
00890         {
00891                 <span class="keyword">enum</span>
00892                 {
00893                         block_size = blk_sz
00894                 };      
00895         };
00896   
00897   <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz,<span class="keyword">class</span> X , <span class="keyword">class</span> Y&gt; 
00898   <span class="keyword">struct </span>bid_iterator_traits&lt; std::_List_iterator&lt;BID&lt;blk_sz&gt;,X,Y &gt; &gt;
00899         {
00900                 <span class="keyword">enum</span>
00901                 {
00902                         block_size = blk_sz
00903                 };      
00904         }; 
00905   
00906   <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz, <span class="keyword">class</span> X &gt; 
00907   <span class="keyword">struct </span>bid_iterator_traits&lt; typename std::vector&lt; BID&lt;blk_sz&gt; , X &gt;::iterator &gt;
00908         {
00909                 <span class="keyword">enum</span>
00910                 {
00911                         block_size = blk_sz
00912                 };      
00913         };
00914 
00916         
<a name="l00919"></a><a class="code" href="classstxxl_1_1block__manager.html">00919</a>         <span class="keyword">class </span><a class="code" href="classstxxl_1_1block__manager.html">block_manager</a>
00920         {
00921                 DiskAllocator **disk_allocators;
00922                 <a class="code" href="classstxxl_1_1file.html">file</a> ** disk_files;
00923                 
00924                 <span class="keywordtype">unsigned</span> ndisks;
00925                 <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> ();
00926         
00927         <span class="keyword">public</span>:
00930                 <span class="keyword">static</span> <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *<a class="code" href="group__mnglayer.html#a12">get_instance</a> ();
00931 
00933                 
00940                 <span class="keyword">template</span> &lt; <span class="keyword">class</span> DiskAssgnFunctor, <span class="keyword">class</span> BIDIteratorClass &gt;
00941                 <span class="keywordtype">void</span> <a class="code" href="group__mnglayer.html#a15">new_blocks</a> (
00942                                          DiskAssgnFunctor functor,
00943                                          <span class="keyword">const</span> BIDIteratorClass &amp; bidbegin,
00944                                          <span class="keyword">const</span> BIDIteratorClass &amp; bidend);
00945 
00947                 
00951                 <span class="keyword">template</span> &lt; <span class="keyword">class</span> BIDIteratorClass &gt;
00952                 <span class="keywordtype">void</span> <a class="code" href="group__mnglayer.html#a17">delete_blocks</a> (<span class="keyword">const</span> BIDIteratorClass &amp; bidbegin, <span class="keyword">const</span> BIDIteratorClass &amp; bidend);
00953 
00956                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00957           <span class="keywordtype">void</span> <a class="code" href="group__mnglayer.html#a16">delete_block</a> (<span class="keyword">const</span> BID &lt; BLK_SIZE &gt; &amp;bid);
00958 
00959                 ~<a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> ();
00960         <span class="keyword">private</span>:
00961                 <span class="keyword">static</span> <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *instance;
00962         };
00963 
<a name="l00964"></a><a class="code" href="classstxxl_1_1block__manager.html#a12">00964</a>         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *block_manager::get_instance ()
00965         {
00966                 <span class="keywordflow">if</span> (!instance)
00967                         instance = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> ();
00968 
00969                 <span class="keywordflow">return</span> instance;
00970         }
00971 
00972         block_manager::block_manager ()
00973         {
00974                 FileCreator fc;
00975                 <a class="code" href="classstxxl_1_1config.html">config</a> *cfg = config::get_instance ();
00976 
00977                 ndisks = cfg-&gt;<a class="code" href="classstxxl_1_1config.html#a0">disks_number</a> ();
00978                 disk_allocators = <span class="keyword">new</span> DiskAllocator *[ndisks];
00979                 disk_files = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1file.html">stxxl::file</a> *[ndisks];
00980 
00981                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; ndisks; i++)
00982                 {
00983                         disk_files[i] = fc.create (cfg-&gt;<a class="code" href="classstxxl_1_1config.html#a4">disk_io_impl</a> (i),
00984                                                    cfg-&gt;<a class="code" href="classstxxl_1_1config.html#a2">disk_path</a> (i),
00985                                                    <a class="code" href="classstxxl_1_1file.html#w6w3">stxxl::file::CREAT</a> | <a class="code" href="classstxxl_1_1file.html#w6w2">stxxl::file::RDWR</a>  | <a class="code" href="classstxxl_1_1file.html#w6w4">stxxl::file::DIRECT</a>
00986                                                    ,i);
00987                         disk_files[i]-&gt;<a class="code" href="classstxxl_1_1file.html#a2">set_size</a> (cfg-&gt;<a class="code" href="classstxxl_1_1config.html#a3">disk_size</a> (i));
00988                         disk_allocators[i] = <span class="keyword">new</span> DiskAllocator (cfg-&gt;<a class="code" href="classstxxl_1_1config.html#a3">disk_size</a> (i));
00989                 }
00990         };
00991 
00992         block_manager::~block_manager()
00993         {
00994                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; ndisks; i++)
00995                 {
00996                         <span class="keyword">delete</span> disk_allocators[i];
00997                         <span class="keyword">delete</span> disk_files[i];
00998                 }
00999                 <span class="keyword">delete</span>[]disk_allocators;
01000                 <span class="keyword">delete</span>[]disk_files;
01001         }
01002 
01003 
01004         <span class="keyword">template</span> &lt; <span class="keyword">class</span> DiskAssgnFunctor, <span class="keyword">class</span> BIDIteratorClass &gt;
<a name="l01005"></a><a class="code" href="classstxxl_1_1block__manager.html#a15">01005</a>                 <span class="keywordtype">void</span> block_manager::new_blocks (
01006                                                 DiskAssgnFunctor functor,
01007                                                 <span class="keyword">const</span> BIDIteratorClass &amp; bidbegin,
01008                                                 <span class="keyword">const</span> BIDIteratorClass &amp; bidend)
01009         {
01010     <span class="keyword">typedef</span>  BIDArray&lt;bid_iterator_traits &lt;BIDIteratorClass &gt;::block_size&gt; bid_array_type;
01011                 <span class="keywordtype">unsigned</span> nblocks = 0;<span class="comment">//std::distance(bidbegin,bidend);</span>
01012     
01013     BIDIteratorClass bidbegin_copy(bidbegin);
01014     <span class="keywordflow">while</span>(bidbegin_copy != bidend)
01015     {
01016       ++bidbegin_copy;
01017       ++nblocks;
01018     }
01019 
01020                 <span class="keywordtype">int</span> *bl = <span class="keyword">new</span> <span class="keywordtype">int</span>[ndisks];
01021                 bid_array_type * disk_bids = <span class="keyword">new</span> bid_array_type[ndisks];
01022 
01023                 memset(bl, 0, ndisks * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
01024 
01025                 <span class="keywordtype">unsigned</span> i = 0;
01026                 BIDIteratorClass it = bidbegin;
01027                 <span class="keywordflow">for</span> (; i &lt; nblocks; i++, it++)
01028                 {
01029                         <span class="keywordtype">int</span> disk = functor (i);
01030                         (*it).storage = disk_files[disk];
01031                         bl[disk]++;
01032                 }
01033 
01034                 <span class="keywordflow">for</span> (i = 0; i &lt; ndisks; i++)
01035                 {
01036                         <span class="keywordflow">if</span> (bl[i])
01037                                 disk_bids[i].resize (bl[i]);
01038                 }
01039     
01040     memset (bl, 0, ndisks * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
01041     
01042                 <span class="keywordflow">for</span> (i=0,it = bidbegin; it != bidend; it++, i++)
01043                 {
01044                         <span class="keywordtype">int</span> disk = (*it).storage-&gt;get_disk_number ();
01045                         disk_bids[disk][bl[disk]++] = (*it);
01046                 }
01047     <span class="keywordflow">for</span> (i = 0; i &lt; ndisks; i++)
01048                 {
01049                         <span class="keywordflow">if</span> (bl[i])
01050                                 disk_allocators[i]-&gt;new_blocks (disk_bids[i]);
01051                 }
01052 
01053                 memset (bl, 0, ndisks * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
01054     
01055                 <span class="keywordflow">for</span> (i=0,it = bidbegin; it != bidend; it++, i++)
01056                 {
01057                         <span class="keywordtype">int</span> disk = (*it).storage-&gt;get_disk_number ();
01058                         (*it).offset = disk_bids[disk][bl[disk]++].offset;
01059                 }
01060 
01061                 <span class="keyword">delete</span>[]bl;
01062                 <span class="keyword">delete</span>[]disk_bids;
01063         }
01064 
01065 
01066 
01067         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
<a name="l01068"></a><a class="code" href="classstxxl_1_1block__manager.html#a16">01068</a>         <span class="keywordtype">void</span> block_manager::delete_block (<span class="keyword">const</span> BID &lt; BLK_SIZE &gt; &amp;bid)
01069         {
01070                 disk_allocators[bid.<a class="code" href="structstxxl_1_1BID.html#o0">storage</a>-&gt;<a class="code" href="classstxxl_1_1file.html#a4">get_disk_number</a> ()]-&gt;delete_block (bid);
01071         }
01072 
01073 
01074         <span class="keyword">template</span> &lt; <span class="keyword">class</span> BIDIteratorClass &gt;
<a name="l01075"></a><a class="code" href="classstxxl_1_1block__manager.html#a17">01075</a>                 <span class="keywordtype">void</span> block_manager::delete_blocks (
01076                                                 <span class="keyword">const</span> BIDIteratorClass &amp; bidbegin,
01077                               <span class="keyword">const</span> BIDIteratorClass &amp; bidend)
01078         {
01079                 <span class="keywordflow">for</span> (BIDIteratorClass it = bidbegin; it != bidend; it++)
01080                 {
01081                         <a class="code" href="group__mnglayer.html#a16">delete_block</a> (*it);
01082                 }
01083         }
01084 
01085         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *block_manager::instance = NULL;
01086         <a class="code" href="classstxxl_1_1config.html">config</a> *config::instance = NULL;
01087 
01088 <span class="preprocessor">  #define STXXL_DEFAULT_ALLOC_STRATEGY RC   </span>
01089 <span class="preprocessor"></span><span class="preprocessor">  #define STXXL_DEFAULT_BLOCK_SIZE(type) (2*1024*1024)  // use traits</span>
01090 <span class="preprocessor"></span>  
01092   
01093 __STXXL_END_NAMESPACE
01094 
01095 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Nov 21 15:28:11 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
