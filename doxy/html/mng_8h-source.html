<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mng.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>mng.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef MNG_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define MNG_HEADER</span>
00003 <span class="preprocessor"></span><span class="comment">/***************************************************************************</span>
00004 <span class="comment"> *            mng.h</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Sat Aug 24 23:55:27 2002</span>
00007 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00008 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00009 <span class="comment"> ****************************************************************************/</span>
00010 
00011 <span class="preprocessor">#include "../io/io.h"</span>
00012 <span class="preprocessor">#include "../common/rand.h"</span>
00013 <span class="preprocessor">#include "../common/aligned_alloc.h"</span>
00014 
00015 
00016 <span class="preprocessor">#include &lt;iostream&gt;</span>
00017 <span class="preprocessor">#include &lt;fstream&gt;</span>
00018 <span class="preprocessor">#include &lt;vector&gt;</span>
00019 <span class="preprocessor">#include &lt;map&gt;</span>
00020 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00021 <span class="preprocessor">#include &lt;string&gt;</span>
00022 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00023 
00024 
00025 __STXXL_BEGIN_NAMESPACE
00026 
00031 
00033         
<a name="l00035"></a><a class="code" href="structstxxl_1_1BID.html">00035</a>         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE &gt; 
00036   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1BID.html">BID</a>
00037         {
00038                 <span class="keyword">enum</span> 
00039                 {
00040                         size = SIZE  
<a name="l00041"></a><a class="code" href="structstxxl_1_1BID.html#m0">00041</a>                 };
<a name="l00042"></a><a class="code" href="structstxxl_1_1BID.html#m1">00042</a>                 <a class="code" href="classstxxl_1_1file.html">file</a> * storage; 
00043                 off_t offset; 
00044     <a class="code" href="structstxxl_1_1BID.html">BID</a>():storage(NULL),offset(0) {}
00045     <span class="keywordtype">bool</span> valid()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> storage; }
00046         };
00047 
00049         
<a name="l00051"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html">00051</a>         <span class="keyword">template</span> &lt;&gt; 
00052   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1BID.html">BID</a>&lt;0&gt;
<a name="l00053"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html#m0">00053</a>         {
<a name="l00054"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html#m1">00054</a>                 <a class="code" href="classstxxl_1_1file.html">file</a> * storage; 
<a name="l00055"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html#m2">00055</a>                 off_t offset; 
00056     <span class="keywordtype">unsigned</span> size;  
00057     <a class="code" href="structstxxl_1_1BID.html">BID</a>():storage(NULL),offset(0),size(0) {}
00058     BID(file * f, off_t o, <span class="keywordtype">unsigned</span> s) : storage(f), offset(o), size(s) {}
00059     <span class="keywordtype">bool</span> valid()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> storage; }
00060         };
00061   
00062         
00063         <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> bytes&gt;
00064         <span class="keyword">class </span>filler_struct__
00065         {
00066                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte_type;
00067                 byte_type filler_array_[bytes];
00068         };
00069         
00070         <span class="keyword">template</span> &lt;&gt;
00071         <span class="keyword">class </span>filler_struct__&lt;0&gt;
00072         {
00073                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte_type;
00074         };
00075 
00076                 
00077         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> REF_NUM, <span class="keywordtype">bool</span> NEEDS_FILLER&gt;
00078         <span class="keyword">class </span>typed_block_base
00079         {
00080         };
00081         
00082         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> REF_NUM&gt;
00083         <span class="keyword">class </span>typed_block_base&lt;SIZE,T,REF_NUM,false&gt;
00084         {
00085          <span class="keyword">public</span>:
00086 
00087                 BID&lt;SIZE&gt; ref[REF_NUM];
00088                 
00089                 BID&lt;SIZE&gt; &amp; operator ()(<span class="keywordtype">int</span> i)
00090                 {
00091                         <span class="keywordflow">return</span> ref[i];
00092                 };
00093         };
00094 
00095         
00096         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T &gt; 
00097         <span class="keyword">class </span>typed_block_base &lt; SIZE, T, 0,false &gt;
00098         {
00099         };
00100 
00101         <span class="comment">// one has to add filler in order to make sizeof(typed_block) == SIZE</span>
00102         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> REF_NUM&gt;
00103         <span class="keyword">class </span>typed_block_base&lt;SIZE,T,REF_NUM,true&gt;
00104         {
00105                 filler_struct__&lt;SIZE-((SIZE-<span class="keyword">sizeof</span>(BID&lt;SIZE&gt;)*REF_NUM)/<span class="keyword">sizeof</span>(T))*<span class="keyword">sizeof</span>(T)&gt; __filler;
00106          <span class="keyword">public</span>:
00107                 BID &lt; SIZE &gt; ref[REF_NUM];
00108 
00109                 BID &lt; SIZE &gt; &amp; operator ()(<span class="keywordtype">int</span> i)
00110                 {
00111                         <span class="keywordflow">return</span> ref[i];
00112                 };
00113         };
00114 
00115         <span class="comment">// one has to add filler in order to make sizeof(typed_block) == SIZE</span>
00116         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T &gt; 
00117         <span class="keyword">class </span>typed_block_base &lt; SIZE, T, 0,true &gt;
00118         {
00119     filler_struct__&lt;SIZE - (SIZE / <span class="keyword">sizeof</span> (T))*<span class="keyword">sizeof</span> (T)&gt; __filler;
00120         };
00121         
<a name="l00123"></a><a class="code" href="classstxxl_1_1typed__block.html">00123</a>         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> REF_NUM = 0&gt;
00124         <span class="keyword">class </span><a class="code" href="classstxxl_1_1typed__block.html">typed_block</a>: <span class="keyword">public</span> typed_block_base&lt;SIZE,T,REF_NUM,SIZE % sizeof(T)&gt;
00125         {
00126         <span class="keyword">public</span>:
00127                 <span class="keyword">typedef</span> T type;
00128                 <span class="keyword">typedef</span> T value_type;
00129                 <span class="keyword">typedef</span> T &amp; reference;
00130                 <span class="keyword">typedef</span> <span class="keyword">const</span> T &amp; const_reference;
00131                 <span class="keyword">typedef</span> type * pointer;
00132                 <span class="keyword">typedef</span> pointer iterator;
00133                 <span class="keyword">typedef</span> <span class="keyword">const</span> pointer const_iterator;
00134                 
00135                 <span class="keyword">enum</span> { has_filler = SIZE % <span class="keyword">sizeof</span>(T) };
00136                 
00137                 <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;SIZE&gt;</a> bid_type;
00138                 
00140                 T elem[(SIZE - <span class="keyword">sizeof</span>(BID &lt; SIZE &gt;) * REF_NUM) / <span class="keyword">sizeof</span> (T)];
00141                 
00142                 <a class="code" href="classstxxl_1_1typed__block.html">typed_block</a>() {};
00143         
00145                 reference operator [](<span class="keywordtype">int</span> i)
00146                 {
00147                         <span class="keywordflow">return</span> elem[i];
00148                 };
00149                 
00150                 <span class="keyword">enum</span>
00151                 { 
00152                         raw_size = SIZE, 
00153                         size = (SIZE - <span class="keyword">sizeof</span> (BID &lt; SIZE &gt;) * REF_NUM) / <span class="keyword">sizeof</span> (T) 
00154                 };
00155 
00157                 iterator begin()
00158                 {
00159                         <span class="keywordflow">return</span> elem;
00160                 };
00162                 const_iterator begin()<span class="keyword"> const</span>
00163 <span class="keyword">                </span>{
00164                         <span class="keywordflow">return</span> elem;
00165                 };
00167                 iterator end()
00168                 {
00169                         <span class="keywordflow">return</span> elem + size;
00170                 };
00172                 const_iterator end()<span class="keyword"> const</span>
00173 <span class="keyword">                </span>{
00174                         <span class="keywordflow">return</span> elem + size;
00175                 };
00176                 
00181                 <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> write (<span class="keyword">const</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;SIZE&gt;</a> &amp; bid, 
00182                             <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl = <a class="code" href="structstxxl_1_1default__completion__handler.html">default_completion_handler</a>())
00183                 {
00184                         <span class="keywordflow">return</span> bid.<a class="code" href="structstxxl_1_1BID.html#m0">storage</a>-&gt;<a class="code" href="classstxxl_1_1file.html#a1">awrite</a>(
00185                                                 <span class="keyword">this</span>, 
00186                                                 bid.<a class="code" href="structstxxl_1_1BID.html#m1">offset</a>, 
00187                                                 SIZE, 
00188                                           on_cmpl);
00189                 };
00190 
00195                 <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> read (<span class="keyword">const</span> BID &lt; SIZE &gt; &amp;bid,
00196                            <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl = <a class="code" href="structstxxl_1_1default__completion__handler.html">default_completion_handler</a>())
00197                 {
00198                         <span class="keywordflow">return</span> bid.<a class="code" href="structstxxl_1_1BID.html#m0">storage</a>-&gt;<a class="code" href="classstxxl_1_1file.html#a0">aread</a>(<span class="keyword">this</span>, bid.<a class="code" href="structstxxl_1_1BID.html#m1">offset</a>, SIZE, on_cmpl);
00199                 };
00200                 
00201                 <span class="keywordtype">void</span> *operator      new[] (size_t bytes)
00202                 {
00203                         <span class="keywordflow">return</span> aligned_alloc &lt; BLOCK_ALIGN &gt; (bytes);
00204                 }
00205                 <span class="keywordtype">void</span> *operator      new (size_t bytes)
00206                 {
00207                         <span class="keywordflow">return</span> aligned_alloc &lt; BLOCK_ALIGN &gt; (bytes);
00208                 }
00209                 <span class="keywordtype">void</span> operator      delete (<span class="keywordtype">void</span> *ptr)
00210                 {
00211                         aligned_dealloc &lt; BLOCK_ALIGN &gt; (ptr);
00212                 }
00213                 <span class="keywordtype">void</span> operator      delete[] (<span class="keywordtype">void</span> *ptr)
00214                 {
00215                         aligned_dealloc &lt; BLOCK_ALIGN &gt; (ptr);
00216                 }
00217         };
00218         
00219 
00220         
00221 <span class="comment">/*</span>
00222 <span class="comment">template &lt;unsigned BLK_SIZE&gt;</span>
00223 <span class="comment">class BIDArray: public std::vector&lt; BID &lt;BLK_SIZE&gt; &gt;</span>
00224 <span class="comment">{</span>
00225 <span class="comment"> public:</span>
00226 <span class="comment">  BIDArray(std::vector&lt; BID &lt;BLK_SIZE&gt; &gt;::size_type size = 0) : std::vector&lt; BID &lt;BLK_SIZE&gt; &gt;(size) {};</span>
00227 <span class="comment">};</span>
00228 <span class="comment">*/</span>
00229 
00230         <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> BLK_SIZE&gt; 
00231   <span class="keyword">class </span>BIDArray
00232         {
00233         <span class="keyword">protected</span>:
00234                 <span class="keywordtype">unsigned</span> _size;
00235                 BID &lt; BLK_SIZE &gt; *array;
00236         <span class="keyword">public</span>:
00237                 <span class="keyword">typedef</span> BID&lt;BLK_SIZE&gt; &amp; reference;
00238                 <span class="keyword">typedef</span> BID&lt;BLK_SIZE&gt; * iterator;
00239                 <span class="keyword">typedef</span> <span class="keyword">const</span> BID&lt;BLK_SIZE&gt; * const_iterator;
00240                 BIDArray ():_size (0), array (NULL)
00241                 {
00242                 };
00243                 iterator begin ()
00244                 {
00245                         <span class="keywordflow">return</span> array;
00246                 };
00247                 iterator end ()
00248                 {
00249                         <span class="keywordflow">return</span> array + _size;
00250                 };
00251                 
00252           BIDArray (<span class="keywordtype">unsigned</span> size):_size (size)
00253                 {
00254                         array = <span class="keyword">new</span> BID &lt; BLK_SIZE &gt;[size];
00255                 };
00256                 <span class="keywordtype">unsigned</span> size ()
00257                 {
00258                         <span class="keywordflow">return</span> _size;
00259                 };
00260                 reference operator [](<span class="keywordtype">int</span> i)
00261                 {
00262                         <span class="keywordflow">return</span> array[i];
00263                 };
00264                 <span class="keywordtype">void</span> resize (<span class="keywordtype">unsigned</span> newsize)
00265                 {
00266                         <span class="keywordflow">if</span> (array)
00267                         {
00268                                 stxxl_debug (std::cerr &lt;&lt;
00269                                              <span class="stringliteral">"Warning: resizing nonempty BIDArray"</span>
00270                                              &lt;&lt; std::endl;)
00271                                 BID &lt; BLK_SIZE &gt; *tmp = array;
00272                                 array = <span class="keyword">new</span> BID &lt; BLK_SIZE &gt;[newsize];
00273                                 memcpy (array, tmp, <span class="keyword">sizeof</span> (BID &lt;BLK_SIZE &gt;) * STXXL_MIN (_size, newsize));
00274                                 <span class="keyword">delete</span> [] tmp;
00275                                 _size = newsize;
00276                         }
00277                         <span class="keywordflow">else</span>
00278                         {
00279                                 array = <span class="keyword">new</span> BID &lt; BLK_SIZE &gt;[newsize];
00280                                 _size = newsize;
00281                         }
00282                 };
00283                 ~BIDArray ()
00284                 {
00285                         <span class="keywordflow">if</span> (array)
00286                                 <span class="keyword">delete</span>[]array;
00287                 };
00288         };
00289 
00290 
00291         <span class="keyword">class </span>DiskAllocator
00292         {
00293                 <span class="keyword">typedef</span> std::pair &lt; off_t, off_t &gt; place;
00294                 <span class="keyword">struct </span>FirstFit:<span class="keyword">public</span> std::binary_function &lt; place, off_t,bool &gt;
00295                 {
00296                         <span class="keywordtype">bool</span> operator     () (
00297                                                                 <span class="keyword">const</span> place &amp; entry,
00298                                               <span class="keyword">const</span> off_t size)<span class="keyword"> const</span>
00299 <span class="keyword">                        </span>{
00300                                 <span class="keywordflow">return</span> (entry.second &gt;= size);
00301                         }
00302                 };
00303                 <span class="keyword">struct </span>OffCmp
00304                 {
00305                         <span class="keywordtype">bool</span> operator      () (<span class="keyword">const</span> off_t &amp; off1,<span class="keyword">const</span> off_t &amp; off2)
00306                         {
00307                                 <span class="keywordflow">return</span> off1 &lt; off2;
00308                         };
00309                 };
00310 
00311                 DiskAllocator ()
00312                 {
00313                 };
00314         <span class="keyword">protected</span>:
00315                 
00316                 <span class="keyword">typedef</span> std::map &lt; off_t, off_t &gt; sortseq;
00317                 sortseq free_space;
00318                 <span class="comment">//  sortseq used_space;</span>
00319                 off_t free_bytes;
00320                 off_t disk_bytes;
00321         
00322   <span class="keyword">public</span>:
00323                 DiskAllocator (off_t disk_size);
00324 
00325                 off_t get_free_bytes ()<span class="keyword"> const</span>
00326 <span class="keyword">                </span>{
00327                         <span class="keywordflow">return</span> free_bytes;
00328                 };
00329                 off_t get_used_bytes ()<span class="keyword"> const</span>
00330 <span class="keyword">                </span>{
00331                         <span class="keywordflow">return</span> disk_bytes - free_bytes;
00332                 };
00333 
00334                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00335                 <span class="keywordtype">void</span> new_blocks (BIDArray &lt; BLK_SIZE &gt; &amp;bids);
00336                 
00337                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00338                 <span class="keywordtype">void</span> delete_blocks (<span class="keyword">const</span> BIDArray &lt; BLK_SIZE &gt; &amp;bids);
00339                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt; 
00340                 <span class="keywordtype">void</span> delete_block (<span class="keyword">const</span> BID &lt;BLK_SIZE &gt; &amp; bid);
00341         };
00342 
00343   DiskAllocator::DiskAllocator (off_t disk_size):
00344                 free_bytes(disk_size),
00345                 disk_bytes(disk_size)
00346         {
00347                 free_space[0] = disk_size;
00348         }
00349 
00350         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00351                 <span class="keywordtype">void</span> DiskAllocator::new_blocks (BIDArray &lt; BLK_SIZE &gt; &amp; bids)
00352         {
00353     STXXL_VERBOSE2(<span class="stringliteral">"DiskAllocator::new_blocks&lt;BLK_SIZE&gt;,  BLK_SIZE = "</span> &lt;&lt; BLK_SIZE
00354       &lt;&lt; <span class="stringliteral">", free:"</span> &lt;&lt; free_bytes &lt;&lt; <span class="stringliteral">" total:"</span>&lt;&lt; disk_bytes)
00355     
00356                 off_t requested_size = off_t(bids.size()) * off_t(BLK_SIZE);
00357                 sortseq::iterator space = 
00358                         std::find_if (free_space.begin (), free_space.end (),
00359                                       bind2nd(FirstFit (), requested_size));
00360 
00361                 <span class="keywordflow">if</span> (space != free_space.end ())
00362                 {
00363                         off_t region_pos = (*space).first;
00364                         off_t region_size = (*space).second;
00365                         free_space.erase (space);
00366                         <span class="keywordflow">if</span> (region_size &gt; requested_size)
00367                                 free_space[region_pos + requested_size] = region_size - requested_size;
00368 
00369                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; bids.size (); i++)
00370                         {
00371                                 bids[i].offset =
00372                                         region_pos +
00373                                         off_t (i) * off_t (BLK_SIZE);
00374                         }
00375                         free_bytes -= requested_size;
00376                 }
00377                 <span class="keywordflow">else</span>
00378                 {
00379                         STXXL_ERRMSG( <span class="stringliteral">"Allocation error: "</span> &lt;&lt; requested_size &lt;&lt;
00380                                 <span class="stringliteral">" bytes requested, "</span> &lt;&lt; free_bytes &lt;&lt;
00381                                 <span class="stringliteral">" bytes free"</span> )
00382                         abort();
00383                 }
00384         };
00385 
00386         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00387                 <span class="keywordtype">void</span> DiskAllocator::delete_block (<span class="keyword">const</span> BID &lt; BLK_SIZE &gt; &amp;bid)
00388         {
00389     STXXL_VERBOSE2(<span class="stringliteral">"DiskAllocator::delete_block&lt;BLK_SIZE&gt;,  BLK_SIZE = "</span> &lt;&lt; BLK_SIZE
00390       &lt;&lt; <span class="stringliteral">", free:"</span> &lt;&lt; free_bytes &lt;&lt; <span class="stringliteral">" total:"</span>&lt;&lt; disk_bytes)
00391                 off_t region_pos = bid.offset;
00392                 off_t region_size = BLK_SIZE;
00393                 sortseq::iterator succ = free_space.upper_bound (region_pos);
00394                 sortseq::iterator pred = succ;
00395                 pred--;
00396                 <span class="keywordflow">if</span> (succ != free_space.end ()
00397                     &amp;&amp; (*succ).first == region_pos + region_size)
00398                 {
00399                         <span class="comment">// coalesce with successor</span>
00400                         region_size += (*succ).second;
00401                         free_space.erase (succ);
00402                 }
00403                 <span class="keywordflow">if</span> (pred != free_space.end ()
00404                     &amp;&amp; (*pred).first + (*pred).second == region_pos)
00405                 {
00406                         <span class="comment">// coalesce with predecessor</span>
00407                         region_size += (*pred).second;
00408                         region_pos = (*pred).first;
00409                         free_space.erase (pred);
00410                 }
00411 
00412                 free_space[region_pos] = region_size;
00413                 free_bytes += off_t (BLK_SIZE);
00414         }
00415 
00416         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00417                 <span class="keywordtype">void</span> DiskAllocator::delete_blocks (<span class="keyword">const</span> BIDArray &lt; BLK_SIZE &gt; &amp;bids)
00418         {
00419                 STXXL_VERBOSE2(<span class="stringliteral">"DiskAllocator::delete_blocks&lt;BLK_SIZE&gt; BLK_SIZE="</span>&lt;&lt; BLK_SIZE &lt;&lt;
00420       <span class="stringliteral">", free:"</span> &lt;&lt; free_bytes &lt;&lt; <span class="stringliteral">" total:"</span>&lt;&lt; disk_bytes )
00421                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; bids.size (); i++)
00422                 {
00423                         off_t region_pos = bids[i].offset;
00424                         off_t region_size = BLK_SIZE;
00425                         sortseq::iterator succ =
00426                                 free_space.upper_bound (region_pos);
00427                         sortseq::iterator pred = succ;
00428                         pred--;
00429 
00430                         <span class="keywordflow">if</span> (succ != free_space.end ()
00431                             &amp;&amp; (*succ).first == region_pos + region_size)
00432                         {
00433                                 <span class="comment">// coalesce with successor</span>
00434 
00435                                 region_size += (*succ).second;
00436                                 free_space.erase (succ);
00437                         }
00438                         <span class="keywordflow">if</span> (pred != free_space.end ()
00439                             &amp;&amp; (*pred).first + (*pred).second == region_pos)
00440                         {
00441                                 <span class="comment">// coalesce with predecessor</span>
00442 
00443                                 region_size += (*pred).second;
00444                                 region_pos = (*pred).first;
00445                                 free_space.erase (pred);
00446                         }
00447 
00448                         free_space[region_pos] = region_size;
00449                 };
00450                 free_bytes += off_t (bids.size ()) * off_t (BLK_SIZE);
00451         }
00452 
00455         <span class="keyword">class </span>config
00456         {
00457                 <span class="keyword">struct </span>DiskEntry
00458                 {
00459                         std::string path;
00460                         std::string io_impl;
00461                         off_t size;
00462                 };
00463                 std::vector &lt; DiskEntry &gt; disks_props;
00464                 
00465                 config (<span class="keyword">const</span> <span class="keywordtype">char</span> *config_path = <span class="stringliteral">"./.stxxl"</span>);
00466          <span class="keyword">public</span>:
00469                 <span class="keywordtype">unsigned</span> <a class="code" href="classstxxl_1_1config.html#a0">disks_number</a>()
00470                 {
00471                         <span class="keywordflow">return</span> disks_props.size ();
00472                 };
00473                 
00474                 <span class="keywordtype">unsigned</span> ndisks()
00475                 {
00476                         <span class="keywordflow">return</span> disks_props.size ();
00477                 };
00478                 
00482                 <span class="keyword">const</span> std::string &amp; <a class="code" href="classstxxl_1_1config.html#a2">disk_path</a> (<span class="keywordtype">int</span> disk)
00483                 {
00484                         <span class="keywordflow">return</span> disks_props[disk].path;
00485                 };
00489                 off_t <a class="code" href="classstxxl_1_1config.html#a3">disk_size</a> (<span class="keywordtype">int</span> disk)
00490                 {
00491                         <span class="keywordflow">return</span> disks_props[disk].size;
00492                 };
00495                 <span class="keyword">const</span> std::string &amp; <a class="code" href="classstxxl_1_1config.html#a4">disk_io_impl</a> (<span class="keywordtype">int</span> disk)
00496                 {
00497                         <span class="keywordflow">return</span> disks_props[disk].io_impl;
00498                 };
00499 
00502                 <span class="keyword">static</span> config *<a class="code" href="group__mnglayer.html#a6">get_instance</a> ();
00503         <span class="keyword">private</span>:
00504                 <span class="keyword">static</span> config *instance;
00505         };
00506 
<a name="l00507"></a><a class="code" href="classstxxl_1_1config.html#a6">00507</a> 
00508         <a class="code" href="classstxxl_1_1config.html">config</a> *config::get_instance ()
00509         {
00510                 <span class="keywordflow">if</span> (!instance)
00511                 {
00512                         <span class="keywordtype">char</span> *cfg_path = getenv (<span class="stringliteral">"STXXLCFG"</span>);
00513                         <span class="keywordflow">if</span> (cfg_path)
00514                                 instance = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1config.html">config</a> (cfg_path);
00515                         <span class="keywordflow">else</span>
00516                                 instance = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1config.html">config</a> ();
00517                 }
00518 
00519                 <span class="keywordflow">return</span> instance;
00520         }
00521 
00522 
00523         config::config (<span class="keyword">const</span> <span class="keywordtype">char</span> *config_path)
00524         {
00525                 std::ifstream cfg_file (config_path);
00526                 <span class="keywordflow">if</span> (!cfg_file)
00527                 {
00528                         STXXL_ERRMSG(<span class="stringliteral">"Warning: no config file found."</span> )
00529                         STXXL_ERRMSG(<span class="stringliteral">"Using default disk configuration."</span> )
00530                         DiskEntry entry1 = { <span class="stringliteral">"/var/tmp/stxxl"</span>, <span class="stringliteral">"syscall"</span>,
00531                                 100 * 1024 * 1024
00532                         };
00533                         DiskEntry entry2 =
00534                                 { <span class="stringliteral">"/tmp/stxxl1"</span>, <span class="stringliteral">"mmap"</span>, 100 * 1024 * 1024 };
00535                         DiskEntry entry3 = { <span class="stringliteral">"/tmp/stxxl2"</span>, <span class="stringliteral">"simdisk"</span>,
00536                                 100 * 1024 * 1024
00537                         };
00538                         disks_props.push_back (entry1);
00539                         <span class="comment">//disks_props.push_back (entry2);</span>
00540                         <span class="comment">//disks_props.push_back (entry3);</span>
00541                 }
00542                 <span class="keywordflow">else</span>
00543                 {
00544                         std::string line;
00545 
00546                         <span class="keywordflow">while</span> (cfg_file &gt;&gt; line)
00547                         {
00548                                 std::vector &lt; std::string &gt; tmp = split (line, <span class="stringliteral">"="</span>);
00549                                 
00550                                 <span class="keywordflow">if</span>(tmp[0][0] == <span class="charliteral">'#'</span>)
00551                                 {
00552                                 }
00553                                 <span class="keywordflow">else</span>
00554                                 <span class="keywordflow">if</span> (tmp[0] == <span class="stringliteral">"disk"</span>)
00555                                 {
00556                                         tmp = split (tmp[1], <span class="stringliteral">","</span>);
00557                                         DiskEntry entry = { tmp[0], tmp[2],
00558                                                         off_t (str2int (tmp[1])) *
00559                                                         off_t (1024 * 1024)
00560                                         };
00561                                         disks_props.push_back (entry);
00562                                 }
00563                                 <span class="keywordflow">else</span>
00564                                 {
00565                                         std::cerr &lt;&lt; <span class="stringliteral">"Unknown token "</span> &lt;&lt;
00566                                                 tmp[0] &lt;&lt; std::endl;
00567                                 }
00568                         }
00569                         cfg_file.close ();
00570                 }
00571 
00572                 <span class="keywordflow">if</span> (disks_props.empty ())
00573                 {
00574                         STXXL_ERRMSG( <span class="stringliteral">"No disks found in '"</span> &lt;&lt; config_path &lt;&lt; <span class="stringliteral">"' ."</span> )
00575                         abort ();
00576                 }
00577                 <span class="keywordflow">else</span>
00578                 {
00579                         <span class="keywordflow">for</span> (std::vector &lt; DiskEntry &gt;::const_iterator it =
00580                              disks_props.begin (); it != disks_props.end ();
00581                              it++)
00582                         {
00583                                 STXXL_MSG(<span class="stringliteral">"Disk '"</span> &lt;&lt; (*it).path &lt;&lt; <span class="stringliteral">"' is allocated, space: "</span> &lt;&lt;
00584                                         ((*it).size) / (1024 * 1024) &lt;&lt;
00585                                         <span class="stringliteral">" Mb, I/O implementation: "</span> &lt;&lt; (*it).io_impl )
00586                         }
00587                 }
00588         };
00589 
00590         <span class="keyword">class </span>FileCreator
00591         {
00592         <span class="keyword">public</span>:
00593                 <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1file.html">stxxl::file</a> * create (<span class="keyword">const</span> std::string &amp; io_impl,
00594                                               <span class="keyword">const</span> std::string &amp; filename,
00595                                               <span class="keywordtype">int</span> options, <span class="keywordtype">int</span> disk)
00596                 {
00597                         <span class="keywordflow">if</span> (io_impl == <span class="stringliteral">"syscall"</span>)
00598                                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstxxl_1_1syscall__file.html">stxxl::syscall_file</a> (filename,
00599                                                                 options,
00600                                                                 disk);
00601                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (io_impl == <span class="stringliteral">"mmap"</span>)
00602                                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstxxl_1_1mmap__file.html">stxxl::mmap_file</a> (filename,
00603                                                              options, disk);
00604                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (io_impl == <span class="stringliteral">"simdisk"</span>)
00605                                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstxxl_1_1sim__disk__file.html">stxxl::sim_disk_file</a> (filename,
00606                                                                  options,
00607                                                                  disk);
00608 
00609                         STXXL_ERRMSG(<span class="stringliteral">"Unsupported disk I/O implementation "</span> &lt;&lt;
00610                                 io_impl &lt;&lt; <span class="stringliteral">" ."</span> )
00611                         abort ();
00612 
00613                         <span class="keywordflow">return</span> NULL;
00614                 };
00615         };
00616   
00620 
00623         <span class="keyword">struct </span>striping
00624         {
00625                 <span class="keywordtype">int</span> begin, diff;
00626                 striping (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):begin (b), diff (e - b)
00627                 {
00628                 };
00629               striping ():begin (0)
00630                 {
00631                         diff = config::get_instance ()-&gt;disks_number ();
00632                 };
00633                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00634 <span class="keyword">                </span>{
00635                         <span class="keywordflow">return</span> begin + i % diff;
00636                 };
00637                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00638                 {
00639                         <span class="keywordflow">return</span> <span class="stringliteral">"striping"</span>;
00640                 }
00641         };
00642 
00645         <span class="keyword">struct </span>FR:<span class="keyword">public</span> striping
00646         {
00647                 random_number&lt;random_uniform_fast&gt; rnd;
00648                 FR (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):striping (b, e)
00649                 {
00650                 };
00651           FR ():striping ()
00652                 {
00653                 };
00654                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00655 <span class="keyword">                </span>{
00656                         <span class="keywordflow">return</span> begin + rnd(diff);
00657                 }
00658                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00659                 {
00660                         <span class="keywordflow">return</span> <span class="stringliteral">"fully randomized striping"</span>;
00661                 }
00662         };
00663 
00666         <span class="keyword">struct </span>SR:<span class="keyword">public</span> striping
00667         {
00668                 random_number&lt;random_uniform_fast&gt; rnd;
00669                 <span class="keywordtype">int</span> offset;
00670                 SR (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):striping (b, e)
00671                 {
00672                         offset = rnd(diff);
00673                 };
00674                 SR():striping ()
00675                 {
00676                         offset = rnd(diff);
00677                 };
00678                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00679 <span class="keyword">                </span>{
00680                         <span class="keywordflow">return</span> begin + (i + offset) % diff;
00681                 }
00682                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00683                 {
00684                         <span class="keywordflow">return</span> <span class="stringliteral">"simple randomized striping"</span>;
00685                 }
00686         };
00687 
00690         <span class="keyword">struct </span>RC:<span class="keyword">public</span> striping
00691         {
00692                 std::vector&lt;int&gt; perm;
00693                  
00694                 RC (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):striping (b, e), perm (diff)
00695                 {
00696                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; diff; i++)
00697                                 perm[i] = i;
00698 
00699                         stxxl::random_number&lt;random_uniform_fast&gt; rnd;
00700                         std::random_shuffle (perm.begin (), perm.end (), rnd);
00701                 }
00702                 RC ():striping (), perm (diff)
00703                 {
00704                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; diff; i++)
00705                                 perm[i] = i;
00706 
00707                         random_number&lt;random_uniform_fast&gt; rnd;
00708                         std::random_shuffle (perm.begin (), perm.end (), rnd);
00709                 }
00710                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00711 <span class="keyword">                </span>{
00712                         <span class="keywordflow">return</span> begin + perm[i % diff];
00713                 }
00714                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00715                 {
00716                         <span class="keywordflow">return</span> <span class="stringliteral">"randomized cycling striping"</span>;
00717                 }
00718         };
00719 
00722         <span class="keyword">struct </span>single_disk
00723         {
00724                 <span class="keyword">const</span> <span class="keywordtype">int</span> disk;
00725                 single_disk(<span class="keywordtype">int</span> d):disk(d)
00726                 {
00727                 };
00728           
00729     single_disk():disk(0)
00730                 {
00731                 };
00732                 <span class="keywordtype">int</span> operator() (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00733 <span class="keyword">                </span>{
00734                         <span class="keywordflow">return</span> disk;
00735                 };
00736                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00737                 {
00738                         <span class="keywordflow">return</span> <span class="stringliteral">"single disk"</span>;
00739                 }
00740         };
00741   
00743   
<a name="l00745"></a><a class="code" href="structstxxl_1_1offset__allocator.html">00745</a>   <span class="keyword">template</span> &lt;<span class="keyword">class</span> BaseAllocator_&gt;
00746   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1offset__allocator.html">offset_allocator</a>
00747   {
00748     BaseAllocator_ base;
00749     <span class="keywordtype">int</span> offset;
00753     <a class="code" href="structstxxl_1_1offset__allocator.html#a0">offset_allocator</a>(<span class="keywordtype">int</span> offset_) : base(),offset(offset_) {}
00758     <a class="code" href="structstxxl_1_1offset__allocator.html#a0">offset_allocator</a>(<span class="keywordtype">int</span> offset_,BaseAllocator_ &amp; base_) : base(base_),offset(offset_) {}
00759     <span class="keywordtype">int</span> operator() (<span class="keywordtype">int</span> i)
00760     {
00761       <span class="keywordflow">return</span> base(offset + i);
00762     }
00763   };
00764 
00766   
00768         <span class="keyword">template</span> &lt; <span class="keyword">class</span> bid_it &gt; <span class="keyword">struct </span>bid_iterator_traits
00769         {
00770                 bid_it *a;
00771                 <span class="keyword">enum</span>
00772                 {
00773                         block_size = bid_it::block_size
00774                 };
00775         };
00776 
00777         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz &gt; <span class="keyword">struct </span>bid_iterator_traits &lt;BID &lt;blk_sz &gt; *&gt;
00778         {
00779                 <span class="keyword">enum</span>
00780                 {
00781                         block_size = blk_sz
00782                 };
00783         };
00784 
00785 <span class="comment">/*</span>
00786 <span class="comment">        template &lt; unsigned _blk_sz &gt; struct bid_iterator_traits&lt;</span>
00787 <span class="comment">                std::__normal_iterator&lt; BID&lt;_blk_sz&gt; * ,std::vector&lt; BID&lt;_blk_sz&gt; ,std::allocator&lt;BID&lt;_blk_sz&gt; &gt; &gt;  &gt; &gt;</span>
00788 <span class="comment">                         </span>
00789 <span class="comment">        {</span>
00790 <span class="comment">                enum</span>
00791 <span class="comment">                {</span>
00792 <span class="comment">                        block_size = _blk_sz</span>
00793 <span class="comment">                };      </span>
00794 <span class="comment">        };</span>
00795 <span class="comment">*/</span>
00796 
00797         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> _blk_sz &gt; <span class="keyword">struct </span>bid_iterator_traits&lt;
00798                 __gnu_cxx::__normal_iterator&lt; BID&lt;_blk_sz&gt; * ,std::vector&lt; BID&lt;_blk_sz&gt; ,std::allocator&lt;BID&lt;_blk_sz&gt; &gt; &gt;  &gt; &gt;
00799         {
00800                 <span class="keyword">enum</span>
00801                 {
00802                         block_size = _blk_sz
00803                 };      
00804         };      
00805 
00807         
00810         <span class="keyword">class </span>block_manager
00811         {
00812                 DiskAllocator **disk_allocators;
00813                 file ** disk_files;
00814                 
00815                 <span class="keywordtype">unsigned</span> ndisks;
00816                 block_manager ();
00817         
00818         <span class="keyword">public</span>:
00821                 <span class="keyword">static</span> block_manager *<a class="code" href="group__mnglayer.html#a8">get_instance</a> ();
00822 
00824                 
00831                 <span class="keyword">template</span> &lt; <span class="keyword">class</span> DiskAssgnFunctor, <span class="keyword">class</span> BIDIteratorClass &gt;
00832                 <span class="keywordtype">void</span> <a class="code" href="group__mnglayer.html#a11">new_blocks</a> (
00833                                          DiskAssgnFunctor functor,
00834                                          <span class="keyword">const</span> BIDIteratorClass &amp; bidbegin,
00835                                          <span class="keyword">const</span> BIDIteratorClass &amp; bidend);
00836 
00838                 
00842                 <span class="keyword">template</span> &lt; <span class="keyword">class</span> BIDIteratorClass &gt;
00843                 <span class="keywordtype">void</span> <a class="code" href="group__mnglayer.html#a13">delete_blocks</a> (<span class="keyword">const</span> BIDIteratorClass &amp; bidbegin, <span class="keyword">const</span> BIDIteratorClass &amp; bidend);
00844 
00847                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00848           <span class="keywordtype">void</span> <a class="code" href="group__mnglayer.html#a12">delete_block</a> (<span class="keyword">const</span> BID &lt; BLK_SIZE &gt; &amp;bid);
00849 
00850                 ~block_manager ();
00851         <span class="keyword">private</span>:
00852                 <span class="keyword">static</span> block_manager *instance;
00853         };
<a name="l00854"></a><a class="code" href="classstxxl_1_1block__manager.html#a8">00854</a> 
00855         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *block_manager::get_instance ()
00856         {
00857                 <span class="keywordflow">if</span> (!instance)
00858                         instance = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> ();
00859 
00860                 <span class="keywordflow">return</span> instance;
00861         }
00862 
00863         block_manager::block_manager ()
00864         {
00865                 FileCreator fc;
00866                 config *cfg = config::get_instance ();
00867 
00868                 ndisks = cfg-&gt;disks_number ();
00869                 disk_allocators = <span class="keyword">new</span> DiskAllocator *[ndisks];
00870                 disk_files = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1file.html">stxxl::file</a> *[ndisks];
00871 
00872                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; ndisks; i++)
00873                 {
00874                         disk_files[i] = fc.create (cfg-&gt;disk_io_impl (i),
00875                                                    cfg-&gt;disk_path (i),
00876                                                    <a class="code" href="classstxxl_1_1file.html#s6s3">stxxl::file::CREAT</a> | <a class="code" href="classstxxl_1_1file.html#s6s2">stxxl::file::RDWR</a>  | <a class="code" href="classstxxl_1_1file.html#s6s4">stxxl::file::DIRECT</a>
00877                                                    ,i);
00878                         disk_files[i]-&gt;set_size (cfg-&gt;disk_size (i));
00879                         disk_allocators[i] = <span class="keyword">new</span> DiskAllocator (cfg-&gt;disk_size (i));
00880                 }
00881         };
00882 
00883         block_manager::~block_manager()
00884         {
00885                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; ndisks; i++)
00886                 {
00887                         <span class="keyword">delete</span> disk_allocators[i];
00888                         <span class="keyword">delete</span> disk_files[i];
00889                 }
00890                 <span class="keyword">delete</span>[]disk_allocators;
00891                 <span class="keyword">delete</span>[]disk_files;
00892         }
00893 
00894 
<a name="l00895"></a><a class="code" href="classstxxl_1_1block__manager.html#a11">00895</a>         <span class="keyword">template</span> &lt; <span class="keyword">class</span> DiskAssgnFunctor, <span class="keyword">class</span> BIDIteratorClass &gt;
00896                 <span class="keywordtype">void</span> block_manager::new_blocks (
00897                                                 DiskAssgnFunctor functor,
00898                                                 <span class="keyword">const</span> BIDIteratorClass &amp; bidbegin,
00899                                                 <span class="keyword">const</span> BIDIteratorClass &amp; bidend)
00900         {
00901                 <span class="keywordtype">unsigned</span> nblocks = bidend - bidbegin;
00902 
00903                 <span class="keywordtype">int</span> *bl = <span class="keyword">new</span> <span class="keywordtype">int</span>[ndisks];
00904                 BIDArray &lt; bid_iterator_traits &lt;BIDIteratorClass &gt;::block_size &gt; *disk_bids =
00905                         <span class="keyword">new</span> BIDArray &lt; bid_iterator_traits &lt;BIDIteratorClass &gt;::block_size &gt;[ndisks];
00906 
00907                 memset(bl, 0, ndisks * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
00908 
00909                 <span class="keywordtype">unsigned</span> i = 0;
00910                 BIDIteratorClass it = bidbegin;
00911                 <span class="keywordflow">for</span> (; i &lt; nblocks; i++, it++)
00912                 {
00913                         <span class="keywordtype">int</span> disk = functor (i);
00914                         (*it).storage = disk_files[disk];
00915                         bl[disk]++;
00916                 }
00917 
00918                 <span class="keywordflow">for</span> (i = 0; i &lt; ndisks; i++)
00919                 {
00920                         <span class="keywordflow">if</span> (bl[i])
00921                         {
00922                                 disk_bids[i].resize (bl[i]);
00923                                 disk_allocators[i]-&gt;new_blocks (disk_bids[i]);
00924                         }
00925                 }
00926 
00927                 memset (bl, 0, ndisks * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
00928 
00929                 i = 0;
00930                 <span class="keywordflow">for</span> (it = bidbegin; it != bidend; it++, i++)
00931                 {
00932                         <span class="keywordtype">int</span> disk = (*it).storage-&gt;get_disk_number ();
00933                         <span class="comment">//    std::cout &lt;&lt; disk_bids[disk][bl[disk]].offset &lt;&lt; " "&lt;&lt;std::endl;</span>
00934                         (*it).offset = disk_bids[disk][bl[disk]++].offset;
00935                         <span class="comment">//    std::cout &lt;&lt;   (*it).offset &lt;&lt; " "&lt;&lt;std::endl;</span>
00936                 }
00937 
00938                 <span class="keyword">delete</span>[]bl;
00939                 <span class="keyword">delete</span>[]disk_bids;
00940         }
00941 
00942 
00943 
<a name="l00944"></a><a class="code" href="classstxxl_1_1block__manager.html#a12">00944</a>         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00945         <span class="keywordtype">void</span> block_manager::delete_block (<span class="keyword">const</span> BID &lt; BLK_SIZE &gt; &amp;bid)
00946         {
00947                 disk_allocators[bid.<a class="code" href="structstxxl_1_1BID.html#m0">storage</a>-&gt;<a class="code" href="classstxxl_1_1file.html#a4">get_disk_number</a> ()]-&gt;delete_block (bid);
00948         }
00949 
00950 
<a name="l00951"></a><a class="code" href="classstxxl_1_1block__manager.html#a13">00951</a>         <span class="keyword">template</span> &lt; <span class="keyword">class</span> BIDIteratorClass &gt;
00952                 <span class="keywordtype">void</span> block_manager::delete_blocks (
00953                                                 <span class="keyword">const</span> BIDIteratorClass &amp; bidbegin,
00954                               <span class="keyword">const</span> BIDIteratorClass &amp; bidend)
00955         {
00956                 <span class="keywordflow">for</span> (BIDIteratorClass it = bidbegin; it != bidend; it++)
00957                 {
00958                         <a class="code" href="group__mnglayer.html#a12">delete_block</a> (*it);
00959                 }
00960         }
00961 
00962         block_manager *block_manager::instance = NULL;
00963         config *config::instance = NULL;
00964 
00965 <span class="preprocessor">  #define STXXL_DEFAULT_ALLOC_STRATEGY RC   </span>
00966 <span class="preprocessor"></span><span class="preprocessor">  #define STXXL_DEFAULT_BLOCK_SIZE(type) (2*1024*1024)  // use traits</span>
00967 <span class="preprocessor"></span>  
00969   
00970 __STXXL_END_NAMESPACE
00971 
00972 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Jul 1 11:08:35 2003 for &lt;stxxl&gt; by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
