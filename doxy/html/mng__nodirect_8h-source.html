<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mng_nodirect.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>mng_nodirect.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef MNG_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define MNG_HEADER</span>
00003 <span class="preprocessor"></span><span class="comment">/***************************************************************************</span>
00004 <span class="comment"> *            mng.h</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Sat Aug 24 23:55:27 2002</span>
00007 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00008 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00009 <span class="comment"> ****************************************************************************/</span>
00010 
00011 <span class="preprocessor">#include "../io/io.h"</span>
00012 <span class="preprocessor">#include "../common/rand.h"</span>
00013 <span class="preprocessor">#include "../common/aligned_alloc.h"</span>
00014 
00015 
00016 <span class="preprocessor">#include &lt;iostream&gt;</span>
00017 <span class="preprocessor">#include &lt;fstream&gt;</span>
00018 <span class="preprocessor">#include &lt;vector&gt;</span>
00019 <span class="preprocessor">#include &lt;list&gt;</span>
00020 <span class="preprocessor">#include &lt;map&gt;</span>
00021 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00022 <span class="preprocessor">#include &lt;string&gt;</span>
00023 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00024 
00025 
00026 __STXXL_BEGIN_NAMESPACE
00027 
00032 
00034         
00036         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE &gt; 
00037   <span class="keyword">struct </span>BID
00038         {
00039                 <span class="keyword">enum</span> 
00040                 {
00041                         size = SIZE  
<a name="l00042"></a><a class="code" href="structstxxl_1_1BID.html#m2">00042</a>                 };
<a name="l00043"></a><a class="code" href="structstxxl_1_1BID.html#m1">00043</a>                 <a class="code" href="classstxxl_1_1file.html">file</a> * storage; 
00044                 off_t offset; 
00045     <a class="code" href="structstxxl_1_1BID.html">BID</a>():storage(NULL),offset(0) {}
00046     <span class="keywordtype">bool</span> valid()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> storage; }
00047         };
00048 
00050         
00052         <span class="keyword">template</span> &lt;&gt; 
00053   <span class="keyword">struct </span>BID&lt;0&gt;
<a name="l00054"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html#m3">00054</a>         {
<a name="l00055"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html#m1">00055</a>                 <a class="code" href="classstxxl_1_1file.html">file</a> * storage; 
<a name="l00056"></a><a class="code" href="structstxxl_1_1BID_3_010_01_4.html#m2">00056</a>                 off_t offset; 
00057     <span class="keywordtype">unsigned</span> size;  
00058     <a class="code" href="structstxxl_1_1BID.html">BID</a>():storage(NULL),offset(0),size(0) {}
00059     BID(file * f, off_t o, <span class="keywordtype">unsigned</span> s) : storage(f), offset(o), size(s) {}
00060     <span class="keywordtype">bool</span> valid()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> storage; }
00061         };
00062   
00063   <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> blk_sz&gt;
00064   <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> BID&lt;blk_sz&gt; &amp; a, <span class="keyword">const</span> BID&lt;blk_sz&gt; &amp; b)
00065   {
00066       <span class="keywordflow">return</span> (a.storage == b.storage) &amp;&amp; (a.offset == b.offset) &amp;&amp; (a.size == b.size);
00067   }
00068   
00069   <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> blk_sz&gt;
00070   std::ostream &amp; operator &lt;&lt; (std::ostream &amp; s, const BID&lt;blk_sz&gt; &amp; bid)
00071   {
00072     s &lt;&lt; <span class="stringliteral">" storage file addr: "</span>&lt;&lt;bid.storage;
00073     s &lt;&lt; <span class="stringliteral">" offset: "</span>&lt;&lt;bid.offset;
00074     s &lt;&lt; <span class="stringliteral">" size: "</span>&lt;&lt;bid.<a class="code" href="classstxxl_1_1file.html#a3">size</a>;
00075     <span class="keywordflow">return</span> s;
00076   }
00077   
00078         
00079         <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> bytes&gt;
00080         <span class="keyword">class </span>filler_struct__
00081         {
00082                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte_type;
00083                 byte_type filler_array_[bytes];
00084         };
00085         
00086         <span class="keyword">template</span> &lt;&gt;
00087         <span class="keyword">class </span>filler_struct__&lt;0&gt;
00088         {
00089                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byte_type;
00090         };
00091 
00092                 
00093         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> REF_NUM, <span class="keywordtype">bool</span> NEEDS_FILLER&gt;
00094         <span class="keyword">class </span>typed_block_base
00095         {
00096         };
00097         
00098         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> REF_NUM&gt;
00099         <span class="keyword">class </span>typed_block_base&lt;SIZE,T,REF_NUM,false&gt;
00100         {
00101          <span class="keyword">public</span>:
00102 
00103                 BID&lt;SIZE&gt; ref[REF_NUM];
00104                 
00105                 BID&lt;SIZE&gt; &amp; operator ()(<span class="keywordtype">int</span> i)
00106                 {
00107                         <span class="keywordflow">return</span> ref[i];
00108                 };
00109         };
00110 
00111         
00112         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T &gt; 
00113         <span class="keyword">class </span>typed_block_base &lt; SIZE, T, 0,false &gt;
00114         {
00115         };
00116 
00117         <span class="comment">// one has to add filler in order to make sizeof(typed_block) == SIZE</span>
00118         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> REF_NUM&gt;
00119         <span class="keyword">class </span>typed_block_base&lt;SIZE,T,REF_NUM,true&gt;
00120         {
00121                 filler_struct__&lt;SIZE-((SIZE-<span class="keyword">sizeof</span>(BID&lt;SIZE&gt;)*REF_NUM)/<span class="keyword">sizeof</span>(T))*<span class="keyword">sizeof</span>(T)&gt; __filler;
00122          <span class="keyword">public</span>:
00123                 BID &lt; SIZE &gt; ref[REF_NUM];
00124 
00125                 BID &lt; SIZE &gt; &amp; operator ()(<span class="keywordtype">int</span> i)
00126                 {
00127                         <span class="keywordflow">return</span> ref[i];
00128                 };
00129         };
00130 
00131         <span class="comment">// one has to add filler in order to make sizeof(typed_block) == SIZE</span>
00132         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T &gt; 
00133         <span class="keyword">class </span>typed_block_base &lt; SIZE, T, 0,true &gt;
00134         {
00135     filler_struct__&lt;SIZE - (SIZE / <span class="keyword">sizeof</span> (T))*<span class="keyword">sizeof</span> (T)&gt; __filler;
00136         };
00137         
00139         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> SIZE, <span class="keyword">class</span> T, <span class="keywordtype">unsigned</span> REF_NUM = 0&gt;
00140         <span class="keyword">class </span>typed_block: <span class="keyword">public</span> typed_block_base&lt;SIZE,T,REF_NUM,SIZE % sizeof(T)&gt;
00141         {
00142         <span class="keyword">public</span>:
00143                 <span class="keyword">typedef</span> T type;
00144                 <span class="keyword">typedef</span> T value_type;
00145                 <span class="keyword">typedef</span> T &amp; reference;
00146                 <span class="keyword">typedef</span> <span class="keyword">const</span> T &amp; const_reference;
00147                 <span class="keyword">typedef</span> type * pointer;
00148                 <span class="keyword">typedef</span> pointer iterator;
00149                 <span class="keyword">typedef</span> <span class="keyword">const</span> pointer const_iterator;
00150                 
00151                 <span class="keyword">enum</span> { has_filler = SIZE % <span class="keyword">sizeof</span>(T) };
00152                 
00153                 <span class="keyword">typedef</span> BID&lt;SIZE&gt; bid_type;
00154                 
00156                 T elem[(SIZE - <span class="keyword">sizeof</span>(BID &lt; SIZE &gt;) * REF_NUM) / <span class="keyword">sizeof</span> (T)];
00157                 
00158                 typed_block() {};
00159         
00161                 reference operator [](<span class="keywordtype">int</span> i)
00162                 {
00163                         <span class="keywordflow">return</span> elem[i];
00164                 };
00165                 
00166                 <span class="keyword">enum</span>
00167                 { 
00168                         raw_size = SIZE, 
00169                         size = (SIZE - <span class="keyword">sizeof</span> (BID &lt; SIZE &gt;) * REF_NUM) / <span class="keyword">sizeof</span> (T) 
00170                 };
00171 
00173                 iterator begin()
00174                 {
00175                         <span class="keywordflow">return</span> elem;
00176                 };
00178                 const_iterator begin()<span class="keyword"> const</span>
00179 <span class="keyword">                </span>{
00180                         <span class="keywordflow">return</span> elem;
00181                 };
00183                 iterator end()
00184                 {
00185                         <span class="keywordflow">return</span> elem + size;
00186                 };
00188                 const_iterator end()<span class="keyword"> const</span>
00189 <span class="keyword">                </span>{
00190                         <span class="keywordflow">return</span> elem + size;
00191                 };
00192                 
00197                 request_ptr write (<span class="keyword">const</span> BID&lt;SIZE&gt; &amp; bid, 
00198                             completion_handler on_cmpl = default_completion_handler())
00199                 {
00200                         <span class="keywordflow">return</span> bid.storage-&gt;awrite(
00201                                                 <span class="keyword">this</span>, 
00202                                                 bid.offset, 
00203                                                 SIZE, 
00204                                           on_cmpl);
00205                 };
00206 
00211                 request_ptr read (<span class="keyword">const</span> BID &lt; SIZE &gt; &amp;bid,
00212                            completion_handler on_cmpl = default_completion_handler())
00213                 {
00214                         <span class="keywordflow">return</span> bid.storage-&gt;aread(<span class="keyword">this</span>, bid.offset, SIZE, on_cmpl);
00215                 };
00216                 
00217                 <span class="keywordtype">void</span> *operator      new[] (size_t bytes)
00218                 {
00219                         <span class="keywordflow">return</span> aligned_alloc &lt; BLOCK_ALIGN &gt; (bytes);
00220                 }
00221                 <span class="keywordtype">void</span> *operator      new (size_t bytes)
00222                 {
00223                         <span class="keywordflow">return</span> aligned_alloc &lt; BLOCK_ALIGN &gt; (bytes);
00224                 }
00225                 <span class="keywordtype">void</span> operator      delete (<span class="keywordtype">void</span> *ptr)
00226                 {
00227                         aligned_dealloc &lt; BLOCK_ALIGN &gt; (ptr);
00228                 }
00229                 <span class="keywordtype">void</span> operator      delete[] (<span class="keywordtype">void</span> *ptr)
00230                 {
00231                         aligned_dealloc &lt; BLOCK_ALIGN &gt; (ptr);
00232                 }
00233         };
00234         
00235 
00236         
00237 <span class="comment">/*</span>
00238 <span class="comment">template &lt;unsigned BLK_SIZE&gt;</span>
00239 <span class="comment">class BIDArray: public std::vector&lt; BID &lt;BLK_SIZE&gt; &gt;</span>
00240 <span class="comment">{</span>
00241 <span class="comment"> public:</span>
00242 <span class="comment">  BIDArray(std::vector&lt; BID &lt;BLK_SIZE&gt; &gt;::size_type size = 0) : std::vector&lt; BID &lt;BLK_SIZE&gt; &gt;(size) {};</span>
00243 <span class="comment">};</span>
00244 <span class="comment">*/</span>
00245 
00246         <span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> BLK_SIZE&gt; 
00247   <span class="keyword">class </span>BIDArray
00248         {
00249         <span class="keyword">protected</span>:
00250                 <span class="keywordtype">unsigned</span> _size;
00251                 BID &lt; BLK_SIZE &gt; *array;
00252         <span class="keyword">public</span>:
00253                 <span class="keyword">typedef</span> BID&lt;BLK_SIZE&gt; &amp; reference;
00254                 <span class="keyword">typedef</span> BID&lt;BLK_SIZE&gt; * iterator;
00255                 <span class="keyword">typedef</span> <span class="keyword">const</span> BID&lt;BLK_SIZE&gt; * const_iterator;
00256                 BIDArray ():_size (0), array (NULL)
00257                 {
00258                 };
00259                 iterator begin ()
00260                 {
00261                         <span class="keywordflow">return</span> array;
00262                 };
00263                 iterator end ()
00264                 {
00265                         <span class="keywordflow">return</span> array + _size;
00266                 };
00267                 
00268           BIDArray (<span class="keywordtype">unsigned</span> size):_size (size)
00269                 {
00270                         array = <span class="keyword">new</span> BID &lt; BLK_SIZE &gt;[size];
00271                 };
00272                 <span class="keywordtype">unsigned</span> size ()
00273                 {
00274                         <span class="keywordflow">return</span> _size;
00275                 };
00276                 reference operator [](<span class="keywordtype">int</span> i)
00277                 {
00278                         <span class="keywordflow">return</span> array[i];
00279                 };
00280                 <span class="keywordtype">void</span> resize (<span class="keywordtype">unsigned</span> newsize)
00281                 {
00282                         <span class="keywordflow">if</span> (array)
00283                         {
00284                                 stxxl_debug (std::cerr &lt;&lt;
00285                                              <span class="stringliteral">"Warning: resizing nonempty BIDArray"</span>
00286                                              &lt;&lt; std::endl;)
00287                                 BID &lt; BLK_SIZE &gt; *tmp = array;
00288                                 array = <span class="keyword">new</span> BID &lt; BLK_SIZE &gt;[newsize];
00289                                 memcpy (array, tmp, <span class="keyword">sizeof</span> (BID &lt;BLK_SIZE &gt;) * STXXL_MIN (_size, newsize));
00290                                 <span class="keyword">delete</span> [] tmp;
00291                                 _size = newsize;
00292                         }
00293                         <span class="keywordflow">else</span>
00294                         {
00295                                 array = <span class="keyword">new</span> BID &lt; BLK_SIZE &gt;[newsize];
00296                                 _size = newsize;
00297                         }
00298                 };
00299                 ~BIDArray ()
00300                 {
00301                         <span class="keywordflow">if</span> (array)
00302                                 <span class="keyword">delete</span>[]array;
00303                 };
00304         };
00305 
00306 
00307         <span class="keyword">class </span>DiskAllocator
00308         {
00309                 <span class="keyword">typedef</span> std::pair &lt; off_t, off_t &gt; place;
00310                 <span class="keyword">struct </span>FirstFit:<span class="keyword">public</span> std::binary_function &lt; place, off_t,bool &gt;
00311                 {
00312                         <span class="keywordtype">bool</span> operator     () (
00313                                                                 <span class="keyword">const</span> place &amp; entry,
00314                                               <span class="keyword">const</span> off_t size)<span class="keyword"> const</span>
00315 <span class="keyword">                        </span>{
00316                                 <span class="keywordflow">return</span> (entry.second &gt;= size);
00317                         }
00318                 };
00319                 <span class="keyword">struct </span>OffCmp
00320                 {
00321                         <span class="keywordtype">bool</span> operator      () (<span class="keyword">const</span> off_t &amp; off1,<span class="keyword">const</span> off_t &amp; off2)
00322                         {
00323                                 <span class="keywordflow">return</span> off1 &lt; off2;
00324                         };
00325                 };
00326 
00327                 DiskAllocator ()
00328                 {
00329                 };
00330         <span class="keyword">protected</span>:
00331                 
00332                 <span class="keyword">typedef</span> std::map &lt; off_t, off_t &gt; sortseq;
00333                 sortseq free_space;
00334                 <span class="comment">//  sortseq used_space;</span>
00335                 off_t free_bytes;
00336                 off_t disk_bytes;
00337         
00338   <span class="keyword">public</span>:
00339                 DiskAllocator (off_t disk_size);
00340 
00341                 off_t get_free_bytes ()<span class="keyword"> const</span>
00342 <span class="keyword">                </span>{
00343                         <span class="keywordflow">return</span> free_bytes;
00344                 };
00345                 off_t get_used_bytes ()<span class="keyword"> const</span>
00346 <span class="keyword">                </span>{
00347                         <span class="keywordflow">return</span> disk_bytes - free_bytes;
00348                 };
00349 
00350                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00351                 <span class="keywordtype">void</span> new_blocks (BIDArray &lt; BLK_SIZE &gt; &amp;bids);
00352                 
00353                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00354                 <span class="keywordtype">void</span> delete_blocks (<span class="keyword">const</span> BIDArray &lt; BLK_SIZE &gt; &amp;bids);
00355                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt; 
00356                 <span class="keywordtype">void</span> delete_block (<span class="keyword">const</span> BID &lt;BLK_SIZE &gt; &amp; bid);
00357         };
00358 
00359   DiskAllocator::DiskAllocator (off_t disk_size):
00360                 free_bytes(disk_size),
00361                 disk_bytes(disk_size)
00362         {
00363                 free_space[0] = disk_size;
00364         }
00365 
00366   
00367   <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00368                 <span class="keywordtype">void</span> DiskAllocator::new_blocks (BIDArray &lt; BLK_SIZE &gt; &amp; bids)
00369         {
00370     STXXL_VERBOSE2(<span class="stringliteral">"DiskAllocator::new_blocks&lt;BLK_SIZE&gt;,  BLK_SIZE = "</span> &lt;&lt; BLK_SIZE
00371       &lt;&lt; <span class="stringliteral">", free:"</span> &lt;&lt; free_bytes &lt;&lt; <span class="stringliteral">" total:"</span>&lt;&lt; disk_bytes)
00372     
00373                 off_t requested_size = 0;
00374     <span class="keywordtype">unsigned</span> i = 0;
00375     <span class="keywordflow">for</span>(;i&lt;bids.size();i++)
00376     {
00377       STXXL_VERBOSE2(<span class="stringliteral">"Asking for a block with size: "</span>&lt;&lt;bids[i].<a class="code" href="structstxxl_1_1BID.html#s2s0">size</a>)
00378       <span class="comment">//assert(bids[i].size);</span>
00379       requested_size += bids[i].size;
00380     }
00381     
00382                 sortseq::iterator space = 
00383                         std::find_if (free_space.begin (), free_space.end (),
00384                                       bind2nd(FirstFit (), requested_size));
00385 
00386                 <span class="keywordflow">if</span> (space != free_space.end ())
00387                 {
00388                         off_t region_pos = (*space).first;
00389                         off_t region_size = (*space).second;
00390                         free_space.erase (space);
00391                         <span class="keywordflow">if</span> (region_size &gt; requested_size)
00392                                 free_space[region_pos + requested_size] = region_size - requested_size;
00393 
00394       bids[0].offset = region_pos;
00395                         <span class="keywordflow">for</span> (i = 1; i &lt; bids.size (); i++)
00396                         {
00397                                 bids[i].offset = bids[i-1].offset + bids[i-1].size;
00398                         }
00399                         free_bytes -= requested_size;
00400                 }
00401                 <span class="keywordflow">else</span>
00402                 {
00403                         STXXL_ERRMSG( <span class="stringliteral">"Allocation error: "</span> &lt;&lt; requested_size &lt;&lt;
00404                                 <span class="stringliteral">" bytes requested, "</span> &lt;&lt; free_bytes &lt;&lt;
00405                                 <span class="stringliteral">" bytes free"</span> )
00406                         abort();
00407                 }
00408         }
00409   
00410 
00411 
00412         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00413                 <span class="keywordtype">void</span> DiskAllocator::delete_block (<span class="keyword">const</span> BID &lt; BLK_SIZE &gt; &amp;bid)
00414         {
00415     STXXL_VERBOSE2(<span class="stringliteral">"DiskAllocator::delete_block&lt;BLK_SIZE&gt;,  BLK_SIZE = "</span> &lt;&lt; BLK_SIZE
00416       &lt;&lt; <span class="stringliteral">", free:"</span> &lt;&lt; free_bytes &lt;&lt; <span class="stringliteral">" total:"</span>&lt;&lt; disk_bytes)
00417     STXXL_VERBOSE2(<span class="stringliteral">"Deallocating a block with size: "</span>&lt;&lt;bid.size)
00418     <span class="comment">//assert(bid.size);</span>
00419                 off_t region_pos = bid.offset;
00420                 off_t region_size = bid.size;
00421                 sortseq::iterator succ = free_space.upper_bound (region_pos);
00422                 sortseq::iterator pred = succ;
00423                 pred--;
00424                 <span class="keywordflow">if</span> (succ != free_space.end ()
00425                     &amp;&amp; (*succ).first == region_pos + region_size)
00426                 {
00427                         <span class="comment">// coalesce with successor</span>
00428                         region_size += (*succ).second;
00429                         free_space.erase (succ);
00430                 }
00431                 <span class="keywordflow">if</span> (pred != free_space.end ()
00432                     &amp;&amp; (*pred).first + (*pred).second == region_pos)
00433                 {
00434                         <span class="comment">// coalesce with predecessor</span>
00435                         region_size += (*pred).second;
00436                         region_pos = (*pred).first;
00437                         free_space.erase (pred);
00438                 }
00439 
00440                 free_space[region_pos] = region_size;
00441                 free_bytes += off_t (bid.size);
00442         }
00443 
00444         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00445                 <span class="keywordtype">void</span> DiskAllocator::delete_blocks (<span class="keyword">const</span> BIDArray &lt; BLK_SIZE &gt; &amp;bids)
00446         {
00447                 STXXL_VERBOSE2(<span class="stringliteral">"DiskAllocator::delete_blocks&lt;BLK_SIZE&gt; BLK_SIZE="</span>&lt;&lt; BLK_SIZE &lt;&lt;
00448       <span class="stringliteral">", free:"</span> &lt;&lt; free_bytes &lt;&lt; <span class="stringliteral">" total:"</span>&lt;&lt; disk_bytes )
00449     
00450     <span class="keywordtype">unsigned</span> i=0;
00451                 <span class="keywordflow">for</span> (; i &lt; bids.size (); i++)
00452                 {
00453                         off_t region_pos = bids[i].offset;
00454                         off_t region_size = bids[i].size;
00455       STXXL_VERBOSE2(<span class="stringliteral">"Deallocating a block with size: "</span>&lt;&lt;region_size)
00456       assert(bids[i].<a class="code" href="structstxxl_1_1BID.html#s2s0">size</a>);
00457       
00458                         sortseq::iterator succ =
00459                                 free_space.upper_bound (region_pos);
00460                         sortseq::iterator pred = succ;
00461                         pred--;
00462 
00463                         <span class="keywordflow">if</span> (succ != free_space.end ()
00464                             &amp;&amp; (*succ).first == region_pos + region_size)
00465                         {
00466                                 <span class="comment">// coalesce with successor</span>
00467 
00468                                 region_size += (*succ).second;
00469                                 free_space.erase (succ);
00470                         }
00471                         <span class="keywordflow">if</span> (pred != free_space.end ()
00472                             &amp;&amp; (*pred).first + (*pred).second == region_pos)
00473                         {
00474                                 <span class="comment">// coalesce with predecessor</span>
00475 
00476                                 region_size += (*pred).second;
00477                                 region_pos = (*pred).first;
00478                                 free_space.erase (pred);
00479                         }
00480 
00481                         free_space[region_pos] = region_size;
00482                 };
00483     <span class="keywordflow">for</span>(;i&lt;bids.size();i++)
00484       free_bytes += off_t(bids[i].<a class="code" href="structstxxl_1_1BID.html#s2s0">size</a>);
00485         }
00486 
00489         <span class="keyword">class </span>config
00490         {
00491                 <span class="keyword">struct </span>DiskEntry
00492                 {
00493                         std::string path;
00494                         std::string io_impl;
00495                         off_t size;
00496                 };
00497                 std::vector &lt; DiskEntry &gt; disks_props;
00498                 
00499                 config (<span class="keyword">const</span> <span class="keywordtype">char</span> *config_path = <span class="stringliteral">"./.stxxl"</span>);
00500          <span class="keyword">public</span>:
00503                 <span class="keywordtype">unsigned</span> <a class="code" href="classstxxl_1_1config.html#a0">disks_number</a>()
00504                 {
00505                         <span class="keywordflow">return</span> disks_props.size ();
00506                 };
00507                 
00508                 <span class="keywordtype">unsigned</span> ndisks()
00509                 {
00510                         <span class="keywordflow">return</span> disks_props.size ();
00511                 };
00512                 
00516                 <span class="keyword">const</span> std::string &amp; <a class="code" href="classstxxl_1_1config.html#a2">disk_path</a> (<span class="keywordtype">int</span> disk)
00517                 {
00518                         <span class="keywordflow">return</span> disks_props[disk].path;
00519                 };
00523                 off_t <a class="code" href="classstxxl_1_1config.html#a3">disk_size</a> (<span class="keywordtype">int</span> disk)
00524                 {
00525                         <span class="keywordflow">return</span> disks_props[disk].size;
00526                 };
00529                 <span class="keyword">const</span> std::string &amp; <a class="code" href="classstxxl_1_1config.html#a4">disk_io_impl</a> (<span class="keywordtype">int</span> disk)
00530                 {
00531                         <span class="keywordflow">return</span> disks_props[disk].io_impl;
00532                 };
00533 
00536                 <span class="keyword">static</span> config *<a class="code" href="group__mnglayer.html#a8">get_instance</a> ();
00537         <span class="keyword">private</span>:
00538                 <span class="keyword">static</span> config *instance;
00539         };
00540 
00541 
00542         config *config::get_instance ()
00543         {
00544                 <span class="keywordflow">if</span> (!instance)
00545                 {
00546                         <span class="keywordtype">char</span> *cfg_path = getenv (<span class="stringliteral">"STXXLCFG"</span>);
00547                         <span class="keywordflow">if</span> (cfg_path)
00548                                 instance = <span class="keyword">new</span> config (cfg_path);
00549                         <span class="keywordflow">else</span>
00550                                 instance = <span class="keyword">new</span> config ();
00551                 }
00552 
00553                 <span class="keywordflow">return</span> instance;
00554         }
00555 
00556 
00557         config::config (<span class="keyword">const</span> <span class="keywordtype">char</span> *config_path)
00558         {
00559                 std::ifstream cfg_file (config_path);
00560                 <span class="keywordflow">if</span> (!cfg_file)
00561                 {
00562                         STXXL_ERRMSG(<span class="stringliteral">"Warning: no config file found."</span> )
00563                         STXXL_ERRMSG(<span class="stringliteral">"Using default disk configuration."</span> )
00564                         DiskEntry entry1 = { <span class="stringliteral">"/var/tmp/stxxl"</span>, <span class="stringliteral">"syscall"</span>,
00565                                 100 * 1024 * 1024
00566                         };
00567                         DiskEntry entry2 =
00568                                 { <span class="stringliteral">"/tmp/stxxl1"</span>, <span class="stringliteral">"mmap"</span>, 100 * 1024 * 1024 };
00569                         DiskEntry entry3 = { <span class="stringliteral">"/tmp/stxxl2"</span>, <span class="stringliteral">"simdisk"</span>,
00570                                 100 * 1024 * 1024
00571                         };
00572                         disks_props.push_back (entry1);
00573                         <span class="comment">//disks_props.push_back (entry2);</span>
00574                         <span class="comment">//disks_props.push_back (entry3);</span>
00575                 }
00576                 <span class="keywordflow">else</span>
00577                 {
00578                         std::string line;
00579 
00580                         <span class="keywordflow">while</span> (cfg_file &gt;&gt; line)
00581                         {
00582                                 std::vector &lt; std::string &gt; tmp = split (line, <span class="stringliteral">"="</span>);
00583                                 
00584                                 <span class="keywordflow">if</span>(tmp[0][0] == <span class="charliteral">'#'</span>)
00585                                 {
00586                                 }
00587                                 <span class="keywordflow">else</span>
00588                                 <span class="keywordflow">if</span> (tmp[0] == <span class="stringliteral">"disk"</span>)
00589                                 {
00590                                         tmp = split (tmp[1], <span class="stringliteral">","</span>);
00591                                         DiskEntry entry = { tmp[0], tmp[2],
00592                                                         off_t (str2int (tmp[1])) *
00593                                                         off_t (1024 * 1024)
00594                                         };
00595                                         disks_props.push_back (entry);
00596                                 }
00597                                 <span class="keywordflow">else</span>
00598                                 {
00599                                         std::cerr &lt;&lt; <span class="stringliteral">"Unknown token "</span> &lt;&lt;
00600                                                 tmp[0] &lt;&lt; std::endl;
00601                                 }
00602                         }
00603                         cfg_file.close ();
00604                 }
00605 
00606                 <span class="keywordflow">if</span> (disks_props.empty ())
00607                 {
00608                         STXXL_ERRMSG( <span class="stringliteral">"No disks found in '"</span> &lt;&lt; config_path &lt;&lt; <span class="stringliteral">"' ."</span> )
00609                         abort ();
00610                 }
00611                 <span class="keywordflow">else</span>
00612                 {
00613                         <span class="keywordflow">for</span> (std::vector &lt; DiskEntry &gt;::const_iterator it =
00614                              disks_props.begin (); it != disks_props.end ();
00615                              it++)
00616                         {
00617                                 STXXL_MSG(<span class="stringliteral">"Disk '"</span> &lt;&lt; (*it).path &lt;&lt; <span class="stringliteral">"' is allocated, space: "</span> &lt;&lt;
00618                                         ((*it).size) / (1024 * 1024) &lt;&lt;
00619                                         <span class="stringliteral">" Mb, I/O implementation: "</span> &lt;&lt; (*it).io_impl )
00620                         }
00621                 }
00622         };
00623 
00624         <span class="keyword">class </span>FileCreator
00625         {
00626         <span class="keyword">public</span>:
00627                 <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1file.html">stxxl::file</a> * create (<span class="keyword">const</span> std::string &amp; io_impl,
00628                                               <span class="keyword">const</span> std::string &amp; filename,
00629                                               <span class="keywordtype">int</span> options, <span class="keywordtype">int</span> disk)
00630                 {
00631                         <span class="keywordflow">if</span> (io_impl == <span class="stringliteral">"syscall"</span>)
00632                                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstxxl_1_1syscall__file.html">stxxl::syscall_file</a> (filename,
00633                                                                 options,
00634                                                                 disk);
00635                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (io_impl == <span class="stringliteral">"mmap"</span>)
00636                                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstxxl_1_1mmap__file.html">stxxl::mmap_file</a> (filename,
00637                                                              options, disk);
00638                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (io_impl == <span class="stringliteral">"simdisk"</span>)
00639                                 <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classstxxl_1_1sim__disk__file.html">stxxl::sim_disk_file</a> (filename,
00640                                                                  options,
00641                                                                  disk);
00642 
00643                         STXXL_ERRMSG(<span class="stringliteral">"Unsupported disk I/O implementation "</span> &lt;&lt;
00644                                 io_impl &lt;&lt; <span class="stringliteral">" ."</span> )
00645                         abort ();
00646 
00647                         <span class="keywordflow">return</span> NULL;
00648                 };
00649         };
00650   
00654 
00657         <span class="keyword">struct </span>striping
00658         {
00659                 <span class="keywordtype">int</span> begin, diff;
00660                 striping (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):begin (b), diff (e - b)
00661                 {
00662                 };
00663           striping ():begin (0)
00664                 {
00665                         diff = config::get_instance ()-&gt;disks_number ();
00666                 };
00667                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00668 <span class="keyword">                </span>{
00669                         <span class="keywordflow">return</span> begin + i % diff;
00670                 };
00671                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00672                 {
00673                         <span class="keywordflow">return</span> <span class="stringliteral">"striping"</span>;
00674                 }
00675         };
00676 
00679         <span class="keyword">struct </span>FR:<span class="keyword">public</span> striping
00680         {
00681                 random_number&lt;random_uniform_fast&gt; rnd;
00682                 FR (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):striping (b, e)
00683                 {
00684                 };
00685           FR ():striping ()
00686                 {
00687                 };
00688                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00689 <span class="keyword">                </span>{
00690                         <span class="keywordflow">return</span> begin + rnd(diff);
00691                 }
00692                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00693                 {
00694                         <span class="keywordflow">return</span> <span class="stringliteral">"fully randomized striping"</span>;
00695                 }
00696         };
00697 
00700         <span class="keyword">struct </span>SR:<span class="keyword">public</span> striping
00701         {
00702                 random_number&lt;random_uniform_fast&gt; rnd;
00703                 <span class="keywordtype">int</span> offset;
00704                 SR (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):striping (b, e)
00705                 {
00706                         offset = rnd(diff);
00707                 };
00708                 SR():striping ()
00709                 {
00710                         offset = rnd(diff);
00711                 };
00712                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00713 <span class="keyword">                </span>{
00714                         <span class="keywordflow">return</span> begin + (i + offset) % diff;
00715                 }
00716                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00717                 {
00718                         <span class="keywordflow">return</span> <span class="stringliteral">"simple randomized striping"</span>;
00719                 }
00720         };
00721 
00724         <span class="keyword">struct </span>RC:<span class="keyword">public</span> striping
00725         {
00726                 std::vector&lt;int&gt; perm;
00727                  
00728                 RC (<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> e):striping (b, e), perm (diff)
00729                 {
00730                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; diff; i++)
00731                                 perm[i] = i;
00732 
00733                         stxxl::random_number&lt;random_uniform_fast&gt; rnd;
00734                         std::random_shuffle (perm.begin (), perm.end (), rnd);
00735                 }
00736                 RC ():striping (), perm (diff)
00737                 {
00738                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; diff; i++)
00739                                 perm[i] = i;
00740 
00741                         random_number&lt;random_uniform_fast&gt; rnd;
00742                         std::random_shuffle (perm.begin (), perm.end (), rnd);
00743                 }
00744                 <span class="keywordtype">int</span> operator     () (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00745 <span class="keyword">                </span>{
00746                         <span class="keywordflow">return</span> begin + perm[i % diff];
00747                 }
00748                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00749                 {
00750                         <span class="keywordflow">return</span> <span class="stringliteral">"randomized cycling striping"</span>;
00751                 }
00752         };
00753 
00756         <span class="keyword">struct </span>single_disk
00757         {
00758                 <span class="keyword">const</span> <span class="keywordtype">int</span> disk;
00759                 single_disk(<span class="keywordtype">int</span> d):disk(d)
00760                 {
00761                 };
00762           
00763     single_disk():disk(0)
00764                 {
00765                 };
00766                 <span class="keywordtype">int</span> operator() (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00767 <span class="keyword">                </span>{
00768                         <span class="keywordflow">return</span> disk;
00769                 };
00770                 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * name()
00771                 {
00772                         <span class="keywordflow">return</span> <span class="stringliteral">"single disk"</span>;
00773                 }
00774         };
00775   
00777   
00779   <span class="keyword">template</span> &lt;<span class="keyword">class</span> BaseAllocator_&gt;
00780   <span class="keyword">struct </span>offset_allocator
00781   {
00782     BaseAllocator_ base;
00783     <span class="keywordtype">int</span> offset;
00787     <a class="code" href="structstxxl_1_1offset__allocator.html#a0">offset_allocator</a>(<span class="keywordtype">int</span> offset_) : base(),offset(offset_) {}
00792     <a class="code" href="structstxxl_1_1offset__allocator.html#a0">offset_allocator</a>(<span class="keywordtype">int</span> offset_,BaseAllocator_ &amp; base_) : base(base_),offset(offset_) {}
00793     <span class="keywordtype">int</span> operator() (<span class="keywordtype">int</span> i)
00794     {
00795       <span class="keywordflow">return</span> base(offset + i);
00796     }
00797   };
00798 
00800   
00802         <span class="keyword">template</span> &lt; <span class="keyword">class</span> bid_it &gt; 
00803   <span class="keyword">struct </span>bid_iterator_traits
00804         {
00805                 bid_it *a;
00806                 <span class="keyword">enum</span>
00807                 {
00808                         block_size = bid_it::block_size
00809                 };
00810         };
00811 
00812         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz &gt; 
00813   <span class="keyword">struct </span>bid_iterator_traits &lt;BID &lt;blk_sz &gt; *&gt;
00814         {
00815                 <span class="keyword">enum</span>
00816                 {
00817                         block_size = blk_sz
00818                 };
00819         };
00820 
00821 <span class="comment">/*</span>
00822 <span class="comment">        template &lt; unsigned _blk_sz &gt; struct bid_iterator_traits&lt;</span>
00823 <span class="comment">                std::__normal_iterator&lt; BID&lt;_blk_sz&gt; * ,std::vector&lt; BID&lt;_blk_sz&gt; ,std::allocator&lt;BID&lt;_blk_sz&gt; &gt; &gt;  &gt; &gt;</span>
00824 <span class="comment">                         </span>
00825 <span class="comment">        {</span>
00826 <span class="comment">                enum</span>
00827 <span class="comment">                {</span>
00828 <span class="comment">                        block_size = _blk_sz</span>
00829 <span class="comment">                };      </span>
00830 <span class="comment">        };</span>
00831 <span class="comment">*/</span>
00832 <span class="comment">/*</span>
00833 <span class="comment">        template &lt; unsigned _blk_sz &gt; struct bid_iterator_traits&lt;</span>
00834 <span class="comment">                __gnu_cxx::__normal_iterator&lt; BID&lt;_blk_sz&gt; * ,std::vector&lt; BID&lt;_blk_sz&gt; ,std::allocator&lt;BID&lt;_blk_sz&gt; &gt; &gt;  &gt; &gt;</span>
00835 <span class="comment">        {</span>
00836 <span class="comment">                enum</span>
00837 <span class="comment">                {</span>
00838 <span class="comment">                        block_size = _blk_sz</span>
00839 <span class="comment">                };      </span>
00840 <span class="comment">        };      */</span>
00841   
00842   <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz,<span class="keyword">class</span> X &gt; 
00843   <span class="keyword">struct </span>bid_iterator_traits&lt; __gnu_cxx::__normal_iterator&lt; BID&lt;blk_sz&gt; *,  X&gt; &gt;
00844         {
00845                 <span class="keyword">enum</span>
00846                 {
00847                         block_size = blk_sz
00848                 };      
00849         };
00850   
00851   <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz,<span class="keyword">class</span> X , <span class="keyword">class</span> Y&gt; 
00852   <span class="keyword">struct </span>bid_iterator_traits&lt; std::_List_iterator&lt;BID&lt;blk_sz&gt;,X,Y &gt; &gt;
00853         {
00854                 <span class="keyword">enum</span>
00855                 {
00856                         block_size = blk_sz
00857                 };      
00858         }; 
00859   
00860   <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz, <span class="keyword">class</span> X &gt; 
00861   <span class="keyword">struct </span>bid_iterator_traits&lt; typename std::vector&lt; BID&lt;blk_sz&gt; , X &gt;::iterator &gt;
00862         {
00863                 <span class="keyword">enum</span>
00864                 {
00865                         block_size = blk_sz
00866                 };      
00867         };
00868 
00870         
00873         <span class="keyword">class </span>block_manager
00874         {
00875                 DiskAllocator **disk_allocators;
00876                 file ** disk_files;
00877                 
00878                 <span class="keywordtype">unsigned</span> ndisks;
00879                 block_manager ();
00880         
00881         <span class="keyword">public</span>:
00884                 <span class="keyword">static</span> block_manager *<a class="code" href="group__mnglayer.html#a10">get_instance</a> ();
00885 
00887                 
00894                 <span class="keyword">template</span> &lt; <span class="keyword">class</span> DiskAssgnFunctor, <span class="keyword">class</span> BIDIteratorClass &gt;
00895                 <span class="keywordtype">void</span> <a class="code" href="group__mnglayer.html#a13">new_blocks</a> (
00896                                          DiskAssgnFunctor functor,
00897                                          <span class="keyword">const</span> BIDIteratorClass &amp; bidbegin,
00898                                          <span class="keyword">const</span> BIDIteratorClass &amp; bidend);
00899 
00901                 
00905                 <span class="keyword">template</span> &lt; <span class="keyword">class</span> BIDIteratorClass &gt;
00906                 <span class="keywordtype">void</span> <a class="code" href="group__mnglayer.html#a15">delete_blocks</a> (<span class="keyword">const</span> BIDIteratorClass &amp; bidbegin, <span class="keyword">const</span> BIDIteratorClass &amp; bidend);
00907 
00910                 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
00911           <span class="keywordtype">void</span> <a class="code" href="group__mnglayer.html#a14">delete_block</a> (<span class="keyword">const</span> BID &lt; BLK_SIZE &gt; &amp;bid);
00912 
00913                 ~block_manager ();
00914         <span class="keyword">private</span>:
00915                 <span class="keyword">static</span> block_manager *instance;
00916         };
00917 
00918         block_manager *block_manager::get_instance ()
00919         {
00920                 <span class="keywordflow">if</span> (!instance)
00921                         instance = <span class="keyword">new</span> block_manager ();
00922 
00923                 <span class="keywordflow">return</span> instance;
00924         }
00925 
00926         block_manager::block_manager ()
00927         {
00928                 FileCreator fc;
00929                 config *cfg = config::get_instance ();
00930 
00931                 ndisks = cfg-&gt;disks_number ();
00932                 disk_allocators = <span class="keyword">new</span> DiskAllocator *[ndisks];
00933                 disk_files = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1file.html">stxxl::file</a> *[ndisks];
00934 
00935                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; ndisks; i++)
00936                 {
00937                         disk_files[i] = fc.create (cfg-&gt;disk_io_impl (i),
00938                                                    cfg-&gt;disk_path (i),
00939                                                    <a class="code" href="classstxxl_1_1file.html#s6s3">stxxl::file::CREAT</a> | <a class="code" href="classstxxl_1_1file.html#s6s2">stxxl::file::RDWR</a>  <span class="comment">// | stxxl::file::DIRECT</span>
00940                                                    ,i);
00941                         disk_files[i]-&gt;set_size (cfg-&gt;disk_size (i));
00942                         disk_allocators[i] = <span class="keyword">new</span> DiskAllocator (cfg-&gt;disk_size (i));
00943                 }
00944         };
00945 
00946         block_manager::~block_manager()
00947         {
00948                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; ndisks; i++)
00949                 {
00950                         <span class="keyword">delete</span> disk_allocators[i];
00951                         <span class="keyword">delete</span> disk_files[i];
00952                 }
00953                 <span class="keyword">delete</span>[]disk_allocators;
00954                 <span class="keyword">delete</span>[]disk_files;
00955         }
00956 
00957 
00958         <span class="keyword">template</span> &lt; <span class="keyword">class</span> DiskAssgnFunctor, <span class="keyword">class</span> BIDIteratorClass &gt;
00959                 <span class="keywordtype">void</span> block_manager::new_blocks (
00960                                                 DiskAssgnFunctor functor,
00961                                                 <span class="keyword">const</span> BIDIteratorClass &amp; bidbegin,
00962                                                 <span class="keyword">const</span> BIDIteratorClass &amp; bidend)
00963         {
00964     <span class="keyword">typedef</span>  BIDArray&lt;bid_iterator_traits &lt;BIDIteratorClass &gt;::block_size&gt; bid_array_type;
00965                 <span class="keywordtype">unsigned</span> nblocks = 0;<span class="comment">//std::distance(bidbegin,bidend);</span>
00966     
00967     BIDIteratorClass bidbegin_copy(bidbegin);
00968     <span class="keywordflow">while</span>(bidbegin_copy != bidend)
00969     {
00970       ++bidbegin_copy;
00971       ++nblocks;
00972     }
00973 
00974                 <span class="keywordtype">int</span> *bl = <span class="keyword">new</span> <span class="keywordtype">int</span>[ndisks];
00975                 bid_array_type * disk_bids = <span class="keyword">new</span> bid_array_type[ndisks];
00976 
00977                 memset(bl, 0, ndisks * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
00978 
00979                 <span class="keywordtype">unsigned</span> i = 0;
00980                 BIDIteratorClass it = bidbegin;
00981                 <span class="keywordflow">for</span> (; i &lt; nblocks; i++, it++)
00982                 {
00983                         <span class="keywordtype">int</span> disk = functor (i);
00984                         (*it).storage = disk_files[disk];
00985                         bl[disk]++;
00986                 }
00987 
00988                 <span class="keywordflow">for</span> (i = 0; i &lt; ndisks; i++)
00989                 {
00990                         <span class="keywordflow">if</span> (bl[i])
00991                                 disk_bids[i].resize (bl[i]);
00992                 }
00993     
00994     memset (bl, 0, ndisks * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
00995     
00996                 <span class="keywordflow">for</span> (i=0,it = bidbegin; it != bidend; it++, i++)
00997                 {
00998                         <span class="keywordtype">int</span> disk = (*it).storage-&gt;get_disk_number ();
00999                         disk_bids[disk][bl[disk]++] = (*it);
01000                 }
01001     <span class="keywordflow">for</span> (i = 0; i &lt; ndisks; i++)
01002                 {
01003                         <span class="keywordflow">if</span> (bl[i])
01004                                 disk_allocators[i]-&gt;new_blocks (disk_bids[i]);
01005                 }
01006 
01007                 memset (bl, 0, ndisks * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));
01008     
01009                 <span class="keywordflow">for</span> (i=0,it = bidbegin; it != bidend; it++, i++)
01010                 {
01011                         <span class="keywordtype">int</span> disk = (*it).storage-&gt;get_disk_number ();
01012                         (*it).offset = disk_bids[disk][bl[disk]++].offset;
01013                 }
01014 
01015                 <span class="keyword">delete</span>[]bl;
01016                 <span class="keyword">delete</span>[]disk_bids;
01017         }
01018 
01019 
01020 
01021         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BLK_SIZE &gt;
01022         <span class="keywordtype">void</span> block_manager::delete_block (<span class="keyword">const</span> BID &lt; BLK_SIZE &gt; &amp;bid)
01023         {
01024                 disk_allocators[bid.storage-&gt;get_disk_number ()]-&gt;delete_block (bid);
01025         }
01026 
01027 
01028         <span class="keyword">template</span> &lt; <span class="keyword">class</span> BIDIteratorClass &gt;
01029                 <span class="keywordtype">void</span> block_manager::delete_blocks (
01030                                                 <span class="keyword">const</span> BIDIteratorClass &amp; bidbegin,
01031                               <span class="keyword">const</span> BIDIteratorClass &amp; bidend)
01032         {
01033                 <span class="keywordflow">for</span> (BIDIteratorClass it = bidbegin; it != bidend; it++)
01034                 {
01035                         delete_block (*it);
01036                 }
01037         }
01038 
01039         block_manager *block_manager::instance = NULL;
01040         config *config::instance = NULL;
01041 
01042 <span class="preprocessor">  #define STXXL_DEFAULT_ALLOC_STRATEGY RC   </span>
01043 <span class="preprocessor"></span><span class="preprocessor">  #define STXXL_DEFAULT_BLOCK_SIZE(type) (2*1024*1024)  // use traits</span>
01044 <span class="preprocessor"></span>  
01046   
01047 __STXXL_END_NAMESPACE
01048 
01049 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Thu Oct 2 11:21:23 2003 for &lt;stxxl&gt; by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
