<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>intksort.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>intksort.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef INTKSORT_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define INTKSORT_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            keysort.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Thu Sep 26 18:07:14 2002</span>
00008 <span class="comment"> *  Copyright  2002 Peter Sanders</span>
00009 <span class="comment"> *  sanders@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 <span class="preprocessor">#include "../common/utils.h"</span>
00012 
00013 __STXXL_BEGIN_NAMESPACE
00014 
00015 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_key&gt;
00016 <span class="keyword">static</span> <span class="keywordtype">void</span>
00017 count (type_key * a, type_key * aEnd, <span class="keywordtype">int</span> *bucket, <span class="keywordtype">int</span> K, <span class="keyword">typename</span> type_key::key_type offset,
00018        <span class="keywordtype">unsigned</span> shift)
00019 {
00020         <span class="comment">// reset buckets</span>
00021         std::fill(bucket, bucket+K, 0);
00022         
00023         <span class="comment">// count occupancies</span>
00024         <span class="keywordflow">for</span> (type_key * p = a; p &lt; aEnd; p++)
00025         {
00026                 <span class="keywordtype">int</span> i = (p-&gt;key - offset) &gt;&gt; shift;
00027                 <span class="comment">/*if(!(i&lt;K &amp;&amp; i&gt;=0))</span>
00028 <span class="comment">                {</span>
00029 <span class="comment">                        STXXL_ERRMSG("i: "&lt;&lt;i)</span>
00030 <span class="comment">                        abort();</span>
00031 <span class="comment">                }*/</span>
00032                 bucket[i]++;
00033         }
00034 }
00035 
00036 
00037 <span class="keyword">static</span> <span class="keywordtype">void</span>
00038 exclusive_prefix_sum (<span class="keywordtype">int</span> *bucket, <span class="keywordtype">int</span> K)
00039 {
00040         <span class="keywordtype">int</span> sum = 0;
00041         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; K; i++)
00042         {
00043                 <span class="keywordtype">int</span> current = bucket[i];
00044                 bucket[i] = sum;
00045                 sum += current;
00046         }
00047 }
00048 
00049 
00050 <span class="comment">// distribute input a to output b using bucket for the starting indices</span>
00051 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_key&gt; <span class="keyword">static</span> <span class="keywordtype">void</span>
00052 classify (type_key * a, type_key * aEnd, type_key * b, <span class="keywordtype">int</span> *bucket, <span class="keyword">typename</span> type_key::key_type offset, <span class="keywordtype">unsigned</span> shift)
00053 {
00054         <span class="keywordflow">for</span> (type_key * p = a; p &lt; aEnd; p++)
00055         {
00056                 <span class="keywordtype">int</span> i = (p-&gt;key - offset) &gt;&gt; shift;
00057                 <span class="keywordtype">int</span> bi = bucket[i];
00058                 b[bi] = *p;
00059                 bucket[i] = bi + 1;
00060         }
00061 }
00062 
00063 
00064 
00065 <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
00066 sort2 (T &amp; a, T &amp; b)
00067 {
00068         <span class="keywordflow">if</span> (b &lt; a)
00069                 std::swap (a, b);
00070 }
00071 
00072 <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
00073 sort3 (T &amp; a, T &amp; b, T &amp; c)
00074 {
00075         T temp;
00076         <span class="keywordflow">if</span> (b &lt; a)
00077         {
00078                 <span class="keywordflow">if</span> (c &lt; a)
00079                 {               <span class="comment">// b , c &lt; a</span>
00080                         <span class="keywordflow">if</span> (b &lt; c)
00081                         {       <span class="comment">// b &lt; c &lt; a</span>
00082                                 temp = a;
00083                                 a = b;
00084                                 b = c;
00085                                 c = temp;
00086                         }
00087                         <span class="keywordflow">else</span>
00088                         {       <span class="comment">// c &lt;=b &lt; a</span>
00089                                 swap (c, a);
00090                         }
00091                 }
00092                 <span class="keywordflow">else</span>
00093                 {               <span class="comment">// b &lt; a &lt;=c</span>
00094                         swap (a, b);
00095                 }
00096         }
00097         <span class="keywordflow">else</span>
00098         {                       <span class="comment">// a &lt;=b</span>
00099                 <span class="keywordflow">if</span> (c &lt; a)
00100                 {               <span class="comment">// c &lt; a &lt;=b</span>
00101                         temp = a;
00102                         a = c;
00103                         c = b;
00104                         b = temp;
00105                 }
00106                 <span class="keywordflow">else</span>
00107                 {               <span class="comment">// a &lt;=b , c</span>
00108                         <span class="keywordflow">if</span> (c &lt; b)
00109                         {       <span class="comment">// a &lt;=c &lt; b</span>
00110                                 swap (b, c);
00111                         }
00112                 }
00113         }
00114         <span class="comment">// Assert1 (!(b &lt; a) &amp;&amp; !(c &lt; b));</span>
00115 }
00116 
00117 
00118 <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
00119 sort4 (T &amp; a, T &amp; b, T &amp; c, T &amp; d)
00120 {
00121         sort2 (a, b);
00122         sort2 (c, d);           <span class="comment">// a &lt; b ; c &lt; d</span>
00123         <span class="keywordflow">if</span> (c &lt; a)
00124         {                       <span class="comment">// c minimal, a &lt; b</span>
00125                 <span class="keywordflow">if</span> (d &lt; a)
00126                 {               <span class="comment">// c &lt; d &lt; a &lt; b</span>
00127                         swap (a, c);
00128                         swap (b, d);
00129                 }
00130                 <span class="keywordflow">else</span>
00131                 {               <span class="comment">// c &lt; a &lt; {db}</span>
00132                         <span class="keywordflow">if</span> (d &lt; b)
00133                         {       <span class="comment">// c &lt; a &lt; d &lt; b</span>
00134                                 T temp = a;
00135                                 a = c;
00136                                 c = d;
00137                                 d = b;
00138                                 b = temp;
00139                         }
00140                         <span class="keywordflow">else</span>
00141                         {       <span class="comment">// c &lt; a &lt; b &lt; d        </span>
00142                                 T temp = a;
00143                                 a = c;
00144                                 c = b;
00145                                 b = temp;
00146                         }
00147                 }
00148         }
00149         <span class="keywordflow">else</span>
00150         {                       <span class="comment">// a minimal ; c &lt; d</span>
00151                 <span class="keywordflow">if</span> (c &lt; b)
00152                 {               <span class="comment">// c &lt; (bd)</span>
00153                         <span class="keywordflow">if</span> (d &lt; b)
00154                         {       <span class="comment">// c &lt; d &lt; b</span>
00155                                 T temp = b;
00156                                 b = c;
00157                                 c = d;
00158                                 d = temp;
00159                         }
00160                         <span class="keywordflow">else</span>
00161                         {       <span class="comment">// a &lt; c &lt; b &lt; d</span>
00162                                 swap (b, c);
00163                         }
00164                 }               <span class="comment">// else sorted</span>
00165         }
00166         <span class="comment">//Assert1 (!(b &lt; a) &amp;&amp; !(c &lt; b) &amp; !(d &lt; c));</span>
00167 }
00168 
00169 
00170 <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
00171 sort5 (T &amp; a, T &amp; b, T &amp; c, T &amp; d, T &amp; e)
00172 {
00173         sort2 (a, b);
00174         sort2 (d, e);
00175         <span class="keywordflow">if</span> (d &lt; a)
00176         {
00177                 swap (a, d);
00178                 swap (b, e);
00179         }                       <span class="comment">// a &lt; d &lt; e, a &lt; b</span>
00180         <span class="keywordflow">if</span> (d &lt; c)
00181         {
00182                 swap (c, d);    <span class="comment">// a minimal, c &lt; {de}</span>
00183                 sort2 (d, e);
00184         }
00185         <span class="keywordflow">else</span>
00186         {                       <span class="comment">// a&lt;b, a&lt;d&lt;e, c&lt;d&lt;e</span>
00187                 sort2 (a, c);
00188         }                       <span class="comment">// a min, c &lt; d &lt; e</span>
00189         <span class="comment">// insert b int cde by binary search</span>
00190         <span class="keywordflow">if</span> (d &lt; b)
00191         {                       <span class="comment">// c &lt; d &lt; {be}</span>
00192                 <span class="keywordflow">if</span> (e &lt; b)
00193                 {               <span class="comment">// c &lt; d &lt; e &lt; b</span>
00194                         T temp = b;
00195                         b = c;
00196                         c = d;
00197                         d = e;
00198                         e = temp;
00199                 }
00200                 <span class="keywordflow">else</span>
00201                 {               <span class="comment">// c &lt; d &lt; b &lt; e</span>
00202                         T temp = b;
00203                         b = c;
00204                         c = d;
00205                         d = temp;
00206                 }
00207         }
00208         <span class="keywordflow">else</span>
00209         {                       <span class="comment">// {cb} &lt;=d &lt; e </span>
00210                 sort2 (b, c);
00211         }
00212         <span class="comment">//Assert1 (!(b &lt; a) &amp;&amp; !(c &lt; b) &amp; !(d &lt; c) &amp; !(e &lt; d));</span>
00213 }
00214 
00215 
00216 <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
00217 insertion_sort (T * a, T * aEnd)
00218 {
00219         T *pp;
00220         <span class="keywordflow">for</span> (T * p = a + 1; p &lt; aEnd; p++)
00221         {
00222                 <span class="comment">// Invariant a..p-1 is sorted;</span>
00223                 T t = *p;
00224                 <span class="keywordflow">if</span> (t &lt; *a)
00225                 {               <span class="comment">// new minimum</span>
00226                         <span class="comment">// move stuff to the right</span>
00227                         <span class="keywordflow">for</span> (pp = p; pp != a; pp--)
00228                         {
00229                                 *pp = *(pp - 1);
00230                         }
00231                         *pp = t;
00232                 }
00233                 <span class="keywordflow">else</span>
00234                 {
00235                         <span class="comment">// now we can use *a as a sentinel</span>
00236                         <span class="keywordflow">for</span> (pp = p; t &lt; *(pp - 1); pp--)
00237                         {
00238                                 *pp = *(pp - 1);
00239                         }
00240                         *pp = t;
00241                 }
00242         }
00243 }
00244 
00245 <span class="comment">// sort each bucket</span>
00246 <span class="comment">// bucket[i] is an index one off to the right from</span>
00247 <span class="comment">// the end of the i-th bucket</span>
00248 <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt; <span class="keyword">static</span> <span class="keywordtype">void</span>
00249 cleanup (T * b, <span class="keywordtype">int</span> *bucket, <span class="keywordtype">int</span> K)
00250 {
00251         T *c = b;
00252         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; K; i++)
00253         {
00254                 T *cEnd = b + bucket[i];
00255                 <span class="keywordflow">switch</span> (cEnd - c)
00256                 {
00257                 <span class="keywordflow">case</span> 0:
00258                         <span class="keywordflow">break</span>;
00259                 <span class="keywordflow">case</span> 1:
00260                         <span class="keywordflow">break</span>;
00261                 <span class="keywordflow">case</span> 2:
00262                         sort2 (c[0], c[1]);
00263                         <span class="keywordflow">break</span>;
00264                 <span class="keywordflow">case</span> 3:
00265                         sort3 (c[0], c[1], c[2]);
00266                         <span class="keywordflow">break</span>;
00267                 <span class="keywordflow">case</span> 4:
00268                         sort4 (c[0], c[1], c[2], c[3]);
00269                         <span class="keywordflow">break</span>;
00270                 <span class="keywordflow">case</span> 5: <span class="comment">//sort5(c[0], c[1], c[2], c[3], c[4]);  break;</span>
00271                 <span class="keywordflow">case</span> 6:
00272                 <span class="keywordflow">case</span> 7:
00273                 <span class="keywordflow">case</span> 8:
00274                 <span class="keywordflow">case</span> 9:
00275                 <span class="keywordflow">case</span> 10:
00276                 <span class="keywordflow">case</span> 11:
00277                 <span class="keywordflow">case</span> 12:
00278                 <span class="keywordflow">case</span> 13:
00279                 <span class="keywordflow">case</span> 14:
00280                 <span class="keywordflow">case</span> 15:
00281                 <span class="keywordflow">case</span> 16:
00282                         insertion_sort (c, cEnd);
00283                         <span class="keywordflow">break</span>;
00284                 <span class="keywordflow">default</span>:
00285                         <a class="code" href="group__stlalgo.html#a12">std::sort</a> (c, cEnd);
00286                 }
00287                 c = cEnd;
00288         }
00289 }
00290 
00291 <span class="comment">// do a single level MDS radix sort</span>
00292 <span class="comment">// using bucket[0..K-1] as a counter array</span>
00293 <span class="comment">// and using (key(x) - offset) &gt;&gt; shift to index buckets.</span>
00294 <span class="comment">// and using (key(x) - offset) &gt;&gt; shift to index buckets.</span>
00295 <span class="comment">// the input comes from a..aEnd-1</span>
00296 <span class="comment">// the output goes to b</span>
00297 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type_key&gt;
00298 <span class="keywordtype">void</span>
00299 l1sort (type_key * a,
00300         type_key * aEnd,
00301         type_key * b, <span class="keywordtype">int</span> *bucket, <span class="keywordtype">int</span> K, <span class="keyword">typename</span> type_key::key_type offset, <span class="keywordtype">int</span> shift)
00302 {
00303         count(a, aEnd, bucket, K, offset, shift);
00304         exclusive_prefix_sum (bucket, K);
00305         classify (a, aEnd, b, bucket, offset, shift);
00306         cleanup (b, bucket, K);
00307 }
00308 
00309 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type,<span class="keyword">typename</span> type_key,<span class="keyword">typename</span> key_extractor&gt;
00310 <span class="keywordtype">void</span> classify_block(type * begin,type * end,type_key * &amp; out,
00311         <span class="keywordtype">int</span> * bucket,<span class="keyword">typename</span> type::key_type offset, <span class="keywordtype">unsigned</span> shift,key_extractor keyobj)
00312 {
00313         <span class="keywordflow">for</span> (type * p = begin;p&lt;end; p++,out++) <span class="comment">// count &amp; create references</span>
00314         {
00315                 out-&gt;ptr = p;
00316                 <span class="keyword">typename</span> type::key_type key = keyobj(*p);
00317                 <span class="keywordtype">int</span> ibucket = (key - offset) &gt;&gt; shift;
00318                 out-&gt;key = key;
00319                 bucket[ibucket]++;
00320         }
00321 }
00322 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type,<span class="keyword">typename</span> type_key,<span class="keyword">typename</span> key_extractor&gt;
00323 <span class="keywordtype">void</span> classify_block(type * begin,type * end,type_key * &amp; out,<span class="keywordtype">int</span> * bucket,<span class="keyword">typename</span> type::key_type offset, <span class="keywordtype">unsigned</span> shift, 
00324         <span class="keyword">const</span> <span class="keywordtype">int</span>  K, key_extractor keyobj)
00325 {
00326         <span class="keywordflow">for</span> (type * p = begin;p&lt;end; p++,out++) <span class="comment">// count &amp; create references</span>
00327         {
00328                 out-&gt;ptr = p;
00329                 <span class="keyword">typename</span> type::key_type key = keyobj(*p);
00330                 <span class="keywordtype">int</span> ibucket = (key - offset) &gt;&gt; shift;
00331                 <span class="comment">/*if(!(ibucket&lt;K &amp;&amp; ibucket&gt;=0))</span>
00332 <span class="comment">                {</span>
00333 <span class="comment">                        STXXL_ERRMSG("ibucket: "&lt;&lt;ibucket&lt;&lt;" K:"&lt;&lt;K)</span>
00334 <span class="comment">                        abort();</span>
00335 <span class="comment">                }*/</span>
00336                 out-&gt;key = key;
00337                 bucket[ibucket]++;
00338         }
00339 }
00340 
00341 
00342 __STXXL_END_NAMESPACE
00343 
00344 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Jul 1 11:08:35 2003 for &lt;stxxl&gt; by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
