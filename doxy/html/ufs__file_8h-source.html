<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: ufs_file.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>ufs_file.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef UFSFILEBASE_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define UFSFILEBASE_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            ufs_file.h</span>
00006 <span class="comment"> *  UNIX file system file base</span>
00007 <span class="comment"> *  Sat Aug 24 23:55:13 2002</span>
00008 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 
00013 <span class="preprocessor">#include "iobase.h"</span>
00014 
00015 __STXXL_BEGIN_NAMESPACE
00016 
00019 
00020         <span class="keyword">class </span>ufs_request_base;
00021 
<a name="l00023"></a><a class="code" href="classstxxl_1_1ufs__file__base.html">00023</a>         <span class="keyword">class </span><a class="code" href="classstxxl_1_1ufs__file__base.html">ufs_file_base</a>:<span class="keyword">public</span> <a class="code" href="classstxxl_1_1file.html">file</a>
00024         {
00025         <span class="keyword">protected</span>:
00026                 <span class="keywordtype">int</span> file_des;   <span class="comment">// file descriptor</span>
00027                 
00028                 <a class="code" href="classstxxl_1_1ufs__file__base.html">ufs_file_base</a> (<span class="keyword">const</span> std::string &amp; filename, <span class="keywordtype">int</span> mode, <span class="keywordtype">int</span> disk);
00029         <span class="keyword">private</span>:
00030                 <a class="code" href="classstxxl_1_1ufs__file__base.html">ufs_file_base</a> ();
00031         <span class="keyword">public</span>:
00032                 <span class="keywordtype">int</span> get_file_des()
00033                 {
00034                         <span class="keywordflow">return</span> file_des;
00035                 };
00036                 ~<a class="code" href="classstxxl_1_1ufs__file__base.html">ufs_file_base</a>();
00037                 off_t size ();
00038                 <span class="keywordtype">void</span> set_size(off_t newsize);
00039         };
00040 
<a name="l00042"></a><a class="code" href="classstxxl_1_1ufs__request__base.html">00042</a>         <span class="keyword">class </span><a class="code" href="classstxxl_1_1ufs__request__base.html">ufs_request_base</a>:<span class="keyword">public</span> <a class="code" href="classstxxl_1_1request.html">request</a>
00043         {
00044                 <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classstxxl_1_1ufs__file__base.html">ufs_file_base</a>;
00045         <span class="keyword">protected</span>:
00046                 <span class="comment">// states of request</span>
00047                 <span class="keyword">enum</span> { OP = 0, DONE = 1, READY2DIE = 2 };       <span class="comment">// OP - operating, DONE - request served, </span>
00048                                                                                                                                                                                         <span class="comment">// READY2DIE - can be destroyed</span>
00049                 <a class="code" href="classstxxl_1_1ufs__file__base.html">ufs_file_base</a> *<a class="code" href="classstxxl_1_1file.html">file</a>;
00050                 <span class="keywordtype">void</span> *buffer;
00051                 off_t offset;
00052                 size_t bytes;
00053                 request_type type;
00054                 
00055                 state _state;
00056                 mutex waiters_mutex;
00057                 std::set &lt; onoff_switch * &gt; waiters;
00058 
00059                 <a class="code" href="classstxxl_1_1ufs__request__base.html">ufs_request_base</a> (
00060                                 <a class="code" href="classstxxl_1_1ufs__file__base.html">ufs_file_base</a> * f, 
00061                                 <span class="keywordtype">void</span> *buf, 
00062                                 off_t off,
00063                                 size_t b, 
00064                                 request_type t,
00065                                 <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl):
00066                                         <a class="code" href="classstxxl_1_1request.html">request</a> (on_cmpl),
00067                                         <a class="code" href="classstxxl_1_1file.html">file</a> (f), 
00068                                         buffer (buf), 
00069                                         offset (off), 
00070                                         bytes (b),
00071                                         type(t),
00072                                         _state (OP)
00073                 {
00074 <span class="preprocessor">#ifdef STXXL_CHECK_BLOCK_ALIGNING</span>
00075 <span class="preprocessor"></span>                        <span class="comment">// Linux direct I/O requires filsystem block size alighnment for file offsets,</span>
00076                         <span class="comment">// memory buffer adresses, and transfer(buffer) size must be multiple</span>
00077                         <span class="comment">// of the filesystem block size</span>
00078                         check_aligning ();
00079 <span class="preprocessor">#endif</span>
00080 <span class="preprocessor"></span>                };<span class="comment">/*</span>
00081 <span class="comment">                void enqueue(request_ptr &amp; req)</span>
00082 <span class="comment">                {</span>
00083 <span class="comment">                        if (type == READ)</span>
00084 <span class="comment">                                disk_queues::get_instance ()-&gt;add_readreq(req,file-&gt;get_id());</span>
00085 <span class="comment">                        else</span>
00086 <span class="comment">                                disk_queues::get_instance ()-&gt;add_writereq(req,file-&gt;get_id());</span>
00087 <span class="comment">                };*/</span>
00088                 <span class="keywordtype">bool</span> add_waiter (onoff_switch * sw)
00089                 {
00090                         waiters_mutex.lock ();
00091 
00092                         <span class="keywordflow">if</span> (poll ()) <span class="comment">// request already finished</span>
00093                         {
00094                                 waiters_mutex.unlock ();
00095                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00096                         }
00097 
00098                         waiters.insert (sw);
00099                         waiters_mutex.unlock ();
00100 
00101                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00102                 };
00103                 <span class="keywordtype">void</span> delete_waiter (onoff_switch * sw)
00104                 {
00105                         waiters_mutex.lock ();
00106                         waiters.erase (sw);
00107                         waiters_mutex.unlock ();
00108                 };
00109                 <span class="keywordtype">int</span> nwaiters () <span class="comment">// returns number of waiters</span>
00110                 {
00111                         waiters_mutex.lock ();
00112                         <span class="keywordtype">int</span> size = waiters.size ();
00113                         waiters_mutex.unlock ();
00114                         <span class="keywordflow">return</span> size;
00115                 };
00116                 <span class="keywordtype">void</span> check_aligning ()
00117                 {
00118                         <span class="keywordflow">if</span> (offset % BLOCK_ALIGN)
00119                                 STXXL_ERRMSG (<span class="stringliteral">"Offset is not aligned: modulo "</span>
00120                                               &lt;&lt; BLOCK_ALIGN &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt;
00121                                               offset % BLOCK_ALIGN);
00122                         <span class="keywordflow">if</span> (bytes % BLOCK_ALIGN)
00123                                 STXXL_ERRMSG (<span class="stringliteral">"Size is multiple of "</span> &lt;&lt;
00124                                               BLOCK_ALIGN &lt;&lt; <span class="stringliteral">", = "</span> &lt;&lt; bytes % BLOCK_ALIGN);
00125                         <span class="keywordflow">if</span> (unsigned (buffer) % BLOCK_ALIGN)
00126                                 STXXL_ERRMSG (<span class="stringliteral">"Buffer is not aligned: modulo "</span>
00127                                               &lt;&lt; BLOCK_ALIGN &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt;
00128                                               <span class="keywordtype">unsigned</span> (buffer) % BLOCK_ALIGN &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; 
00129                                                                 std::hex &lt;&lt; buffer &lt;&lt; std::dec &lt;&lt; <span class="stringliteral">")"</span>);
00130                 };
00131         <span class="keyword">public</span>:
00132                 <span class="keyword">virtual</span> ~<a class="code" href="classstxxl_1_1ufs__request__base.html">ufs_request_base</a> ()
00133                 {
00134       STXXL_VERBOSE3(<span class="stringliteral">"ufs_request_base "</span>&lt;&lt; <span class="keywordtype">unsigned</span>(<span class="keyword">this</span>) &lt;&lt;<span class="stringliteral">": deletion, cnt: "</span>&lt;&lt;ref_cnt)
00135                         _state.wait_for (READY2DIE);
00136                 };
00137 
<a name="l00138"></a><a class="code" href="classstxxl_1_1ufs__request__base.html#a1">00138</a>                 <span class="keywordtype">void</span> wait ()
00139                 {
00140                         START_COUNT_WAIT_TIME 
00141                         
00142 <span class="preprocessor">                        #ifdef NO_OVERLAPPING</span>
00143 <span class="preprocessor"></span>                        enqueue();
00144 <span class="preprocessor">                        #endif</span>
00145 <span class="preprocessor"></span>                        
00146                         _state.wait_for (READY2DIE);
00147                         
00148                         END_COUNT_WAIT_TIME
00149                 };
<a name="l00150"></a><a class="code" href="classstxxl_1_1ufs__request__base.html#a2">00150</a>                 <span class="keywordtype">bool</span> poll()
00151                 {
00152 <span class="preprocessor">                        #ifdef NO_OVERLAPPING</span>
00153 <span class="preprocessor"></span>                        <span class="comment">/*if(_state () &lt; DONE)*/</span> wait();
00154 <span class="preprocessor">                        #endif</span>
00155 <span class="preprocessor"></span>                        
00156                         <span class="keywordflow">return</span> (_state () &gt;= DONE);
00157                 };
<a name="l00158"></a><a class="code" href="classstxxl_1_1ufs__request__base.html#a3">00158</a>                 <span class="keyword">const</span> <span class="keywordtype">char</span> *io_type ()
00159                 {
00160                         <span class="keywordflow">return</span> <span class="stringliteral">"ufs_base"</span>;
00161                 };
00162         };
00163 
00164         ufs_file_base::ufs_file_base (
00165                         <span class="keyword">const</span> std::string &amp; filename, 
00166                         <span class="keywordtype">int</span> mode, 
00167                         <span class="keywordtype">int</span> disk): file (disk), file_des (-1)
00168         {
00169                 <span class="keywordtype">int</span> fmode = 0;
00170                 <span class="keywordflow">if</span> (mode &amp; DIRECT)
00171                         fmode |= O_SYNC | O_RSYNC | O_DSYNC | O_DIRECT;
00172                 <span class="keywordflow">if</span> (mode &amp; RDONLY)
00173                         fmode |= O_RDONLY;
00174                 <span class="keywordflow">if</span> (mode &amp; WRONLY)
00175                         fmode |= O_WRONLY;
00176                 <span class="keywordflow">if</span> (mode &amp; RDWR)
00177                         fmode |= O_RDWR;
00178                 <span class="keywordflow">if</span> (mode &amp; CREAT)
00179                         fmode |= O_CREAT;
00180                 <span class="keywordflow">if</span> (mode &amp; TRUNC)
00181                         fmode |= O_TRUNC;
00182 
00183 
00184                 stxxl_ifcheck ((file_des =::open (filename.c_str(), fmode,
00185                                       S_IREAD | S_IWRITE | S_IRGRP | S_IWGRP)));
00186         };
00187         ufs_file_base::~ufs_file_base ()
00188         {
00189                 <span class="keywordtype">int</span> res =::close (file_des);
00190 
00191                 <span class="comment">// if successful, reset file descriptor</span>
00192                 <span class="keywordflow">if</span> (res &gt;= 0)
00193                         file_des = -1;
00194                 <span class="keywordflow">else</span>
00195                         stxxl_function_error;
00196         };
<a name="l00197"></a><a class="code" href="classstxxl_1_1ufs__file__base.html#a13">00197</a>         off_t ufs_file_base::size ()
00198         {
00199                 <span class="keyword">struct </span>stat st;
00200                 stxxl_ifcheck (fstat (file_des, &amp;st));
00201                 <span class="keywordflow">return</span> st.st_size;
00202         };
<a name="l00203"></a><a class="code" href="classstxxl_1_1ufs__file__base.html#a14">00203</a>         <span class="keywordtype">void</span> ufs_file_base::set_size (off_t newsize)
00204         {
00205                 <span class="keywordflow">if</span> (newsize &gt; <a class="code" href="group__fileimpl.html#a13">size</a> ())
00206                 {
00207                         stxxl_ifcheck (::lseek (file_des, newsize - 1,SEEK_SET));
00208                 }
00209         };
00210   
00212 
00213 __STXXL_END_NAMESPACE
00214 
00215 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Nov 26 10:56:55 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
