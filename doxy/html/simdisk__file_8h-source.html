<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: simdisk_file.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>simdisk_file.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef SIMDISK_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define SIMDISK_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            simdisk_file.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Sat Aug 24 23:55:03 2002</span>
00008 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 
00013 <span class="preprocessor">#include "ufs_file.h"</span>
00014 <span class="preprocessor">#include &lt;math.h&gt;</span>
00015 
00016 <span class="keyword">namespace </span>stxxl
00017 {
00020   
00021 <span class="preprocessor">        #define AVERAGE_SPEED (15*1024*1024)    </span>
00022 <span class="preprocessor"></span>                
00023         <span class="keyword">class </span>DiskGeometry
00024         {
00025                 <span class="keyword">struct </span>Zone
00026                 {
00027                         <span class="comment">// manufactuted data</span>
00028                         <span class="comment">//    int last_cyl;</span>
00029                         <span class="comment">//    int sect_per_track;</span>
00030                         <span class="comment">// derived data</span>
00031                         <span class="keywordtype">int</span> first_sector;
00032                         <span class="keywordtype">int</span> sectors;
00033                         <span class="keywordtype">double</span> sustained_data_rate;     <span class="comment">// in Mb/s</span>
00034                           Zone (<span class="keywordtype">int</span>
00035                                 _first_sector):first_sector (_first_sector)
00036                         {
00037                         };      <span class="comment">// constructor for zone search</span>
00038 
00039                           Zone (        <span class="comment">//int _last_cyl, </span>
00040                                        <span class="comment">//int _sect_per_track,</span>
00041                                        <span class="keywordtype">int</span> _first_sector,
00042                                        <span class="keywordtype">int</span> _sectors, <span class="keywordtype">double</span> _rate):
00043                                 <span class="comment">//last_cyl(_last_cyl),</span>
00044                                 <span class="comment">//       sect_per_track(_sect_per_track) ,</span>
00045                          
00046                                 first_sector (_first_sector),
00047                                 sectors (_sectors),
00048                                 sustained_data_rate (_rate)
00049                         {
00050                         };
00051                 };
00052                 <span class="keyword">struct </span>ZoneCmp
00053                 {
00054                         <span class="keywordtype">bool</span> operator  () (<span class="keyword">const</span> Zone &amp; a, <span class="keyword">const</span> Zone &amp; b)<span class="keyword"> const</span>
00055 <span class="keyword">                        </span>{
00056                                 <span class="keywordflow">return</span> a.first_sector &lt; b.first_sector;
00057                         };
00058                 };
00059 
00060               <span class="keyword">protected</span>:
00061                 <span class="keywordtype">int</span> nsurfaces;
00062                 <span class="keywordtype">int</span> bytes_per_sector;
00063                 <span class="keywordtype">double</span> cmd_ovh; <span class="comment">// in s</span>
00064                 <span class="keywordtype">double</span> seek_time;       <span class="comment">// in s</span>
00065                 <span class="keywordtype">double</span> rot_latency;     <span class="comment">// in s</span>
00066                 <span class="keywordtype">double</span> head_switch_time;        <span class="comment">// in s</span>
00067                 <span class="keywordtype">double</span> cyl_switch_time; <span class="comment">// in s</span>
00068                 <span class="keywordtype">double</span> revolution_time; <span class="comment">// in s</span>
00069                 <span class="keywordtype">double</span> interface_speed; <span class="comment">// in byte/s</span>
00070                 std::set &lt; Zone, ZoneCmp &gt; zones;
00071 
00072                 <span class="keywordtype">void</span> add_zone (<span class="keywordtype">int</span> &amp;first_cyl, <span class="keywordtype">int</span> last_cyl,
00073                                <span class="keywordtype">int</span> sec_per_track, <span class="keywordtype">int</span> &amp;first_sect)
00074                 {
00075                         <span class="keywordtype">double</span> rate =
00076                                 nsurfaces * sec_per_track * bytes_per_sector /
00077                                 ((nsurfaces - 1) * head_switch_time +
00078                                  cyl_switch_time +
00079                                  nsurfaces * revolution_time);
00080                         <span class="keywordtype">int</span> sectors =
00081                                 (last_cyl - first_cyl +
00082                                  1) * nsurfaces * sec_per_track;
00083                         zones.insert (Zone (first_sect, sectors, rate));
00084                         first_sect += sectors;
00085                         first_cyl = last_cyl + 1;
00086                 };
00087               <span class="keyword">public</span>:
00088                 DiskGeometry ()
00089                 {
00090                 };
00091                 <span class="keywordtype">double</span> get_delay (off_t offset, size_t size)    <span class="comment">// returns delay in s</span>
00092                 {
00093                         <span class="comment">/*</span>
00094 <span class="comment">                          </span>
00095 <span class="comment">                        int first_sect = offset / bytes_per_sector;</span>
00096 <span class="comment">                        int last_sect = (offset + size) / bytes_per_sector;</span>
00097 <span class="comment">                        int sectors = size / bytes_per_sector;</span>
00098 <span class="comment">                        double delay =</span>
00099 <span class="comment">                                cmd_ovh + seek_time + rot_latency +</span>
00100 <span class="comment">                                double (bytes_per_sector) /</span>
00101 <span class="comment">                                double (interface_speed);</span>
00102 <span class="comment">                        </span>
00103 <span class="comment">                        std::set &lt; Zone, ZoneCmp &gt;::iterator zone =</span>
00104 <span class="comment">                                zones.lower_bound (first_sect);</span>
00105 <span class="comment">                        // cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; " " &lt;&lt; (*zone).first_sector &lt;&lt; endl;</span>
00106 <span class="comment">                        while (1)</span>
00107 <span class="comment">                        {</span>
00108 <span class="comment">                                int from_this_zone =</span>
00109 <span class="comment">                                        last_sect - ((*zone).first_sector +</span>
00110 <span class="comment">                                                     (*zone).sectors);</span>
00111 <span class="comment">                                if (from_this_zone &lt;= 0)</span>
00112 <span class="comment">                                {</span>
00113 <span class="comment">                                        delay += sectors * bytes_per_sector /</span>
00114 <span class="comment">                                                ((*zone).sustained_data_rate);</span>
00115 <span class="comment">                                        break;</span>
00116 <span class="comment">                                }</span>
00117 <span class="comment">                                else</span>
00118 <span class="comment">                                {</span>
00119 <span class="comment">                                        delay += from_this_zone *</span>
00120 <span class="comment">                                                bytes_per_sector /</span>
00121 <span class="comment">                                                ((*zone).sustained_data_rate);</span>
00122 <span class="comment">                                        zone++;</span>
00123 <span class="comment">                                        stxxl_nassert (zone == zones.end ());</span>
00124 <span class="comment">                                        sectors -= from_this_zone;</span>
00125 <span class="comment">                                }</span>
00126 <span class="comment">                        }  </span>
00127 <span class="comment"></span>
00128 <span class="comment">                        return delay;</span>
00129 <span class="comment">                        </span>
00130 <span class="comment">                        */</span>
00131                         <span class="keywordflow">return</span>  double(size)/double(AVERAGE_SPEED);
00132                 };
00133                 ~DiskGeometry ()
00134                 {
00135                 };
00136         };
00137 
00138 
00139         <span class="keyword">class </span>IC35L080AVVA07:<span class="keyword">public</span> DiskGeometry        <span class="comment">// IBM series 120GXP</span>
00140         {
00141          <span class="keyword">public</span>:
00142                 IC35L080AVVA07 ()
00143                 {
00144                         std::cout &lt;&lt; <span class="stringliteral">"Creating IBM 120GXP IC35L080AVVA07"</span> &lt;&lt;
00145                                 std::endl;
00146 
00147                         nsurfaces = 4;
00148                         bytes_per_sector = 512;
00149                         cmd_ovh = 0.0002;       <span class="comment">// in s</span>
00150                         seek_time = 0.0082;     <span class="comment">// in s</span>
00151                         rot_latency = 0.00417;  <span class="comment">// in s</span>
00152                         head_switch_time = 0.0015;      <span class="comment">// in s</span>
00153                         cyl_switch_time = 0.002;        <span class="comment">// in s</span>
00154                         revolution_time = 0.0083;       <span class="comment">// in s</span>
00155                         interface_speed = 100000000;    <span class="comment">// in byte/s</span>
00156 
00157                         <span class="keywordtype">int</span> first_sect = 0;
00158                         <span class="keywordtype">int</span> last_cyl = 0;
00159                           add_zone (last_cyl, 1938, 928, first_sect);
00160                           add_zone (last_cyl, 3756, 921, first_sect);
00161                           add_zone (last_cyl, 5564, 896, first_sect);
00162                           add_zone (last_cyl, 7687, 896, first_sect);
00163                           add_zone (last_cyl, 9526, 888, first_sect);
00164                           add_zone (last_cyl, 11334, 883, first_sect);
00165                           add_zone (last_cyl, 13331, 864, first_sect);
00166                           add_zone (last_cyl, 15128, 850, first_sect);
00167                           add_zone (last_cyl, 16925, 840, first_sect);
00168                           add_zone (last_cyl, 18922, 822, first_sect);
00169                           add_zone (last_cyl, 20709, 806, first_sect);
00170                           add_zone (last_cyl, 22601, 792, first_sect);
00171                           add_zone (last_cyl, 24138, 787, first_sect);
00172                           add_zone (last_cyl, 26024, 768, first_sect);
00173                           add_zone (last_cyl, 27652, 752, first_sect);
00174                           add_zone (last_cyl, 29501, 740, first_sect);
00175                           add_zone (last_cyl, 31234, 725, first_sect);
00176                           add_zone (last_cyl, 33009, 698, first_sect);
00177                           add_zone (last_cyl, 34784, 691, first_sect);
00178                           add_zone (last_cyl, 36609, 672, first_sect);
00179                           add_zone (last_cyl, 38374, 648, first_sect);
00180                           add_zone (last_cyl, 40139, 630, first_sect);
00181                           add_zone (last_cyl, 41904, 614, first_sect);
00182                           add_zone (last_cyl, 43519, 595, first_sect);
00183                           add_zone (last_cyl, 45250, 576, first_sect);
00184                           add_zone (last_cyl, 47004, 552, first_sect);
00185                           add_zone (last_cyl, 48758, 533, first_sect);
00186                           add_zone (last_cyl, 50491, 512, first_sect);
00187                           add_zone (last_cyl, 52256, 493, first_sect);
00188                           add_zone (last_cyl, 54010, 471, first_sect);
00189                           add_zone (last_cyl, 55571, 448, first_sect);
00190 
00191                         <span class="comment">/*</span>
00192 <span class="comment">                         * set&lt;Zone,ZoneCmp&gt;::iterator it=zones.begin();</span>
00193 <span class="comment">                         * int i=0;</span>
00194 <span class="comment">                         * for(;it!=zones.end();it++,i++)</span>
00195 <span class="comment">                         * {</span>
00196 <span class="comment">                         * //const int block_size = 128*3*1024* 4; // one cylinder</span>
00197 <span class="comment">                         * </span>
00198 <span class="comment">                         * cout &lt;&lt; "Zone " &lt;&lt; i &lt;&lt; " first sector: " &lt;&lt; (*it).first_sector;</span>
00199 <span class="comment">                         * cout &lt;&lt; " sectors: " &lt;&lt; (*it).sectors &lt;&lt; " sustained rate: " ;</span>
00200 <span class="comment">                         * cout &lt;&lt; (*it).sustained_data_rate/1000000 &lt;&lt; " Mb/s"  &lt;&lt; endl;</span>
00201 <span class="comment">                         * </span>
00202 <span class="comment">                         * }</span>
00203 <span class="comment">                         * </span>
00204 <span class="comment">                         * </span>
00205 <span class="comment">                         * cout &lt;&lt; "Last sector     : " &lt;&lt; first_sect &lt;&lt;endl;</span>
00206 <span class="comment">                         * cout &lt;&lt; "Approx. capacity: " &lt;&lt; (first_sect/1000000)*bytes_per_sector &lt;&lt; " Mb" &lt;&lt; endl;</span>
00207 <span class="comment">                         */</span>
00208 
00209                           std::cout &lt;&lt; <span class="stringliteral">"Transfer 16 Mb from zone 0 : "</span> &lt;&lt;
00210                                 get_delay (0,
00211                                            16 * 1024 *
00212                                            1024) &lt;&lt; <span class="stringliteral">" s"</span> &lt;&lt; std::endl;
00213                           std::cout &lt;&lt; <span class="stringliteral">"Transfer 16 Mb from zone 30: "</span> &lt;&lt;
00214                                 get_delay (off_t (158204036) *
00215                                            off_t (bytes_per_sector),
00216                                            16 * 1024 *
00217                                            1024) &lt;&lt; <span class="stringliteral">" s"</span> &lt;&lt; std::endl;
00218                 };
00219         };
00220 
00221         <span class="keyword">class </span>sim_disk_request;
00222 
<a name="l00225"></a><a class="code" href="classstxxl_1_1sim__disk__file.html">00225</a>         <span class="keyword">class </span><a class="code" href="classstxxl_1_1sim__disk__file.html">sim_disk_file</a>:<span class="keyword">public</span> <a class="code" href="classstxxl_1_1ufs__file__base.html">ufs_file_base</a>, <span class="keyword">public</span> IC35L080AVVA07
00226         {
00227         <span class="keyword">public</span>:
<a name="l00233"></a><a class="code" href="classstxxl_1_1sim__disk__file.html#a0">00233</a>                 <a class="code" href="classstxxl_1_1sim__disk__file.html#a0">sim_disk_file</a> (<span class="keyword">const</span> std::string &amp; filename, <span class="keywordtype">int</span> mode,<span class="keywordtype">int</span> disk):<a class="code" href="classstxxl_1_1ufs__file__base.html">ufs_file_base</a> (filename, mode, disk)
00234                 {
00235                         std::cout &lt;&lt; <span class="stringliteral">"Please, make sure that '"</span> &lt;&lt; filename &lt;&lt;
00236                                 <span class="stringliteral">"' is resided on swap memory partition!"</span> &lt;&lt;
00237                                 std::endl;
00238                 };
00239                 <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> <a class="code" href="group__fileimpl.html#a6">aread</a>(<span class="keywordtype">void</span> *buffer, off_t pos, size_t bytes,
00240                             <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl);
00241                 <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> <a class="code" href="group__fileimpl.html#a7">awrite</a>(<span class="keywordtype">void</span> *buffer, off_t pos, size_t bytes,
00242                             <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl);
00243                 <span class="keywordtype">void</span> <a class="code" href="group__fileimpl.html#a4">set_size</a> (off_t newsize);
00244         };
00245 
<a name="l00246"></a><a class="code" href="classstxxl_1_1sim__disk__file.html#a4">00246</a>         <span class="keywordtype">void</span> sim_disk_file::set_size (off_t newsize)
00247     {
00248          <span class="keywordflow">if</span> (newsize &gt; <a class="code" href="group__fileimpl.html#a13">size</a> ())
00249          {
00250              stxxl_ifcheck (::lseek (file_des, newsize - 1,
00251                             SEEK_SET));
00252              stxxl_ifcheck(::write(file_des,<span class="stringliteral">""</span>,1));
00253          }
00254     };
00255 
<a name="l00257"></a><a class="code" href="classstxxl_1_1sim__disk__request.html">00257</a>         <span class="keyword">class </span><a class="code" href="classstxxl_1_1sim__disk__request.html">sim_disk_request</a>:<span class="keyword">public</span> <a class="code" href="classstxxl_1_1ufs__request__base.html">ufs_request_base</a>
00258         {
00259                 <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classstxxl_1_1sim__disk__file.html">sim_disk_file</a>;
00260         <span class="keyword">protected</span>:
00261                   <a class="code" href="classstxxl_1_1sim__disk__request.html">sim_disk_request</a> (<a class="code" href="classstxxl_1_1sim__disk__file.html">sim_disk_file</a> * f, <span class="keywordtype">void</span> *buf, off_t off,
00262                                     size_t b, request_type t,
00263                                     <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl):
00264                                 <a class="code" href="classstxxl_1_1ufs__request__base.html">ufs_request_base</a> (f,
00265                                                                                          buf,
00266                                                                                          off,
00267                                                                                          b,
00268                                                                                          t,
00269                                                                                          on_cmpl)
00270                 {
00271                 };
00272                 <span class="keywordtype">void</span> serve ();
00273         <span class="keyword">public</span>:
<a name="l00274"></a><a class="code" href="classstxxl_1_1sim__disk__request.html#a0">00274</a>                 <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classstxxl_1_1sim__disk__request.html#a0">io_type</a> ()
00275                 {
00276                         <span class="keywordflow">return</span> <span class="stringliteral">"simdisk"</span>;
00277                 };
00278   <span class="keyword">private</span>:
00279     <span class="comment">// Following methods are declared but not implemented </span>
00280     <span class="comment">// intentionnaly to forbid their usage</span>
00281                 <a class="code" href="classstxxl_1_1sim__disk__request.html">sim_disk_request</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1sim__disk__request.html">sim_disk_request</a> &amp;);
00282     <a class="code" href="classstxxl_1_1sim__disk__request.html">sim_disk_request</a> &amp; operator=(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1sim__disk__request.html">sim_disk_request</a> &amp;);
00283                 <a class="code" href="classstxxl_1_1sim__disk__request.html">sim_disk_request</a>();
00284         };
00285 
00286         <span class="keywordtype">void</span> sim_disk_request::serve ()
00287         {
00288                 <span class="comment">//      file-&gt;set_size(offset+bytes);</span>
00289                 <span class="keywordtype">double</span> op_start = stxxl_timestamp();
00290                                 
00291                 <span class="keywordtype">void</span> *mem =
00292                         mmap (NULL, bytes, PROT_READ | PROT_WRITE, MAP_SHARED,file-&gt;get_file_des (), offset);
00293                 <span class="keywordflow">if</span> (mem == MAP_FAILED)
00294                 {
00295                         STXXL_ERRMSG( <span class="stringliteral">"Mapping failed."</span> )
00296                         STXXL_ERRMSG( <span class="stringliteral">"Page size: "</span> &lt;&lt; sysconf (_SC_PAGESIZE)
00297                                 &lt;&lt; <span class="stringliteral">" offset modulo page size"</span> &lt;&lt; (offset % sysconf(_SC_PAGESIZE)) )
00298                         abort ();
00299                 }
00300                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mem == 0)
00301                 {
00302                         stxxl_function_error
00303                 }
00304                 <span class="keywordflow">else</span>
00305                 {
00306                         <span class="keywordflow">if</span> (type == READ)
00307                         {
00308                                 stxxl_ifcheck (memcpy (buffer, mem, bytes))
00309                                 <span class="keywordflow">else</span>
00310                                 stxxl_ifcheck (munmap ((<span class="keywordtype">char</span> *) mem, bytes))}
00311                         <span class="keywordflow">else</span>
00312                         {
00313                                 stxxl_ifcheck (memcpy (mem, buffer, bytes))
00314                                 <span class="keywordflow">else</span>
00315                                 stxxl_ifcheck (munmap ((<span class="keywordtype">char</span> *) mem, bytes))}
00316                         }
00317 
00318                 <span class="keywordtype">double</span> delay =
00319                         (static_cast &lt;sim_disk_file * &gt;(file))-&gt;get_delay (offset, bytes);
00320                 
00321                 delay = delay - stxxl_timestamp() + op_start;
00322                 
00323                 assert( delay &gt; 0.0 );
00324                 
00325                 <span class="keywordtype">int</span> seconds_to_wait = static_cast &lt; int &gt;(floor (delay));
00326                 <span class="keywordflow">if</span> (seconds_to_wait)
00327                         sleep (seconds_to_wait);
00328 
00329                 usleep ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) ((delay - seconds_to_wait) * 1000000.));
00330 
00331                 _state.set_to (DONE);
00332 
00333                 waiters_mutex.lock ();
00334                 <span class="comment">// &lt;&lt; notification &gt;&gt;</span>
00335                 <span class="keywordflow">for</span> (std::set &lt; onoff_switch * &gt;::iterator i =
00336                      waiters.begin (); i != waiters.end (); i++)
00337                         (*i)-&gt;on ();
00338                 waiters_mutex.unlock ();
00339 
00340                 completed ();
00341                 _state.set_to (READY2DIE);
00342         }
00343 
<a name="l00344"></a><a class="code" href="classstxxl_1_1sim__disk__file.html#a6">00344</a>         <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> sim_disk_file::aread (<span class="keywordtype">void</span> *buffer, off_t pos, size_t bytes,
00345                                    <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl)
00346         {
00347                 <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> req = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1sim__disk__request.html">sim_disk_request</a> (<span class="keyword">this</span>, buffer, pos, bytes,
00348                                             request::READ, on_cmpl);
00349                 <span class="keywordflow">if</span> (!req.<a class="code" href="classstxxl_1_1request__ptr.html#a7">get</a>())
00350                         stxxl_function_error;
00351                 
00352 <span class="preprocessor">                #ifndef NO_OVERLAPPING</span>
00353 <span class="preprocessor"></span>                disk_queues::get_instance ()-&gt;add_readreq(req,<a class="code" href="classstxxl_1_1file.html#a5">get_id</a>());
00354 <span class="preprocessor">                #endif</span>
00355 <span class="preprocessor"></span>    
00356     <span class="keywordflow">return</span> req;
00357         };
<a name="l00358"></a><a class="code" href="classstxxl_1_1sim__disk__file.html#a7">00358</a>         <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> sim_disk_file::awrite (
00359                                                 <span class="keywordtype">void</span> *buffer, off_t pos, size_t bytes,
00360                                     <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl)
00361         {
00362                 <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> req = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1sim__disk__request.html">sim_disk_request</a> (<span class="keyword">this</span>, buffer, pos, bytes,
00363                                             request::WRITE, on_cmpl);
00364     
00365                 <span class="keywordflow">if</span> (!req.<a class="code" href="classstxxl_1_1request__ptr.html#a7">get</a>())
00366                         stxxl_function_error;
00367                 
00368 <span class="preprocessor">                #ifndef NO_OVERLAPPING</span>
00369 <span class="preprocessor"></span>                disk_queues::get_instance ()-&gt;add_writereq(req,<a class="code" href="classstxxl_1_1file.html#a5">get_id</a>());
00370 <span class="preprocessor">                #endif</span>
00371 <span class="preprocessor"></span>                <span class="keywordflow">return</span> req;
00372         };
00373   
00375 
00376 }
00377 
00378 
00379 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Nov 21 15:28:11 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
