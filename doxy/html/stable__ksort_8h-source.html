<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>stable_ksort.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>stable_ksort.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef STABLE_KSORT_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define STABLE_KSORT_HEADER</span>
00003 <span class="preprocessor"></span><span class="comment">/***************************************************************************</span>
00004 <span class="comment"> *            stable_ksort.h</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Tue Feb  4 16:45:46 2003</span>
00007 <span class="comment"> *  Copyright  2003  Roman Dementiev</span>
00008 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00009 <span class="comment"> ****************************************************************************/</span>
00010 
00011 
00012 <span class="comment">// it is a first try: distribution sort without sampling</span>
00013 <span class="comment">// I rework the stable_ksort when I would have a time</span>
00014 
00015 <span class="preprocessor">#include &lt;math.h&gt;</span>
00016 <span class="preprocessor">#include "../mng/mng.h"</span>
00017 <span class="preprocessor">#include "../common/utils.h"</span>
00018 <span class="preprocessor">#include "../mng/buf_istream.h"</span>
00019 <span class="preprocessor">#include "../mng/buf_ostream.h"</span>
00020 <span class="preprocessor">#include "../common/simple_vector.h"</span>
00021 <span class="preprocessor">#include "intksort.h"</span>
00022 
00023 __STXXL_BEGIN_NAMESPACE
00024 
00027 
00029 <span class="keyword">namespace </span>stable_ksort_local
00030 {
00031   <span class="keyword">template</span> &lt;<span class="keyword">class</span> type_,<span class="keyword">class</span> type_key&gt;
00032   <span class="keywordtype">void</span> classify_block(type_ * begin,type_ * end,type_key * &amp; out,<span class="keywordtype">int</span> * bucket,<span class="keywordtype">unsigned</span> offset, <span class="keywordtype">unsigned</span> shift)
00033   {
00034     <span class="keywordflow">for</span> (type_ * p = begin;p&lt;end; p++,out++)    <span class="comment">// count &amp; create references</span>
00035     {
00036       out-&gt;ptr = p;
00037       <span class="keyword">typename</span> type_::key_type key = p-&gt;key();
00038       <span class="keywordtype">int</span> ibucket = (key - offset) &gt;&gt; shift;
00039       out-&gt;key = key;
00040       bucket[ibucket]++;
00041     }
00042   }
00043 
00044         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00045         <span class="keyword">struct </span>type_key
00046         {
00047                 <span class="keyword">typedef</span> <span class="keyword">typename</span> type::key_type key_type;
00048                 key_type key;
00049                 type * ptr;
00050                 
00051                 type_key() {};
00052                 type_key(key_type k, type * p):key (k), ptr (p)
00053                 {
00054                 };
00055         };
00056         
00057         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00058         <span class="keywordtype">bool</span> operator  &lt; (const type_key&lt;type&gt; &amp; a, <span class="keyword">const</span> type_key&lt;type&gt; &amp; b)
00059         {
00060                         <span class="keywordflow">return</span> a.key &lt; b.key;
00061         }
00062         
00063         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00064         <span class="keywordtype">bool</span> operator  &gt; (<span class="keyword">const</span> type_key&lt;type&gt; &amp; a, <span class="keyword">const</span> type_key&lt;type&gt; &amp; b)
00065         {
00066                         <span class="keywordflow">return</span> a.key &gt; b.key;
00067         }
00068         
00069 
00070         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIDType_,<span class="keyword">typename</span> AllocStrategy_&gt;
00071         <span class="keyword">class </span>bid_sequence
00072         {
00073         <span class="keyword">public</span>:
00074                 <span class="keyword">typedef</span> BIDType_ bid_type;
00075                 <span class="keyword">typedef</span> bid_type &amp; reference;
00076                 <span class="keyword">typedef</span> AllocStrategy_ alloc_strategy;
00077                 <span class="keyword">typedef</span> <span class="keyword">typename</span> simple_vector&lt;bid_type&gt;::size_type size_type;
00078                 <span class="keyword">typedef</span> <span class="keyword">typename</span> simple_vector&lt;bid_type&gt;::iterator iterator;
00079         <span class="keyword">protected</span>:
00080                 simple_vector&lt;bid_type&gt; * bids;
00081                 alloc_strategy alloc_strategy_;
00082                 
00083                 bid_sequence() {}
00084         <span class="keyword">public</span>:
00085                 bid_sequence(size_type size_)
00086                 {
00087                         bids = <span class="keyword">new</span> simple_vector&lt;bid_type&gt;(size_);
00088                         block_manager * mng = block_manager::get_instance();
00089                         mng-&gt;new_blocks(alloc_strategy_,bids-&gt;begin(),bids-&gt;end());
00090                 }
00091                 reference operator [] (size_type i)
00092                 {
00093                         size_type size_ = size(); <span class="comment">// cache size in a register</span>
00094                         <span class="keywordflow">if</span>(i &lt; size_)
00095                                 <span class="keywordflow">return</span> *(bids-&gt;begin() + i);
00096                         
00097                         block_manager * mng = block_manager::get_instance();
00098                         simple_vector&lt;bid_type&gt; * larger_bids = <span class="keyword">new</span> simple_vector&lt;bid_type&gt;((i+1)*2);
00099                         std::copy(bids-&gt;begin(),bids-&gt;end(),larger_bids-&gt;begin());
00100                         mng-&gt;new_blocks(alloc_strategy_,larger_bids-&gt;begin() + size_,larger_bids-&gt;end());
00101                         <span class="keyword">delete</span> bids;
00102                         bids = larger_bids;
00103                         <span class="keywordflow">return</span> *(larger_bids-&gt;begin() + i);
00104                 }
00105                 size_type size() { <span class="keywordflow">return</span> bids-&gt;size();} 
00106                 iterator begin() { <span class="keywordflow">return</span> bids-&gt;begin(); }
00107                 ~bid_sequence()
00108                 {
00109                         block_manager::get_instance()-&gt;delete_blocks(bids-&gt;begin(),bids-&gt;end());
00110                         <span class="keyword">delete</span> bids;
00111                 }
00112         };
00113 
00114         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExtIterator_&gt;
00115         <span class="keywordtype">void</span> distribute(
00116                 bid_sequence&lt;<span class="keyword">typename</span> ExtIterator_::vector_type::block_type::bid_type,
00117                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy&gt; * bucket_bids,
00118                 int64 * bucket_sizes,
00119                 <span class="keyword">const</span> <span class="keywordtype">int</span> nbuckets,
00120                 <span class="keyword">const</span> <span class="keywordtype">int</span> lognbuckets,
00121                 ExtIterator_ first,
00122                 ExtIterator_ last,
00123                 <span class="keyword">const</span> <span class="keywordtype">int</span> nread_buffers,
00124                 <span class="keyword">const</span> <span class="keywordtype">int</span> nwrite_buffers)
00125         {
00126                 <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::vector_type::value_type value_type;
00127                 <span class="keyword">typedef</span> <span class="keyword">typename</span> value_type::key_type key_type;
00128                 <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::block_type block_type;
00129                 <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00130                 <span class="keyword">typedef</span> buf_istream&lt;<span class="keyword">typename</span> ExtIterator_::block_type,
00131                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator&gt; buf_istream_type;
00132         
00133                 <span class="keywordtype">int</span> i=0;
00134                 
00135                 buf_istream_type in(first.bid(),last.bid() + ((first.block_offset())?1:0),
00136                         nread_buffers);
00137                 
00138                 buffered_writer&lt;block_type&gt; out(
00139                         nbuckets + nwrite_buffers,
00140                         nwrite_buffers);
00141                 
00142                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * bucket_block_offsets = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[nbuckets];
00143                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * bucket_iblock = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[nbuckets];
00144                 block_type ** bucket_blocks = <span class="keyword">new</span> block_type *[nbuckets];
00145                 
00146                 std::fill(bucket_sizes,bucket_sizes + nbuckets,0);
00147                 std::fill(bucket_iblock,bucket_iblock + nbuckets,0);
00148                 std::fill(bucket_block_offsets,bucket_block_offsets + nbuckets,0);
00149                 
00150                 <span class="keywordflow">for</span>(i= 0; i&lt; nbuckets; i++)
00151                         bucket_blocks[i] = out.get_free_block();
00152                 
00153                 ExtIterator_ cur = first - first.block_offset();
00154                 
00155                 <span class="comment">// skip part of the block before first untouched</span>
00156                 <span class="keywordflow">for</span>( ;cur != first;cur++)
00157                         in++;
00158                 
00159                 <span class="keyword">const</span> <span class="keywordtype">int</span> shift = <span class="keyword">sizeof</span>(key_type)*8 - lognbuckets;
00160                 <span class="comment">// search in the the range [_begin,_end)</span>
00161                 <span class="keywordflow">for</span>( ;cur != last;cur++)
00162                 {
00163                         key_type cur_key = in.current().key();
00164                         <span class="keywordtype">int</span> ibucket = cur_key &gt;&gt; shift;
00165                         
00166                         <span class="keywordtype">int</span> block_offset = bucket_block_offsets[ibucket];
00167                         in &gt;&gt; (bucket_blocks[ibucket]-&gt;elem[block_offset++]);
00168                         <span class="keywordflow">if</span>(block_offset == block_type::size)
00169                         {
00170                                 block_offset = 0;
00171                                 <span class="keywordtype">int</span> iblock = bucket_iblock[ibucket]++;
00172                                 bucket_blocks[ibucket] = out.write(bucket_blocks[ibucket],bucket_bids[ibucket][iblock]);
00173                         }
00174                         bucket_block_offsets[ibucket] = block_offset;
00175                 }
00176                 <span class="keywordflow">for</span>(i = 0 ;i&lt;nbuckets;i++)
00177                 {
00178                         <span class="keywordflow">if</span>(bucket_block_offsets[i])
00179                         {
00180                                 out.write(bucket_blocks[i],bucket_bids[i][bucket_iblock[i]]);
00181                         }
00182                         bucket_sizes[i] = int64(block_type::size) * bucket_iblock[i] + 
00183                                 bucket_block_offsets[i];
00184                         STXXL_MSG(<span class="stringliteral">"Bucket "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" has size "</span>&lt;&lt;bucket_sizes[i]&lt;&lt;
00185                                 <span class="stringliteral">", estimated size: "</span>&lt;&lt;((last-first)/int64(nbuckets)))
00186                 }
00187                 
00188                 
00189                 <span class="keyword">delete</span> [] bucket_blocks;
00190                 <span class="keyword">delete</span> [] bucket_block_offsets;
00191                 <span class="keyword">delete</span> [] bucket_iblock;
00192         }
00193 };
00194 
00195 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExtIterator_&gt;
00196 <span class="keywordtype">void</span> stable_ksort(ExtIterator_ first, ExtIterator_ last,<span class="keywordtype">unsigned</span> M)
00197 {
00198         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::vector_type::value_type value_type;
00199         <span class="keyword">typedef</span> <span class="keyword">typename</span> value_type::key_type key_type;
00200         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::block_type block_type;
00201         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00202         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy alloc_strategy;
00203         <span class="keyword">typedef</span> stable_ksort_local::bid_sequence&lt;bid_type,alloc_strategy&gt; bucket_bids_type;
00204         <span class="keyword">typedef</span> stable_ksort_local::type_key&lt;value_type&gt; type_key_;
00205         
00206         first.flush(); <span class="comment">// flush container</span>
00207         
00208 <span class="preprocessor">#ifdef STXXL_IO_STATS</span>
00209 <span class="preprocessor"></span>        stats *iostats = stats::get_instance ();
00210         iostats-&gt;reset ();
00211 <span class="preprocessor">#endif</span>
00212 <span class="preprocessor"></span>        
00213         reset_io_wait_time();
00214         
00215 
00216         <span class="keywordtype">double</span> begin = stxxl_timestamp();
00217         (void)(begin);
00218   
00219   
00220         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;
00221         config * cfg = config::get_instance();
00222         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = M/block_type::raw_size;
00223         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> write_buffers_multiple = 2;
00224         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> read_buffers_multiple = 2;
00225         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ndisks = cfg-&gt;ndisks();
00226         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nmaxbuckets = m - (write_buffers_multiple + read_buffers_multiple)*ndisks;
00227         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lognbuckets = static_cast&lt;unsigned&gt;(log2(nmaxbuckets));
00228         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbuckets = 1&lt;&lt;lognbuckets;
00229         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> est_bucket_size = div_and_round_up((last-first)/int64(nbuckets),
00230                 int64(block_type::size)); <span class="comment">//in blocks</span>
00231 
00232         STXXL_MSG(<span class="stringliteral">"Elements to sort: "</span> &lt;&lt; (last - first))
00233         STXXL_MSG(<span class="stringliteral">"Number of buckets has to be reduced from "</span>&lt;&lt;nmaxbuckets&lt;&lt;<span class="stringliteral">" to "</span>&lt;&lt; nbuckets)
00234         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread_buffers = (m - nbuckets)*read_buffers_multiple/(read_buffers_multiple+write_buffers_multiple);
00235         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nwrite_buffers = (m - nbuckets)*write_buffers_multiple/(read_buffers_multiple+write_buffers_multiple);
00236 
00237         STXXL_MSG(<span class="stringliteral">"Read buffers in distribution phase: "</span>&lt;&lt;nread_buffers)
00238         STXXL_MSG(<span class="stringliteral">"Write buffers in distribution phase: "</span>&lt;&lt;nwrite_buffers)
00239 
00240         bucket_bids_type * bucket_bids = <span class="keyword">new</span> bucket_bids_type[nbuckets](est_bucket_size);
00241         int64 * bucket_sizes = <span class="keyword">new</span> int64[nbuckets];
00242         
00243         disk_queues::get_instance()-&gt;set_priority_op(disk_queue::WRITE);
00244         
00245         stable_ksort_local::distribute(
00246                         bucket_bids,
00247                         bucket_sizes,
00248                         nbuckets,
00249                         lognbuckets,
00250                         first,
00251                         last,
00252                         write_buffers_multiple*ndisks,
00253                         read_buffers_multiple*ndisks );
00254                         
00255         <span class="keywordtype">double</span> dist_end = stxxl_timestamp(),end;
00256   (void)(dist_end);
00257 <span class="preprocessor">        #ifdef COUNT_WAIT_TIME</span>
00258 <span class="preprocessor"></span>        <span class="keywordtype">double</span> io_wait_after_d = stxxl::wait_time_counter;
00259   (void)(io_wait_after_d);
00260 <span class="preprocessor">        #endif</span>
00261 <span class="preprocessor"></span>
00262 {
00263         <span class="comment">// sort buckets</span>
00264         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> write_buffers_multiple_bs = 2; 
00265         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_bucket_size_bl = (m - write_buffers_multiple_bs*ndisks)/2; <span class="comment">// in number of blocks</span>
00266         int64 max_bucket_size_rec = int64(max_bucket_size_bl)*block_type::size; <span class="comment">// in number of records</span>
00267         int64 max_bucket_size_act = 0; <span class="comment">// actual max bucket size</span>
00268         <span class="comment">// establish output stream</span>
00269         
00270         <span class="keywordflow">for</span>(i=0;i&lt;nbuckets;i++)
00271         {
00272                 max_bucket_size_act = STXXL_MAX(bucket_sizes[i],max_bucket_size_act);
00273                 <span class="keywordflow">if</span>(bucket_sizes[i] &gt; max_bucket_size_rec)
00274                 {
00275                         STXXL_ERRMSG(<span class="stringliteral">"Bucket "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" is too large: "</span>&lt;&lt;bucket_sizes[i]&lt;&lt;
00276                                 <span class="stringliteral">" records, maximum: "</span>&lt;&lt;max_bucket_size_rec);
00277                         STXXL_ERRMSG(<span class="stringliteral">"Recursion on buckets is not yet implemented, aborting."</span>);
00278                         abort();
00279                 }
00280                 
00281         }
00282         <span class="comment">// here we can increase write_buffers_multiple_b knowing max(bucket_sizes[i])</span>
00283         <span class="comment">// ... and decrease max_bucket_size_bl</span>
00284         <span class="keyword">const</span> <span class="keywordtype">int</span> max_bucket_size_act_bl = div_and_round_up(max_bucket_size_act,block_type::size);
00285         STXXL_MSG(<span class="stringliteral">"Reducing required number of required blocks per bucket from "</span>&lt;&lt;
00286                 max_bucket_size_bl&lt;&lt;<span class="stringliteral">" to "</span>&lt;&lt;max_bucket_size_act_bl)
00287         max_bucket_size_rec = max_bucket_size_act;
00288         max_bucket_size_bl = max_bucket_size_act_bl;
00289         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nwrite_buffers_bs = m - 2*max_bucket_size_bl;
00290         STXXL_MSG(<span class="stringliteral">"Write buffers in bucket sorting phase: "</span>&lt;&lt;nwrite_buffers_bs)
00291         
00292         <span class="keyword">typedef</span> buf_ostream&lt;block_type,typename ExtIterator_::bids_container_iterator&gt; buf_ostream_type;
00293         buf_ostream_type out(first.bid(),nwrite_buffers_bs);
00294         
00295         disk_queues::get_instance()-&gt;set_priority_op(disk_queue::READ);
00296         
00297         <span class="keywordflow">if</span>(first.block_offset())
00298         {
00299                 <span class="comment">// has to skip part of the first block</span>
00300                 block_type * block = <span class="keyword">new</span> block_type;
00301                 request_ptr req;
00302                 req = block-&gt;read(*first.bid());
00303                 req-&gt;wait();
00304                 
00305                 <span class="keywordflow">for</span>(i=0;i&lt;first.block_offset();i++)
00306                 {
00307                         out &lt;&lt; block-&gt;elem[i];
00308                 }
00309                 <span class="keyword">delete</span> block;
00310         }
00311         block_type * blocks1 = <span class="keyword">new</span> block_type[max_bucket_size_bl];
00312         block_type * blocks2 = <span class="keyword">new</span> block_type[max_bucket_size_bl];
00313         request_ptr * reqs1 = <span class="keyword">new</span> request_ptr [max_bucket_size_bl];
00314         request_ptr * reqs2 = <span class="keyword">new</span> request_ptr [max_bucket_size_bl];
00315         type_key_ *refs1 = <span class="keyword">new</span> type_key_[max_bucket_size_rec];
00316         type_key_ *refs2 = <span class="keyword">new</span> type_key_[max_bucket_size_rec];
00317         
00318         <span class="comment">// submit reading first 2 buckets (Peter's scheme)</span>
00319         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbucket_blocks = div_and_round_up(bucket_sizes[0],block_type::size);
00320         <span class="keywordflow">for</span>(i=0; i&lt;nbucket_blocks; i++)
00321                 reqs1[i] = blocks1[i].read(bucket_bids[0][i]);
00322         
00323         nbucket_blocks = div_and_round_up(bucket_sizes[1],block_type::size);
00324         <span class="keywordflow">for</span>(i=0; i&lt;nbucket_blocks; i++)
00325                 reqs2[i] = blocks2[i].read(bucket_bids[1][i]);
00326         
00327         key_type offset = 0;
00328         <span class="keywordtype">unsigned</span> log_k1 = static_cast&lt;int&gt;(ceil(log2(max_bucket_size_rec*<span class="keyword">sizeof</span>(type_key_)/STXXL_L2_SIZE)));
00329         <span class="keywordtype">unsigned</span> k1 = 1 &lt;&lt; log_k1;
00330         <span class="keywordtype">int</span> *bucket1 = <span class="keyword">new</span> <span class="keywordtype">int</span>[k1];
00331         
00332         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift = <span class="keyword">sizeof</span>(key_type)*8 - lognbuckets;
00333         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift1 = shift - log_k1;
00334         
00335         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> k=0;k&lt;nbuckets;k++)
00336         {
00337                 nbucket_blocks = div_and_round_up(bucket_sizes[k],block_type::size);
00338                 log_k1 = static_cast&lt;unsigned&gt;(ceil(log2(bucket_sizes[k]*<span class="keyword">sizeof</span>(type_key_)/STXXL_L2_SIZE)));
00339                 k1 = 1 &lt;&lt; log_k1;
00340                 std::fill(bucket1,bucket1 + k1,0);
00341 
00342                 STXXL_MSG(<span class="stringliteral">"Classifying bucket "</span>&lt;&lt;k&lt;&lt;<span class="stringliteral">" size:"</span>&lt;&lt;bucket_sizes[k]&lt;&lt;
00343                         <span class="stringliteral">" blocks:"</span>&lt;&lt;nbucket_blocks&lt;&lt;<span class="stringliteral">" log_k1:"</span>&lt;&lt; log_k1)
00344                 <span class="comment">// classify first nbucket_blocks-1 blocks, they are full</span>
00345                 type_key_ * ref_ptr = refs1;
00346                 key_type offset1 = offset + (key_type(1)&lt;&lt;key_type(shift)) * key_type(k);
00347                 <span class="keywordflow">for</span>(i = 0;i &lt; nbucket_blocks-1;i++)
00348                 {
00349                         reqs1[i]-&gt;wait();
00350                         stable_ksort_local::classify_block(blocks1[i].begin(),blocks1[i].end(),ref_ptr,bucket1,offset1,shift1<span class="comment">/*,k1*/</span>);
00351                 }
00352                 <span class="comment">// last block might be non-full</span>
00353                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last_block_size = bucket_sizes[k] - int64(nbucket_blocks - 1)*block_type::size;
00354                 reqs1[i]-&gt;wait();
00355                 
00356                 <span class="comment">//STXXL_MSG("block_type::size: "&lt;&lt;block_type::size&lt;&lt;" last_block_size:"&lt;&lt;last_block_size)</span>
00357                 
00358                 classify_block(blocks1[i].begin(),blocks1[i].begin() + last_block_size,ref_ptr,bucket1,offset1,shift1);
00359         
00360                 exclusive_prefix_sum(bucket1, k1);
00361                 classify(refs1, refs1 + bucket_sizes[k], refs2, bucket1,offset1, shift1);
00362         
00363                 type_key_ *c = refs2;
00364                 type_key_ *d = refs1;
00365                 <span class="keywordflow">for</span> (i = 0; i &lt; k1; i++)
00366                 {
00367                         type_key_ *cEnd = refs2 + bucket1[i];
00368                         type_key_ *dEnd = refs1 + bucket1[i];
00369                         
00370                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> log_k2 = static_cast&lt;unsigned&gt;(log2(bucket1[i])) - 1; <span class="comment">// adaptive bucket size</span>
00371                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k2 = 1 &lt;&lt; log_k2;
00372                         <span class="keywordtype">int</span> *bucket2 = <span class="keyword">new</span> <span class="keywordtype">int</span>[k2];
00373                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> shift2 = shift1 - log_k2;
00374                 
00375                         <span class="comment">// STXXL_MSG("Sorting bucket "&lt;&lt;k&lt;&lt;":"&lt;&lt;i)</span>
00376                         l1sort (c, cEnd, d, bucket2, k2,
00377                                         offset1 + (key_type(1)&lt;&lt;key_type(shift1)) * key_type(i) , 
00378                                         shift2);
00379                         
00380                         <span class="comment">// write out all</span>
00381                         <span class="keywordflow">for</span> (type_key_ * p = d; p &lt; dEnd; p++)
00382                                 out &lt;&lt; (*(p-&gt;ptr));
00383                         
00384                         <span class="keyword">delete</span> [] bucket2;
00385                         c = cEnd;
00386                         d = dEnd;
00387                 }
00388                 <span class="comment">// submit next read</span>
00389                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> bucket2submit = k+2;
00390                 <span class="keywordflow">if</span>( bucket2submit &lt; nbuckets )
00391                 {
00392                         nbucket_blocks = div_and_round_up(bucket_sizes[bucket2submit],block_type::size);
00393                         <span class="keywordflow">for</span>(i=0; i&lt;nbucket_blocks; i++)
00394                                 reqs1[i] = blocks1[i].read(bucket_bids[bucket2submit][i]);
00395                 }
00396                 
00397                 std::swap (blocks1, blocks2);
00398                 std::swap (reqs1, reqs2);
00399         }
00400         
00401         <span class="keyword">delete</span> [] bucket1;
00402         <span class="keyword">delete</span> [] refs1;
00403         <span class="keyword">delete</span> [] refs2;
00404         <span class="keyword">delete</span> [] blocks1;
00405         <span class="keyword">delete</span> [] blocks2;
00406         <span class="keyword">delete</span> [] reqs1;
00407         <span class="keyword">delete</span> [] reqs2;
00408         <span class="keyword">delete</span> [] bucket_bids;
00409         <span class="keyword">delete</span> [] bucket_sizes;
00410         
00411         <span class="keywordflow">if</span>(last.block_offset())
00412         {
00413                 <span class="comment">// has to skip part of the first block</span>
00414                 block_type * block = <span class="keyword">new</span> block_type;
00415                 request_ptr req = block-&gt;read(*last.bid());
00416                 req-&gt;wait();
00417                 
00418                 <span class="keywordflow">for</span>(i=last.block_offset();i&lt;block_type::size;i++)
00419                 {
00420                         out &lt;&lt; block-&gt;elem[i];
00421                 }
00422                 <span class="keyword">delete</span> block;
00423         }
00424         
00425         end = stxxl_timestamp();
00426         
00427   }
00428         
00429         STXXL_VERBOSE (<span class="stringliteral">"Elapsed time        : "</span> &lt;&lt; end - begin &lt;&lt; <span class="stringliteral">" s. Distribution time: "</span> &lt;&lt; 
00430         dist_end - begin &lt;&lt; <span class="stringliteral">" s"</span>)
00431 #ifdef STXXL_IO_STATS
00432         STXXL_VERBOSE (<span class="stringliteral">"reads               : "</span> &lt;&lt; iostats-&gt;get_reads ()) 
00433         STXXL_VERBOSE (<span class="stringliteral">"writes              : "</span> &lt;&lt; iostats-&gt;get_writes ())
00434         STXXL_VERBOSE (<span class="stringliteral">"read time           : "</span> &lt;&lt; iostats-&gt;get_read_time () &lt;&lt; <span class="stringliteral">" s"</span>) 
00435         STXXL_VERBOSE (<span class="stringliteral">"write time          : "</span> &lt;&lt; iostats-&gt;get_write_time () &lt;&lt;<span class="stringliteral">" s"</span>)
00436         STXXL_VERBOSE (<span class="stringliteral">"parallel read time  : "</span> &lt;&lt; iostats-&gt;get_pread_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00437         STXXL_VERBOSE (<span class="stringliteral">"parallel write time : "</span> &lt;&lt; iostats-&gt;get_pwrite_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00438         STXXL_VERBOSE (<span class="stringliteral">"parallel io time    : "</span> &lt;&lt; iostats-&gt;get_pio_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00439 <span class="preprocessor">#endif</span>
00440 <span class="preprocessor"></span><span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00441 <span class="preprocessor"></span>        STXXL_VERBOSE (<span class="stringliteral">"Time in I/O wait(ds): "</span> &lt;&lt; io_wait_after_d &lt;&lt; <span class="stringliteral">" s"</span>)
00442         STXXL_VERBOSE (<span class="stringliteral">"Time in I/O wait    : "</span> &lt;&lt; stxxl::wait_time_counter &lt;&lt; <span class="stringliteral">" s"</span>)
00443 #endif
00444 }
00445 
00447 
00448 __STXXL_END_NAMESPACE
00449 
00450 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Jul 1 11:08:36 2003 for &lt;stxxl&gt; by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
