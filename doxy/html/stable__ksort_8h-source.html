<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: stable_ksort.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>stable_ksort.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef STABLE_KSORT_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define STABLE_KSORT_HEADER</span>
00003 <span class="preprocessor"></span><span class="comment">/***************************************************************************</span>
00004 <span class="comment"> *            stable_ksort.h</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Tue Feb  4 16:45:46 2003</span>
00007 <span class="comment"> *  Copyright  2003  Roman Dementiev</span>
00008 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00009 <span class="comment"> ****************************************************************************/</span>
00010 
00011 
00012 <span class="comment">// it is a first try: distribution sort without sampling</span>
00013 <span class="comment">// I rework the stable_ksort when I would have a time</span>
00014 
00015 <span class="preprocessor">#include &lt;math.h&gt;</span>
00016 <span class="preprocessor">#include "../mng/mng.h"</span>
00017 <span class="preprocessor">#include "../common/utils.h"</span>
00018 <span class="preprocessor">#include "../mng/buf_istream.h"</span>
00019 <span class="preprocessor">#include "../mng/buf_ostream.h"</span>
00020 <span class="preprocessor">#include "../common/simple_vector.h"</span>
00021 <span class="preprocessor">#include "intksort.h"</span>
00022 
00023 __STXXL_BEGIN_NAMESPACE
00024 
00027 
<a name="l00030"></a><a class="code" href="namespacestxxl_1_1stable__ksort__local.html">00030</a> <span class="keyword">namespace </span>stable_ksort_local
00031 {
00032   <span class="keyword">template</span> &lt;<span class="keyword">class</span> type_,<span class="keyword">class</span> type_key&gt;
00033   <span class="keywordtype">void</span> classify_block(type_ * begin,type_ * end,type_key * &amp; out,<span class="keywordtype">int</span> * bucket,<span class="keywordtype">unsigned</span> offset, <span class="keywordtype">unsigned</span> shift)
00034   {
00035     <span class="keywordflow">for</span> (type_ * p = begin;p&lt;end; p++,out++)    <span class="comment">// count &amp; create references</span>
00036     {
00037       out-&gt;ptr = p;
00038       <span class="keyword">typename</span> type_::key_type key = p-&gt;key();
00039       <span class="keywordtype">int</span> ibucket = (key - offset) &gt;&gt; shift;
00040       out-&gt;key = key;
00041       bucket[ibucket]++;
00042     }
00043   }
00044 
00045         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00046         <span class="keyword">struct </span>type_key
00047         {
00048                 <span class="keyword">typedef</span> <span class="keyword">typename</span> type::key_type key_type;
00049                 key_type key;
00050                 type * ptr;
00051                 
00052                 type_key() {};
00053                 type_key(key_type k, type * p):key (k), ptr (p)
00054                 {
00055                 };
00056         };
00057         
00058         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00059         <span class="keywordtype">bool</span> operator  &lt; (const type_key&lt;type&gt; &amp; a, <span class="keyword">const</span> type_key&lt;type&gt; &amp; b)
00060         {
00061                         <span class="keywordflow">return</span> a.key &lt; b.key;
00062         }
00063         
00064         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00065         <span class="keywordtype">bool</span> operator  &gt; (<span class="keyword">const</span> type_key&lt;type&gt; &amp; a, <span class="keyword">const</span> type_key&lt;type&gt; &amp; b)
00066         {
00067                         <span class="keywordflow">return</span> a.key &gt; b.key;
00068         }
00069         
00070 
00071         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIDType_,<span class="keyword">typename</span> AllocStrategy_&gt;
00072         <span class="keyword">class </span>bid_sequence
00073         {
00074         <span class="keyword">public</span>:
00075                 <span class="keyword">typedef</span> BIDType_ bid_type;
00076                 <span class="keyword">typedef</span> bid_type &amp; reference;
00077                 <span class="keyword">typedef</span> AllocStrategy_ alloc_strategy;
00078                 <span class="keyword">typedef</span> <span class="keyword">typename</span> simple_vector&lt;bid_type&gt;::size_type size_type;
00079                 <span class="keyword">typedef</span> <span class="keyword">typename</span> simple_vector&lt;bid_type&gt;::iterator iterator;
00080         <span class="keyword">protected</span>:
00081                 simple_vector&lt;bid_type&gt; * bids;
00082                 alloc_strategy alloc_strategy_;
00083                 
00084                 bid_sequence() {}
00085         <span class="keyword">public</span>:
00086                 bid_sequence(size_type size_)
00087                 {
00088                         bids = <span class="keyword">new</span> simple_vector&lt;bid_type&gt;(size_);
00089                         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * mng = block_manager::get_instance();
00090                         mng-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(alloc_strategy_,bids-&gt;begin(),bids-&gt;end());
00091                 }
00092                 reference operator [] (size_type i)
00093                 {
00094                         size_type size_ = size(); <span class="comment">// cache size in a register</span>
00095                         <span class="keywordflow">if</span>(i &lt; size_)
00096                                 <span class="keywordflow">return</span> *(bids-&gt;begin() + i);
00097                         
00098                         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * mng = block_manager::get_instance();
00099                         simple_vector&lt;bid_type&gt; * larger_bids = <span class="keyword">new</span> simple_vector&lt;bid_type&gt;((i+1)*2);
00100                         std::copy(bids-&gt;begin(),bids-&gt;end(),larger_bids-&gt;begin());
00101                         mng-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(alloc_strategy_,larger_bids-&gt;begin() + size_,larger_bids-&gt;end());
00102                         <span class="keyword">delete</span> bids;
00103                         bids = larger_bids;
00104                         <span class="keywordflow">return</span> *(larger_bids-&gt;begin() + i);
00105                 }
00106                 size_type size() { <span class="keywordflow">return</span> bids-&gt;size();} 
00107                 iterator begin() { <span class="keywordflow">return</span> bids-&gt;begin(); }
00108                 ~bid_sequence()
00109                 {
00110                         block_manager::get_instance()-&gt;delete_blocks(bids-&gt;begin(),bids-&gt;end());
00111                         <span class="keyword">delete</span> bids;
00112                 }
00113         };
00114 
00115         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExtIterator_&gt;
00116         <span class="keywordtype">void</span> distribute(
00117                 bid_sequence&lt;<span class="keyword">typename</span> ExtIterator_::vector_type::block_type::bid_type,
00118                         <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy&gt; * bucket_bids,
00119                 int64 * bucket_sizes,
00120                 <span class="keyword">const</span> <span class="keywordtype">int</span> nbuckets,
00121                 <span class="keyword">const</span> <span class="keywordtype">int</span> lognbuckets,
00122                 ExtIterator_ first,
00123                 ExtIterator_ last,
00124                 <span class="keyword">const</span> <span class="keywordtype">int</span> nread_buffers,
00125                 <span class="keyword">const</span> <span class="keywordtype">int</span> nwrite_buffers)
00126         {
00127                 <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::vector_type::value_type value_type;
00128                 <span class="keyword">typedef</span> <span class="keyword">typename</span> value_type::key_type key_type;
00129                 <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::block_type block_type;
00130                 <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00131                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1buf__istream.html">buf_istream</a>&lt;<span class="keyword">typename</span> ExtIterator_::block_type,
00132                                 <span class="keyword">typename</span> ExtIterator_::bids_container_iterator&gt; buf_istream_type;
00133         
00134                 <span class="keywordtype">int</span> i=0;
00135                 
00136                 buf_istream_type in(first.bid(),last.bid() + ((first.block_offset())?1:0),
00137                         nread_buffers);
00138                 
00139                 <a class="code" href="classstxxl_1_1buffered__writer.html">buffered_writer&lt;block_type&gt;</a> out(
00140                         nbuckets + nwrite_buffers,
00141                         nwrite_buffers);
00142                 
00143                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * bucket_block_offsets = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[nbuckets];
00144                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * bucket_iblock = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[nbuckets];
00145                 block_type ** bucket_blocks = <span class="keyword">new</span> block_type *[nbuckets];
00146                 
00147                 std::fill(bucket_sizes,bucket_sizes + nbuckets,0);
00148                 std::fill(bucket_iblock,bucket_iblock + nbuckets,0);
00149                 std::fill(bucket_block_offsets,bucket_block_offsets + nbuckets,0);
00150                 
00151                 <span class="keywordflow">for</span>(i= 0; i&lt; nbuckets; i++)
00152                         bucket_blocks[i] = out.<a class="code" href="classstxxl_1_1buffered__writer.html#a1">get_free_block</a>();
00153                 
00154                 ExtIterator_ cur = first - first.block_offset();
00155                 
00156                 <span class="comment">// skip part of the block before first untouched</span>
00157                 <span class="keywordflow">for</span>( ;cur != first;cur++)
00158                         ++in;
00159                 
00160                 <span class="keyword">const</span> <span class="keywordtype">int</span> shift = <span class="keyword">sizeof</span>(key_type)*8 - lognbuckets;
00161                 <span class="comment">// search in the the range [_begin,_end)</span>
00162                 <span class="keywordflow">for</span>( ;cur != last;cur++)
00163                 {
00164                         key_type cur_key = in.current().key();
00165                         <span class="keywordtype">int</span> ibucket = cur_key &gt;&gt; shift;
00166                         
00167                         <span class="keywordtype">int</span> block_offset = bucket_block_offsets[ibucket];
00168                         in &gt;&gt; (bucket_blocks[ibucket]-&gt;elem[block_offset++]);
00169                         <span class="keywordflow">if</span>(block_offset == block_type::size)
00170                         {
00171                                 block_offset = 0;
00172                                 <span class="keywordtype">int</span> iblock = bucket_iblock[ibucket]++;
00173                                 bucket_blocks[ibucket] = out.<a class="code" href="classstxxl_1_1buffered__writer.html#a2">write</a>(bucket_blocks[ibucket],bucket_bids[ibucket][iblock]);
00174                         }
00175                         bucket_block_offsets[ibucket] = block_offset;
00176                 }
00177                 <span class="keywordflow">for</span>(i = 0 ;i&lt;nbuckets;i++)
00178                 {
00179                         <span class="keywordflow">if</span>(bucket_block_offsets[i])
00180                         {
00181                                 out.<a class="code" href="classstxxl_1_1buffered__writer.html#a2">write</a>(bucket_blocks[i],bucket_bids[i][bucket_iblock[i]]);
00182                         }
00183                         bucket_sizes[i] = int64(block_type::size) * bucket_iblock[i] + 
00184                                 bucket_block_offsets[i];
00185                         STXXL_MSG(<span class="stringliteral">"Bucket "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" has size "</span>&lt;&lt;bucket_sizes[i]&lt;&lt;
00186                                 <span class="stringliteral">", estimated size: "</span>&lt;&lt;((last-first)/int64(nbuckets)))
00187                 }
00188                 
00189                 
00190                 <span class="keyword">delete</span> [] bucket_blocks;
00191                 <span class="keyword">delete</span> [] bucket_block_offsets;
00192                 <span class="keyword">delete</span> [] bucket_iblock;
00193         }
00194 };
00195 
00196 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExtIterator_&gt;
00197 <span class="keywordtype">void</span> stable_ksort(ExtIterator_ first, ExtIterator_ last,<span class="keywordtype">unsigned</span> M)
00198 {
00199         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::vector_type::value_type value_type;
00200         <span class="keyword">typedef</span> <span class="keyword">typename</span> value_type::key_type key_type;
00201         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::block_type block_type;
00202         <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00203         <span class="keyword">typedef</span> <span class="keyword">typename</span> ExtIterator_::vector_type::alloc_strategy alloc_strategy;
00204         <span class="keyword">typedef</span> stable_ksort_local::bid_sequence&lt;bid_type,alloc_strategy&gt; bucket_bids_type;
00205         <span class="keyword">typedef</span> stable_ksort_local::type_key&lt;value_type&gt; type_key_;
00206         
00207         first.flush(); <span class="comment">// flush container</span>
00208         
00209 <span class="preprocessor">#ifdef STXXL_IO_STATS</span>
00210 <span class="preprocessor"></span>        <a class="code" href="classstxxl_1_1stats.html">stats</a> *iostats = stats::get_instance ();
00211         iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a7">reset</a> ();
00212 <span class="preprocessor">#endif</span>
00213 <span class="preprocessor"></span>        
00214         reset_io_wait_time();
00215         
00216 
00217         <span class="keywordtype">double</span> begin = stxxl_timestamp();
00218         (<span class="keywordtype">void</span>)(begin);
00219   
00220   
00221         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;
00222         <a class="code" href="classstxxl_1_1config.html">config</a> * cfg = config::get_instance();
00223         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = M/block_type::raw_size;
00224         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> write_buffers_multiple = 2;
00225         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> read_buffers_multiple = 2;
00226         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ndisks = cfg-&gt;<a class="code" href="classstxxl_1_1config.html#a1">ndisks</a>();
00227         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nmaxbuckets = m - (write_buffers_multiple + read_buffers_multiple)*ndisks;
00228         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lognbuckets = static_cast&lt;unsigned&gt;(log2(nmaxbuckets));
00229         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbuckets = 1&lt;&lt;lognbuckets;
00230         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> est_bucket_size = div_and_round_up((last-first)/int64(nbuckets),
00231                 int64(block_type::size)); <span class="comment">//in blocks</span>
00232 
00233         STXXL_MSG(<span class="stringliteral">"Elements to sort: "</span> &lt;&lt; (last - first))
00234         STXXL_MSG(<span class="stringliteral">"Number of buckets has to be reduced from "</span>&lt;&lt;nmaxbuckets&lt;&lt;<span class="stringliteral">" to "</span>&lt;&lt; nbuckets)
00235         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nread_buffers = (m - nbuckets)*read_buffers_multiple/(read_buffers_multiple+write_buffers_multiple);
00236         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nwrite_buffers = (m - nbuckets)*write_buffers_multiple/(read_buffers_multiple+write_buffers_multiple);
00237 
00238         STXXL_MSG(<span class="stringliteral">"Read buffers in distribution phase: "</span>&lt;&lt;nread_buffers)
00239         STXXL_MSG(<span class="stringliteral">"Write buffers in distribution phase: "</span>&lt;&lt;nwrite_buffers)
00240 
00241         bucket_bids_type * bucket_bids = <span class="keyword">new</span> bucket_bids_type[nbuckets](est_bucket_size);
00242         int64 * bucket_sizes = <span class="keyword">new</span> int64[nbuckets];
00243         
00244         disk_queues::get_instance()-&gt;set_priority_op(disk_queue::WRITE);
00245         
00246         stable_ksort_local::distribute(
00247                         bucket_bids,
00248                         bucket_sizes,
00249                         nbuckets,
00250                         lognbuckets,
00251                         first,
00252                         last,
00253                         write_buffers_multiple*ndisks,
00254                         read_buffers_multiple*ndisks );
00255                         
00256         <span class="keywordtype">double</span> dist_end = stxxl_timestamp(),end;
00257   (<span class="keywordtype">void</span>)(dist_end);
00258 <span class="preprocessor">        #ifdef COUNT_WAIT_TIME</span>
00259 <span class="preprocessor"></span>        <span class="keywordtype">double</span> io_wait_after_d = stxxl::wait_time_counter;
00260   (<span class="keywordtype">void</span>)(io_wait_after_d);
00261 <span class="preprocessor">        #endif</span>
00262 <span class="preprocessor"></span>
00263 {
00264         <span class="comment">// sort buckets</span>
00265         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> write_buffers_multiple_bs = 2; 
00266         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_bucket_size_bl = (m - write_buffers_multiple_bs*ndisks)/2; <span class="comment">// in number of blocks</span>
00267         int64 max_bucket_size_rec = int64(max_bucket_size_bl)*block_type::size; <span class="comment">// in number of records</span>
00268         int64 max_bucket_size_act = 0; <span class="comment">// actual max bucket size</span>
00269         <span class="comment">// establish output stream</span>
00270         
00271         <span class="keywordflow">for</span>(i=0;i&lt;nbuckets;i++)
00272         {
00273                 max_bucket_size_act = STXXL_MAX(bucket_sizes[i],max_bucket_size_act);
00274                 <span class="keywordflow">if</span>(bucket_sizes[i] &gt; max_bucket_size_rec)
00275                 {
00276                         STXXL_ERRMSG(<span class="stringliteral">"Bucket "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" is too large: "</span>&lt;&lt;bucket_sizes[i]&lt;&lt;
00277                                 <span class="stringliteral">" records, maximum: "</span>&lt;&lt;max_bucket_size_rec);
00278                         STXXL_ERRMSG(<span class="stringliteral">"Recursion on buckets is not yet implemented, aborting."</span>);
00279                         abort();
00280                 }
00281                 
00282         }
00283         <span class="comment">// here we can increase write_buffers_multiple_b knowing max(bucket_sizes[i])</span>
00284         <span class="comment">// ... and decrease max_bucket_size_bl</span>
00285         <span class="keyword">const</span> <span class="keywordtype">int</span> max_bucket_size_act_bl = div_and_round_up(max_bucket_size_act,block_type::size);
00286         STXXL_MSG(<span class="stringliteral">"Reducing required number of required blocks per bucket from "</span>&lt;&lt;
00287                 max_bucket_size_bl&lt;&lt;<span class="stringliteral">" to "</span>&lt;&lt;max_bucket_size_act_bl)
00288         max_bucket_size_rec = max_bucket_size_act;
00289         max_bucket_size_bl = max_bucket_size_act_bl;
00290         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nwrite_buffers_bs = m - 2*max_bucket_size_bl;
00291         STXXL_MSG(<span class="stringliteral">"Write buffers in bucket sorting phase: "</span>&lt;&lt;nwrite_buffers_bs)
00292         
00293         <span class="keyword">typedef</span> buf_ostream&lt;block_type,typename ExtIterator_::bids_container_iterator&gt; buf_ostream_type;
00294         buf_ostream_type out(first.bid(),nwrite_buffers_bs);
00295         
00296         disk_queues::get_instance()-&gt;set_priority_op(disk_queue::READ);
00297         
00298         <span class="keywordflow">if</span>(first.block_offset())
00299         {
00300                 <span class="comment">// has to skip part of the first block</span>
00301                 block_type * block = <span class="keyword">new</span> block_type;
00302                 request_ptr req;
00303                 req = block-&gt;read(*first.bid());
00304                 req-&gt;wait();
00305                 
00306                 <span class="keywordflow">for</span>(i=0;i&lt;first.block_offset();i++)
00307                 {
00308                         out &lt;&lt; block-&gt;elem[i];
00309                 }
00310                 <span class="keyword">delete</span> block;
00311         }
00312         block_type * blocks1 = <span class="keyword">new</span> block_type[max_bucket_size_bl];
00313         block_type * blocks2 = <span class="keyword">new</span> block_type[max_bucket_size_bl];
00314         request_ptr * reqs1 = <span class="keyword">new</span> request_ptr [max_bucket_size_bl];
00315         request_ptr * reqs2 = <span class="keyword">new</span> request_ptr [max_bucket_size_bl];
00316         type_key_ *refs1 = <span class="keyword">new</span> type_key_[max_bucket_size_rec];
00317         type_key_ *refs2 = <span class="keyword">new</span> type_key_[max_bucket_size_rec];
00318         
00319         <span class="comment">// submit reading first 2 buckets (Peter's scheme)</span>
00320         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbucket_blocks = div_and_round_up(bucket_sizes[0],block_type::size);
00321         <span class="keywordflow">for</span>(i=0; i&lt;nbucket_blocks; i++)
00322                 reqs1[i] = blocks1[i].read(bucket_bids[0][i]);
00323         
00324         nbucket_blocks = div_and_round_up(bucket_sizes[1],block_type::size);
00325         <span class="keywordflow">for</span>(i=0; i&lt;nbucket_blocks; i++)
00326                 reqs2[i] = blocks2[i].read(bucket_bids[1][i]);
00327         
00328         key_type offset = 0;
00329         <span class="keywordtype">unsigned</span> log_k1 = static_cast&lt;int&gt;(ceil(log2(max_bucket_size_rec*<span class="keyword">sizeof</span>(type_key_)/STXXL_L2_SIZE)));
00330         <span class="keywordtype">unsigned</span> k1 = 1 &lt;&lt; log_k1;
00331         <span class="keywordtype">int</span> *bucket1 = <span class="keyword">new</span> <span class="keywordtype">int</span>[k1];
00332         
00333         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift = <span class="keyword">sizeof</span>(key_type)*8 - lognbuckets;
00334         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> shift1 = shift - log_k1;
00335         
00336         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> k=0;k&lt;nbuckets;k++)
00337         {
00338                 nbucket_blocks = div_and_round_up(bucket_sizes[k],block_type::size);
00339                 log_k1 = static_cast&lt;unsigned&gt;(ceil(log2(bucket_sizes[k]*<span class="keyword">sizeof</span>(type_key_)/STXXL_L2_SIZE)));
00340                 k1 = 1 &lt;&lt; log_k1;
00341                 std::fill(bucket1,bucket1 + k1,0);
00342 
00343                 STXXL_MSG(<span class="stringliteral">"Classifying bucket "</span>&lt;&lt;k&lt;&lt;<span class="stringliteral">" size:"</span>&lt;&lt;bucket_sizes[k]&lt;&lt;
00344                         <span class="stringliteral">" blocks:"</span>&lt;&lt;nbucket_blocks&lt;&lt;<span class="stringliteral">" log_k1:"</span>&lt;&lt; log_k1)
00345                 <span class="comment">// classify first nbucket_blocks-1 blocks, they are full</span>
00346                 type_key_ * ref_ptr = refs1;
00347                 key_type offset1 = offset + (key_type(1)&lt;&lt;key_type(shift)) * key_type(k);
00348                 <span class="keywordflow">for</span>(i = 0;i &lt; nbucket_blocks-1;i++)
00349                 {
00350                         reqs1[i]-&gt;wait();
00351                         stable_ksort_local::classify_block(blocks1[i].begin(),blocks1[i].end(),ref_ptr,bucket1,offset1,shift1<span class="comment">/*,k1*/</span>);
00352                 }
00353                 <span class="comment">// last block might be non-full</span>
00354                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last_block_size = bucket_sizes[k] - int64(nbucket_blocks - 1)*block_type::size;
00355                 reqs1[i]-&gt;wait();
00356                 
00357                 <span class="comment">//STXXL_MSG("block_type::size: "&lt;&lt;block_type::size&lt;&lt;" last_block_size:"&lt;&lt;last_block_size)</span>
00358                 
00359                 classify_block(blocks1[i].begin(),blocks1[i].begin() + last_block_size,ref_ptr,bucket1,offset1,shift1);
00360         
00361                 exclusive_prefix_sum(bucket1, k1);
00362                 classify(refs1, refs1 + bucket_sizes[k], refs2, bucket1,offset1, shift1);
00363         
00364                 type_key_ *c = refs2;
00365                 type_key_ *d = refs1;
00366                 <span class="keywordflow">for</span> (i = 0; i &lt; k1; i++)
00367                 {
00368                         type_key_ *cEnd = refs2 + bucket1[i];
00369                         type_key_ *dEnd = refs1 + bucket1[i];
00370                         
00371                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> log_k2 = static_cast&lt;unsigned&gt;(log2(bucket1[i])) - 1; <span class="comment">// adaptive bucket size</span>
00372                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k2 = 1 &lt;&lt; log_k2;
00373                         <span class="keywordtype">int</span> *bucket2 = <span class="keyword">new</span> <span class="keywordtype">int</span>[k2];
00374                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> shift2 = shift1 - log_k2;
00375                 
00376                         <span class="comment">// STXXL_MSG("Sorting bucket "&lt;&lt;k&lt;&lt;":"&lt;&lt;i)</span>
00377                         l1sort (c, cEnd, d, bucket2, k2,
00378                                         offset1 + (key_type(1)&lt;&lt;key_type(shift1)) * key_type(i) , 
00379                                         shift2);
00380                         
00381                         <span class="comment">// write out all</span>
00382                         <span class="keywordflow">for</span> (type_key_ * p = d; p &lt; dEnd; p++)
00383                                 out &lt;&lt; (*(p-&gt;ptr));
00384                         
00385                         <span class="keyword">delete</span> [] bucket2;
00386                         c = cEnd;
00387                         d = dEnd;
00388                 }
00389                 <span class="comment">// submit next read</span>
00390                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> bucket2submit = k+2;
00391                 <span class="keywordflow">if</span>( bucket2submit &lt; nbuckets )
00392                 {
00393                         nbucket_blocks = div_and_round_up(bucket_sizes[bucket2submit],block_type::size);
00394                         <span class="keywordflow">for</span>(i=0; i&lt;nbucket_blocks; i++)
00395                                 reqs1[i] = blocks1[i].read(bucket_bids[bucket2submit][i]);
00396                 }
00397                 
00398                 std::swap (blocks1, blocks2);
00399                 std::swap (reqs1, reqs2);
00400         }
00401         
00402         <span class="keyword">delete</span> [] bucket1;
00403         <span class="keyword">delete</span> [] refs1;
00404         <span class="keyword">delete</span> [] refs2;
00405         <span class="keyword">delete</span> [] blocks1;
00406         <span class="keyword">delete</span> [] blocks2;
00407         <span class="keyword">delete</span> [] reqs1;
00408         <span class="keyword">delete</span> [] reqs2;
00409         <span class="keyword">delete</span> [] bucket_bids;
00410         <span class="keyword">delete</span> [] bucket_sizes;
00411         
00412         <span class="keywordflow">if</span>(last.block_offset())
00413         {
00414                 <span class="comment">// has to skip part of the first block</span>
00415                 block_type * block = <span class="keyword">new</span> block_type;
00416                 request_ptr req = block-&gt;read(*last.bid());
00417                 req-&gt;wait();
00418                 
00419                 <span class="keywordflow">for</span>(i=last.block_offset();i&lt;block_type::size;i++)
00420                 {
00421                         out &lt;&lt; block-&gt;elem[i];
00422                 }
00423                 <span class="keyword">delete</span> block;
00424         }
00425         
00426         end = stxxl_timestamp();
00427         
00428   }
00429         
00430         STXXL_VERBOSE (<span class="stringliteral">"Elapsed time        : "</span> &lt;&lt; end - begin &lt;&lt; <span class="stringliteral">" s. Distribution time: "</span> &lt;&lt; 
00431         dist_end - begin &lt;&lt; <span class="stringliteral">" s"</span>)
00432 #ifdef STXXL_IO_STATS
00433         STXXL_VERBOSE (<span class="stringliteral">"reads               : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a0">get_reads</a> ()) 
00434         STXXL_VERBOSE (<span class="stringliteral">"writes              : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a1">get_writes</a> ())
00435         STXXL_VERBOSE (<span class="stringliteral">"read time           : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a2">get_read_time</a> () &lt;&lt; <span class="stringliteral">" s"</span>) 
00436         STXXL_VERBOSE (<span class="stringliteral">"write time          : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a3">get_write_time</a> () &lt;&lt;<span class="stringliteral">" s"</span>)
00437         STXXL_VERBOSE (<span class="stringliteral">"parallel read time  : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a4">get_pread_time</a> () &lt;&lt; <span class="stringliteral">" s"</span>)
00438         STXXL_VERBOSE (<span class="stringliteral">"parallel write time : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a5">get_pwrite_time</a> () &lt;&lt; <span class="stringliteral">" s"</span>)
00439         STXXL_VERBOSE (<span class="stringliteral">"parallel io time    : "</span> &lt;&lt; iostats-&gt;<a class="code" href="classstxxl_1_1stats.html#a6">get_pio_time</a> () &lt;&lt; <span class="stringliteral">" s"</span>)
00440 <span class="preprocessor">#endif</span>
00441 <span class="preprocessor"></span><span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00442 <span class="preprocessor"></span>        STXXL_VERBOSE (<span class="stringliteral">"Time in I/O wait(ds): "</span> &lt;&lt; io_wait_after_d &lt;&lt; <span class="stringliteral">" s"</span>)
00443         STXXL_VERBOSE (<span class="stringliteral">"Time in I/O wait    : "</span> &lt;&lt; stxxl::wait_time_counter &lt;&lt; <span class="stringliteral">" s"</span>)
00444 #endif
00445 }
00446 
00448 
00449 __STXXL_END_NAMESPACE
00450 
00451 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Nov 26 10:56:54 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
