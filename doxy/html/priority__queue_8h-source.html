<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: priority_queue.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>priority_queue.h</h1><div class="fragment"><pre>00001 <span class="preprocessor"> #ifndef PRIORITY_QUEUE_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor"> #define PRIORITY_QUEUE_HEADER</span>
00003 <span class="preprocessor"></span> <span class="comment">/***************************************************************************</span>
00004 <span class="comment"> *            priority_queue.h</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Thu Jul  3 15:22:50 2003</span>
00007 <span class="comment"> *  Copyright  2003  Roman Dementiev</span>
00008 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00009 <span class="comment"> ****************************************************************************/</span>
00010 <span class="preprocessor">#include "../common/utils.h"</span>
00011 <span class="preprocessor">#include "../mng/prefetch_pool.h"</span>
00012 <span class="preprocessor">#include "../mng/write_pool.h"</span>
00013 <span class="preprocessor">#include "../mng/mng.h"</span>
00014 <span class="preprocessor">#include "../common/tmeta.h"</span>
00015 <span class="preprocessor">#include &lt;queue&gt;</span>
00016 <span class="preprocessor">#include &lt;list&gt;</span>
00017 <span class="preprocessor">#include &lt;iterator&gt;</span>
00018 
00019 __STXXL_BEGIN_NAMESPACE
00020 
00024 
<a name="l00027"></a><a class="code" href="namespacestxxl_1_1priority__queue__local.html">00027</a> <span class="keyword">namespace </span>priority_queue_local
00028 {
00029   
00030   
00032 <span class="comment">// auxiliary functions</span>
00033 
00034 <span class="comment">// merge sz element from the two sentinel terminated input</span>
00035 <span class="comment">// sequences *f0 and *f1 to "to"</span>
00036 <span class="comment">// advance *fo and *f1 accordingly.</span>
00037 <span class="comment">// require: at least sz nonsentinel elements available in f0, f1</span>
00038 <span class="comment">// require: to may overwrite one of the sources as long as</span>
00039 <span class="comment">//   *fx + sz is before the end of fx</span>
00040 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value_,<span class="keyword">class</span> Cmp_&gt;
00041 <span class="keywordtype">void</span> merge(Value_ **f0,
00042            Value_ **f1,
00043            Value_  *to, <span class="keywordtype">int</span> sz, Cmp_ cmp) 
00044 {
00045   Value_ *from0   = *f0;
00046   Value_ *from1   = *f1;
00047   Value_ *done    = to + sz;
00048 
00049   <span class="keywordflow">while</span> (to != done)
00050   {
00051     <span class="keywordflow">if</span>(cmp(*from0,*from1))
00052     {
00053       *to = *from1;
00054       ++from1;
00055     }
00056     <span class="keywordflow">else</span>
00057     {
00058       *to = *from0; 
00059       ++from0; 
00060     }
00061     ++to;
00062   }
00063   *f0   = from0;
00064   *f1   = from1;
00065 }
00066 
00067 
00068 <span class="comment">// merge sz element from the three sentinel terminated input</span>
00069 <span class="comment">// sequences *f0, *f1 and *f2 to "to"</span>
00070 <span class="comment">// advance *f0, *f1 and *f2 accordingly.</span>
00071 <span class="comment">// require: at least sz nonsentinel elements available in f0, f1 and f2</span>
00072 <span class="comment">// require: to may overwrite one of the sources as long as</span>
00073 <span class="comment">//   *fx + sz is before the end of fx</span>
00074 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value_,<span class="keyword">class</span> Cmp_&gt;
00075 <span class="keywordtype">void</span> merge3(
00076            Value_ **f0,
00077            Value_ **f1,
00078            Value_ **f2,
00079            Value_  *to, <span class="keywordtype">int</span> sz,Cmp_ cmp) 
00080 {
00081   Value_ *from0   = *f0;
00082   Value_ *from1   = *f1;
00083   Value_ *from2   = *f2;
00084   Value_ *done    = to + sz;
00085 
00086   <span class="keywordflow">if</span> (cmp(*from1,*from0)) {
00087     <span class="keywordflow">if</span> (cmp(*from2,*from1))   { <span class="keywordflow">goto</span> s012; }
00088     <span class="keywordflow">else</span> { 
00089       <span class="keywordflow">if</span> (cmp(*from0,*from2)) { <span class="keywordflow">goto</span> s201; }
00090       <span class="keywordflow">else</span>             { <span class="keywordflow">goto</span> s021; }
00091     }
00092   } <span class="keywordflow">else</span> {
00093     <span class="keywordflow">if</span> (cmp(*from2,*from1)) {
00094       <span class="keywordflow">if</span> (cmp(*from2,*from0)) { <span class="keywordflow">goto</span> s102; }
00095       <span class="keywordflow">else</span>             { <span class="keywordflow">goto</span> s120; }
00096     } <span class="keywordflow">else</span>             { <span class="keywordflow">goto</span> s210; }
00097   }
00098 
00099 <span class="preprocessor">#define Merge3Case(a,b,c)\</span>
00100 <span class="preprocessor">  s ## a ## b ## c :\</span>
00101 <span class="preprocessor">  if (to == done) goto finish;\</span>
00102 <span class="preprocessor">  *to = * from ## a ;\</span>
00103 <span class="preprocessor">  ++to;\</span>
00104 <span class="preprocessor">  ++from ## a ;\</span>
00105 <span class="preprocessor">  if (cmp(*from ## b , *from ## a )) goto s ## a ## b ## c;\</span>
00106 <span class="preprocessor">  if (cmp(*from ## c , *from ## a )) goto s ## b ## a ## c;\</span>
00107 <span class="preprocessor">  goto s ## b ## c ## a;</span>
00108 <span class="preprocessor"></span>
00109   <span class="comment">// the order is choosen in such a way that </span>
00110   <span class="comment">// four of the trailing gotos can be eliminated by the optimizer</span>
00111   Merge3Case(0, 1, 2);
00112   Merge3Case(1, 2, 0);
00113   Merge3Case(2, 0, 1);
00114   Merge3Case(1, 0, 2);
00115   Merge3Case(0, 2, 1);
00116   Merge3Case(2, 1, 0);
00117 
00118  finish:
00119   *f0   = from0;
00120   *f1   = from1;
00121   *f2   = from2;
00122 }
00123 
00124 
00125 <span class="comment">// merge sz element from the three sentinel terminated input</span>
00126 <span class="comment">// sequences *f0, *f1, *f2 and *f3 to "to"</span>
00127 <span class="comment">// advance *f0, *f1, *f2 and *f3 accordingly.</span>
00128 <span class="comment">// require: at least sz nonsentinel elements available in f0, f1, f2 and f2</span>
00129 <span class="comment">// require: to may overwrite one of the sources as long as</span>
00130 <span class="comment">//   *fx + sz is before the end of fx</span>
00131 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Value_, <span class="keyword">class</span> Cmp_&gt;
00132 <span class="keywordtype">void</span> merge4(
00133            Value_ **f0,
00134            Value_ **f1,
00135            Value_ **f2,
00136            Value_ **f3,
00137            Value_  *to, <span class="keywordtype">int</span> sz, Cmp_ cmp) 
00138 {
00139   Value_ *from0   = *f0;
00140   Value_ *from1   = *f1;
00141   Value_ *from2   = *f2;
00142   Value_ *from3   = *f3;
00143   Value_ *done    = to + sz;
00144 
00145 <span class="preprocessor">#define StartMerge4(a, b, c, d)\</span>
00146 <span class="preprocessor">  if ( (!cmp(*from##a ,*from##b )) &amp;&amp; (!cmp(*from##b ,*from##c )) &amp;&amp; (!cmp(*from##c ,*from##d )) )\</span>
00147 <span class="preprocessor">    goto s ## a ## b ## c ## d ;</span>
00148 <span class="preprocessor"></span>
00149   <span class="comment">// b&gt;a c&gt;b d&gt;c</span>
00150   <span class="comment">// a&lt;b b&lt;c c&lt;d</span>
00151   <span class="comment">// a&lt;=b b&lt;=c c&lt;=d</span>
00152   <span class="comment">// !(a&gt;b) !(b&gt;c) !(c&gt;d)</span>
00153   
00154   StartMerge4(0, 1, 2, 3);
00155   StartMerge4(1, 2, 3, 0);
00156   StartMerge4(2, 3, 0, 1);
00157   StartMerge4(3, 0, 1, 2);
00158 
00159   StartMerge4(0, 3, 1, 2);
00160   StartMerge4(3, 1, 2, 0);
00161   StartMerge4(1, 2, 0, 3);
00162   StartMerge4(2, 0, 3, 1);
00163 
00164   StartMerge4(0, 2, 3, 1);
00165   StartMerge4(2, 3, 1, 0);
00166   StartMerge4(3, 1, 0, 2);
00167   StartMerge4(1, 0, 2, 3);
00168 
00169   StartMerge4(2, 0, 1, 3);
00170   StartMerge4(0, 1, 3, 2);
00171   StartMerge4(1, 3, 2, 0);
00172   StartMerge4(3, 2, 0, 1);
00173 
00174   StartMerge4(3, 0, 2, 1);
00175   StartMerge4(0, 2, 1, 3);
00176   StartMerge4(2, 1, 3, 0);
00177   StartMerge4(1, 3, 0, 2);
00178 
00179   StartMerge4(1, 0, 3, 2);
00180   StartMerge4(0, 3, 2, 1);
00181   StartMerge4(3, 2, 1, 0);
00182   StartMerge4(2, 1, 0, 3);
00183 
00184 <span class="preprocessor">#define Merge4Case(a, b, c, d)\</span>
00185 <span class="preprocessor">  s ## a ## b ## c ## d:\</span>
00186 <span class="preprocessor">  if (to == done) goto finish;\</span>
00187 <span class="preprocessor">  *to = *from ## a ;\</span>
00188 <span class="preprocessor">  ++to;\</span>
00189 <span class="preprocessor">  ++from ## a ;\</span>
00190 <span class="preprocessor">  if (cmp(*from ## c , *from ## a))\</span>
00191 <span class="preprocessor">  {\</span>
00192 <span class="preprocessor">    if (cmp(*from ## b, *from ## a )) \</span>
00193 <span class="preprocessor">      goto s ## a ## b ## c ## d; \</span>
00194 <span class="preprocessor">    else \</span>
00195 <span class="preprocessor">      goto s ## b ## a ## c ## d; \</span>
00196 <span class="preprocessor">  }\</span>
00197 <span class="preprocessor">  else \</span>
00198 <span class="preprocessor">  {\</span>
00199 <span class="preprocessor">    if (cmp(*from ## d, *from ## a))\</span>
00200 <span class="preprocessor">      goto s ## b ## c ## a ## d; \</span>
00201 <span class="preprocessor">    else \</span>
00202 <span class="preprocessor">      goto s ## b ## c ## d ## a; \</span>
00203 <span class="preprocessor">  }</span>
00204 <span class="preprocessor"></span>  
00205   Merge4Case(0, 1, 2, 3);
00206   Merge4Case(1, 2, 3, 0);
00207   Merge4Case(2, 3, 0, 1);
00208   Merge4Case(3, 0, 1, 2);
00209 
00210   Merge4Case(0, 3, 1, 2);
00211   Merge4Case(3, 1, 2, 0);
00212   Merge4Case(1, 2, 0, 3);
00213   Merge4Case(2, 0, 3, 1);
00214 
00215   Merge4Case(0, 2, 3, 1);
00216   Merge4Case(2, 3, 1, 0);
00217   Merge4Case(3, 1, 0, 2);
00218   Merge4Case(1, 0, 2, 3);
00219 
00220   Merge4Case(2, 0, 1, 3);
00221   Merge4Case(0, 1, 3, 2);
00222   Merge4Case(1, 3, 2, 0);
00223   Merge4Case(3, 2, 0, 1);
00224 
00225   Merge4Case(3, 0, 2, 1);
00226   Merge4Case(0, 2, 1, 3);
00227   Merge4Case(2, 1, 3, 0);
00228   Merge4Case(1, 3, 0, 2);
00229 
00230   Merge4Case(1, 0, 3, 2);
00231   Merge4Case(0, 3, 2, 1);
00232   Merge4Case(3, 2, 1, 0);
00233   Merge4Case(2, 1, 0, 3);
00234 
00235  finish:
00236   *f0   = from0;
00237   *f1   = from1;
00238   *f2   = from2;
00239   *f3   = from3;
00240 }
00241 
00242   
00243   
00244   
00245   
00246   <span class="keyword">template</span> &lt;  <span class="keyword">class </span>BlockType_, 
00247               <span class="keyword">class </span>Cmp_,
00248               <span class="keywordtype">unsigned</span> Arity_,
00249               <span class="keyword">class </span>AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY&gt;
00250   <span class="keyword">class </span>ext_merger
00251   {
00252     <span class="keyword">public</span>:
00253       <span class="keyword">typedef</span> off_t size_type;
00254       <span class="keyword">typedef</span> BlockType_ block_type;
00255       <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00256       <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type value_type;
00257       <span class="keyword">typedef</span> Cmp_ comparator_type;
00258       <span class="keyword">typedef</span> AllocStr_ alloc_strategy;
00259     
00260       <span class="keyword">enum</span> { arity = Arity_ };
00261     
00262     <span class="keyword">protected</span>:
00263       <span class="keyword">struct </span>sequence_type
00264       {
00265         <span class="keywordtype">unsigned</span> current;
00266         block_type * block;
00267         std::list&lt;bid_type&gt; * bids;
00268         sequence_type() {}
00269         sequence_type(<span class="keywordtype">unsigned</span> c,block_type * bl, std::list&lt;bid_type&gt; * bi):
00270           current(c),block(bl),bids(bi) {}
00271         value_type &amp; operator *()
00272         {
00273           <span class="keywordflow">return</span> (*block)[current];
00274         }
00275       };
00276     
00277       <span class="keyword">typedef</span> <span class="keyword">typename</span> std::list&lt;sequence_type&gt;::iterator sequences_iterator;
00278       
00279       <span class="keyword">struct </span>sequence_element
00280       {
00281         value_type value;
00282         sequences_iterator sequence;
00283         sequence_element() {}
00284         sequence_element(<span class="keyword">const</span> value_type &amp; v, <span class="keyword">const</span> sequences_iterator &amp; s):
00285           value(v),sequence(s) {}
00286       };
00287       <span class="keyword">struct </span>sequence_element_comparator
00288       {
00289         <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> sequence_element &amp; a, <span class="keyword">const</span> sequence_element &amp; b)<span class="keyword"> const</span>
00290 <span class="keyword">        </span>{
00291           <span class="keywordflow">return</span> comparator_type()(a.value,b.value);
00292         }
00293       };
00294       
00295       <span class="keywordtype">unsigned</span> nsequences;
00296       size_type nelements;
00297       std::list&lt;sequence_type&gt; sequences;
00298       <span class="comment">//typename std::list&lt;sequence_type&gt;::iterator last_sequence;</span>
00299       std::priority_queue&lt; 
00300                   sequence_element,
00301                   std::vector&lt;sequence_element&gt;,
00302                   sequence_element_comparator&gt; min_elements;
00303       
00304       <a class="code" href="classstxxl_1_1prefetch__pool.html">prefetch_pool&lt;block_type&gt;</a> &amp; p_pool;
00305       <a class="code" href="classstxxl_1_1write__pool.html">write_pool&lt;block_type&gt;</a> &amp; w_pool;
00306     <span class="keyword">public</span>:
00307       ext_merger( <a class="code" href="classstxxl_1_1prefetch__pool.html">prefetch_pool&lt;block_type&gt;</a> &amp; p_pool_,
00308                   <a class="code" href="classstxxl_1_1write__pool.html">write_pool&lt;block_type&gt;</a> &amp; w_pool_):
00309                       nsequences(0),nelements(0),
00310                       p_pool(p_pool_),
00311                       w_pool(w_pool_)
00312       {
00313         STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::ext_merger(...)"</span>)
00314       }
00315       <span class="keywordtype">unsigned</span> mem_cons() <span class="keyword">const</span> <span class="comment">// only raugh estimation</span>
00316       {
00317         <span class="keywordflow">return</span> (nsequences * block_type::raw_size);
00318       }
00319       <span class="keyword">virtual</span> ~ext_merger()
00320       {
00321         STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::~ext_merger()"</span>)
00322         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * bm = block_manager::get_instance();
00323         sequences_iterator i = sequences.begin();
00324         <span class="keywordflow">for</span>(;i!=sequences.end();i++)
00325         {
00326           bm-&gt;<a class="code" href="group__mnglayer.html#a17">delete_blocks</a>(i-&gt;bids-&gt;begin(),i-&gt;bids-&gt;end());
00327           <span class="keyword">delete</span> i-&gt;block;
00328           <span class="keyword">delete</span> i-&gt;bids;
00329         }
00330       }
00331       <span class="keyword">template</span> &lt;<span class="keyword">class</span> OutputIterator&gt;
00332       <span class="keywordtype">void</span> multi_merge(OutputIterator begin, OutputIterator end)
00333       {
00334         STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::multi_merge(...)"</span>)
00335         <span class="keywordflow">while</span>(begin != end)
00336         {
00337           assert(nelements);
00338           assert(nsequences);
00339           assert(!min_elements.empty());
00340           
00341           sequence_element m = min_elements.top();
00342           min_elements.pop();
00343           STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::multi_merge(...) extracting value: "</span> &lt;&lt; m.value)
00344           *begin = m.value;
00345           ++begin;
00346           --nelements;
00347           sequence_type &amp; s = *(m.sequence);
00348           ++(s.current);
00349           <span class="keywordflow">if</span>(s.current == s.block-&gt;size )
00350           {
00351             STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::multi_merge(...) crossing block border "</span>)
00352             <span class="comment">// go to the next block</span>
00353             <span class="keywordflow">if</span>(s.bids-&gt;empty()) <span class="comment">// if there is no next block</span>
00354             {
00355               STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::multi_merge(...) it was the last block in the sequence "</span>)
00356               --nsequences;
00357               <span class="keyword">delete</span> s.bids;
00358               <span class="keyword">delete</span> s.block;
00359               sequences.erase(m.sequence);
00360               <span class="keywordflow">continue</span>;
00361             }
00362             <span class="keywordflow">else</span>
00363             {
00364               STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::multi_merge(...) there is another block "</span>)
00365               bid_type bid = s.bids-&gt;front();
00366               s.bids-&gt;pop_front();
00367               <span class="keywordflow">if</span>(!(s.bids-&gt;empty()))
00368               {
00369                 STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::multi_merge(...) one more block exists in a sequence: "</span>&lt;&lt;
00370                 <span class="stringliteral">"flushing this block in write cache (if not written yet) and giving hint to prefetcher"</span>)
00371                 bid_type next_bid = s.bids-&gt;front();<span class="comment">/*</span>
00372 <span class="comment">                request_ptr r = w_pool.get_request(next_bid);</span>
00373 <span class="comment">                if(r.valid()) </span>
00374 <span class="comment">                {</span>
00375 <span class="comment">                  STXXL_VERBOSE2("ext_merger::multi_merge(...) block was in write pool: "&lt;&lt;</span>
00376 <span class="comment">                    ((r-&gt;poll())?"already written":"not yet written") )</span>
00377 <span class="comment">                  r-&gt;wait();</span>
00378 <span class="comment">                }</span>
00379 <span class="comment">                else</span>
00380 <span class="comment">                {</span>
00381 <span class="comment">                  STXXL_VERBOSE2("ext_merger::multi_merge(...) block was not in write pool ")</span>
00382 <span class="comment">                }</span>
00383 <span class="comment">                p_pool.hint(next_bid);*/</span>
00384                 p_pool.hint(next_bid,w_pool);
00385               }
00386               p_pool.read(s.block,bid)-&gt;wait();
00387               block_manager::get_instance()-&gt;delete_block(bid);
00388               s.current = 0;
00389             }
00390           }
00391           m.value = *s;
00392           min_elements.push(m);
00393         }
00394       }
00395       <span class="keywordtype">bool</span> spaceIsAvailable()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nsequences &lt; arity; }
00396       
00397       <span class="keyword">template</span> &lt;<span class="keyword">class</span> Merger&gt;
00398       <span class="keywordtype">void</span> insert_segment(Merger &amp; another_merger, size_type segment_size)
00399       {
00400         STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::insert_segment(merger,...)"</span>)
00401         assert(segment_size);
00402         <span class="keywordtype">unsigned</span> nblocks = segment_size / block_type::size; 
00403         STXXL_VERBOSE2(<span class="stringliteral">"ext_merger::insert_segment(merger,...) inserting segment with "</span>&lt;&lt;nblocks&lt;&lt;<span class="stringliteral">" blocks"</span>)
00404         <span class="comment">//assert(nblocks); // at least one block</span>
00405                 STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment nblocks="</span>&lt;&lt;nblocks)
00406         <span class="keywordflow">if</span>(nblocks == 0)
00407         {
00408           STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment(merger,...) WARNING: inserting a segment with "</span>&lt;&lt;
00409             nblocks&lt;&lt;<span class="stringliteral">" blocks"</span>)
00410           STXXL_VERBOSE1(<span class="stringliteral">"THIS IS INEFFICIENT: TRY TO CHANGE PRIORITY QUEUE PARAMETERS"</span>)
00411         }
00412         <span class="keywordtype">unsigned</span> first_size = segment_size % block_type::size;
00413         <span class="keywordflow">if</span>(first_size == 0)
00414         {
00415           first_size = block_type::size;
00416           --nblocks;
00417         }
00418         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * bm = block_manager::get_instance();
00419         std::list&lt;bid_type&gt; * bids = <span class="keyword">new</span> std::list&lt;bid_type&gt;(nblocks);
00420         bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(alloc_strategy(),bids-&gt;begin(),bids-&gt;end());
00421         block_type * first_block = <span class="keyword">new</span> block_type;
00422         another_merger.multi_merge(
00423             first_block-&gt;begin() + (block_type::size - first_size), 
00424             first_block-&gt;end());
00425         <span class="comment">/*</span>
00426 <span class="comment">        if(w_pool.size() &lt; nblocks)</span>
00427 <span class="comment">        {</span>
00428 <span class="comment">          STXXL_MSG("ext_merger::insert_segment write pool is too small: "&lt;&lt;</span>
00429 <span class="comment">            w_pool.size()&lt;&lt;" blocks, resizing to "&lt;&lt;nblocks)</span>
00430 <span class="comment">          w_pool.resize(nblocks);</span>
00431 <span class="comment">        }*/</span>
00432         assert(w_pool.size() &gt; 0);
00433         
00434         <span class="keyword">typename</span> std::list&lt;bid_type&gt;::iterator curbid = bids-&gt;begin();
00435         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;nblocks;i++,curbid++)
00436         {
00437           block_type *b = w_pool.steal();
00438           another_merger.multi_merge(b-&gt;begin(),b-&gt;end());
00439           w_pool.write(b,*curbid);
00440         }
00441         
00442         insert_segment(bids,first_block,first_size);
00443       }
00444       size_type  size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nelements; }
00445       
00446  <span class="keyword">protected</span>:
00449       <span class="keywordtype">void</span> insert_segment(std::list&lt;bid_type&gt; * segment, block_type * first_block, <span class="keywordtype">unsigned</span> first_size)
00450       {
00451         STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment(segment_bids,...) "</span>&lt;&lt;<span class="keyword">this</span>)
00452         assert(first_size);
00453         ++nsequences;
00454         nelements += size_type(segment-&gt;size())*block_type::size + first_size;
00455         <span class="comment">// assert(nsequences &lt;= arity);</span>
00456         <span class="keywordflow">if</span>(nsequences&gt;arity)
00457         {
00458           STXXL_VERBOSE1(<span class="stringliteral">"ext_merger::insert_segment(..) "</span>
00459                   <span class="stringliteral">"INSERTING SEGMENT OVER CAPACITY, CAPACITY:"</span>&lt;&lt;arity&lt;&lt;<span class="stringliteral">" SEQUENCES: "</span>&lt;&lt;nsequences)
00460         }
00461         sequence_type new_sequence;
00462         new_sequence.current = block_type::size - first_size;
00463         new_sequence.block = first_block;
00464         new_sequence.bids = segment;
00465         sequences.push_front(new_sequence);
00466         min_elements.push(sequence_element(*new_sequence,sequences.begin()));
00467         <span class="comment">//last_sequence = sequences.begin();</span>
00468       }
00469   };
00470   
00471   
00473 <span class="comment">// The data structure from Knuth, "Sorting and Searching", Section 5.4.1</span>
00474 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00475 <span class="keyword">class </span>looser_tree
00476 {
00477 <span class="keyword">public</span>:
00478   <span class="keyword">typedef</span> ValTp_ value_type;
00479   <span class="keyword">typedef</span> Cmp_ comparator_type;
00480   <span class="keyword">typedef</span> value_type Element;
00481   
00482 <span class="keyword">private</span>:
00483   <span class="keyword">struct </span>Entry 
00484   {
00485     value_type key;   <span class="comment">// Key of Looser element (winner for 0)</span>
00486     <span class="keywordtype">int</span> index;        <span class="comment">// number of loosing segment</span>
00487   };
00488 
00489   comparator_type cmp;
00490   <span class="comment">// stack of empty segments</span>
00491   <span class="keywordtype">int</span> empty[KNKMAX]; <span class="comment">// indices of empty segments</span>
00492   <span class="keywordtype">int</span> lastFree;  <span class="comment">// where in "empty" is the last valid entry?</span>
00493 
00494   <span class="keywordtype">unsigned</span> size_; <span class="comment">// total number of elements stored</span>
00495   <span class="keywordtype">unsigned</span> logK; <span class="comment">// log of current tree size</span>
00496   <span class="keywordtype">unsigned</span> k; <span class="comment">// invariant k = 1 &lt;&lt; logK</span>
00497 
00498   Element dummy; <span class="comment">// target of empty segment pointers</span>
00499 
00500   <span class="comment">// upper levels of looser trees</span>
00501   <span class="comment">// entry[0] contains the winner info</span>
00502   Entry entry[KNKMAX]; 
00503 
00504   <span class="comment">// leaf information</span>
00505   <span class="comment">// note that Knuth uses indices k..k-1</span>
00506   <span class="comment">// while we use 0..k-1</span>
00507   Element *current[KNKMAX]; <span class="comment">// pointer to actual element</span>
00508   Element *segment[KNKMAX]; <span class="comment">// start of Segments</span>
00509   <span class="keywordtype">unsigned</span> segment_size[KNKMAX];
00510 
00511   <span class="keywordtype">unsigned</span> mem_cons_;
00512   
00513   <span class="comment">// private member functions</span>
00514   <span class="keywordtype">int</span> initWinner(<span class="keywordtype">int</span> root);
00515   <span class="keywordtype">void</span> updateOnInsert(<span class="keywordtype">int</span> node, <span class="keyword">const</span> Element &amp; newKey, <span class="keywordtype">int</span> newIndex, 
00516                       Element * winnerKey, <span class="keywordtype">int</span> * winnerIndex, <span class="keywordtype">int</span> * mask);
00517   <span class="keywordtype">void</span> deallocateSegment(<span class="keywordtype">int</span> index);
00518   <span class="keywordtype">void</span> doubleK();
00519   <span class="keywordtype">void</span> compactTree();
00520   <span class="keywordtype">void</span> rebuildLooserTree();
00521   <span class="keywordtype">bool</span> segmentIsEmpty(<span class="keywordtype">int</span> i);
00522   <span class="keywordtype">void</span> multi_merge_k(Element * to, <span class="keywordtype">int</span> l);
00523   <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> LogK&gt;
00524   <span class="keywordtype">void</span> multi_merge_f(Element *to, <span class="keywordtype">int</span> l)
00525   {
00526     <span class="comment">//Entry *currentPos;</span>
00527     <span class="comment">//Element currentKey;</span>
00528     <span class="comment">//int currentIndex; // leaf pointed to by current entry</span>
00529     Element *done = to + l;
00530     Entry    *regEntry   = entry;
00531     Element **regCurrent = current;
00532     <span class="keywordtype">int</span>      winnerIndex = regEntry[0].index;
00533     Element  winnerKey   = regEntry[0].key;
00534     Element *winnerPos;
00535     <span class="comment">//Element sup = dummy; // supremum</span>
00536     
00537     assert(logK &gt;= LogK);
00538     <span class="keywordflow">while</span> (to != done)
00539     {
00540       winnerPos = regCurrent[winnerIndex];
00541       
00542       <span class="comment">// write result</span>
00543       *to   = winnerKey;
00544       
00545       <span class="comment">// advance winner segment</span>
00546       ++winnerPos;
00547       regCurrent[winnerIndex] = winnerPos;
00548       winnerKey = *winnerPos;
00549       
00550       <span class="comment">// remove winner segment if empty now</span>
00551       <span class="keywordflow">if</span> (is_sentinel(winnerKey))
00552       { 
00553         deallocateSegment(winnerIndex); 
00554       } 
00555       ++to;
00556       
00557       <span class="comment">// update looser tree</span>
00558 <span class="preprocessor">#define TreeStep(L)\</span>
00559 <span class="preprocessor">      if (1 &lt;&lt; LogK &gt;= 1 &lt;&lt; L) {\</span>
00560 <span class="preprocessor">        Entry  *pos##L = regEntry+((winnerIndex+(1&lt;&lt;LogK)) &gt;&gt; (((int(LogK-L)+1)&gt;=0)?((LogK-L)+1):0));\</span>
00561 <span class="preprocessor">        Element key##L = pos##L-&gt;key;\</span>
00562 <span class="preprocessor">        if (cmp(winnerKey,key##L)) {\</span>
00563 <span class="preprocessor">          int index##L  = pos##L-&gt;index;\</span>
00564 <span class="preprocessor">          pos##L-&gt;key   = winnerKey;\</span>
00565 <span class="preprocessor">          pos##L-&gt;index = winnerIndex;\</span>
00566 <span class="preprocessor">          winnerKey     = key##L;\</span>
00567 <span class="preprocessor">          winnerIndex   = index##L;\</span>
00568 <span class="preprocessor">        }\</span>
00569 <span class="preprocessor">      }</span>
00570 <span class="preprocessor"></span>      TreeStep(10);
00571       TreeStep(9);
00572       TreeStep(8);
00573       TreeStep(7);
00574       TreeStep(6);
00575       TreeStep(5);
00576       TreeStep(4);
00577       TreeStep(3);
00578       TreeStep(2);
00579       TreeStep(1);
00580 <span class="preprocessor">#undef TreeStep      </span>
00581 <span class="preprocessor"></span>    }
00582     regEntry[0].index = winnerIndex;
00583     regEntry[0].key   = winnerKey;  
00584   }
00585   
00586   <span class="keywordtype">bool</span> is_sentinel(<span class="keyword">const</span> Element &amp; a)
00587   {
00588     <span class="keywordflow">return</span> !(cmp(cmp.min_value(),a));
00589   }
00590   <span class="keywordtype">bool</span> not_sentinel(<span class="keyword">const</span> Element &amp; a)
00591   {
00592     <span class="keywordflow">return</span> cmp(cmp.min_value(),a);
00593   }
00594 <span class="keyword">public</span>:
00595   looser_tree();
00596   ~looser_tree();
00597   <span class="keywordtype">void</span> init(); 
00598 
00599   <span class="keywordtype">void</span> multi_merge(Element * begin, Element * end)
00600   {
00601     multi_merge(begin,end-begin);
00602   }
00603   <span class="keywordtype">void</span> multi_merge(Element *, <span class="keywordtype">unsigned</span> l);
00604   
00605   <span class="keywordtype">unsigned</span> mem_cons()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mem_cons_; }
00606   <span class="keywordtype">bool</span>  spaceIsAvailable() <span class="comment">// for new segment</span>
00607   { <span class="keywordflow">return</span> k &lt; KNKMAX || lastFree &gt;= 0; } 
00608      
00609   <span class="keywordtype">void</span> insert_segment(Element *to, <span class="keywordtype">unsigned</span> sz); <span class="comment">// insert segment beginning at to</span>
00610   <span class="keywordtype">unsigned</span>  size() { <span class="keywordflow">return</span> size_; }
00611 };  
00612 
00614 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00615 looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::looser_tree() : lastFree(0), size_(0), logK(0), k(1),mem_cons_(0)
00616 {
00617   empty  [0] = 0;
00618   segment[0] = 0;
00619   current[0] = &amp;dummy;
00620   <span class="comment">// entry and dummy are initialized by init</span>
00621   <span class="comment">// since they need the value of supremum</span>
00622   init();
00623 }
00624 
00625 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00626 <span class="keywordtype">void</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::init()
00627 {
00628   dummy      = cmp.min_value();
00629   rebuildLooserTree();
00630   assert(current[entry[0].index] == &amp;dummy);
00631 }
00632 
00633 
00634 <span class="comment">// rebuild looser tree information from the values in current</span>
00635 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00636 <span class="keywordtype">void</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::rebuildLooserTree()
00637 {  
00638   <span class="keywordtype">int</span> winner = initWinner(1);
00639   entry[0].index = winner;
00640   entry[0].key   = *(current[winner]);
00641 }
00642 
00643 
00644 <span class="comment">// given any values in the leaves this</span>
00645 <span class="comment">// routing recomputes upper levels of the tree</span>
00646 <span class="comment">// from scratch in linear time</span>
00647 <span class="comment">// initialize entry[root].index and the subtree rooted there</span>
00648 <span class="comment">// return winner index</span>
00649 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00650 <span class="keywordtype">int</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::initWinner(<span class="keywordtype">int</span> root)
00651 {
00652   <span class="keywordflow">if</span> (root &gt;= int(k)) { <span class="comment">// leaf reached</span>
00653     <span class="keywordflow">return</span> root - k;
00654   } <span class="keywordflow">else</span> {
00655     <span class="keywordtype">int</span> left  = initWinner(2*root    );
00656     <span class="keywordtype">int</span> right = initWinner(2*root + 1);
00657     Element lk    = *(current[left ]);
00658     Element rk    = *(current[right]);
00659     <span class="keywordflow">if</span> (!(cmp(lk,rk))) { <span class="comment">// right subtree looses</span>
00660       entry[root].index = right;
00661       entry[root].key   = rk;
00662       <span class="keywordflow">return</span> left;
00663     } <span class="keywordflow">else</span> {
00664       entry[root].index = left;
00665       entry[root].key   = lk;
00666       <span class="keywordflow">return</span> right;
00667     }
00668   }
00669 }
00670 
00671 
00672 <span class="comment">// first go up the tree all the way to the root</span>
00673 <span class="comment">// hand down old winner for the respective subtree</span>
00674 <span class="comment">// based on new value, and old winner and looser </span>
00675 <span class="comment">// update each node on the path to the root top down.</span>
00676 <span class="comment">// This is implemented recursively</span>
00677 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00678 <span class="keywordtype">void</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::updateOnInsert(
00679                <span class="keywordtype">int</span> node, 
00680                <span class="keyword">const</span> Element  &amp; newKey, 
00681                <span class="keywordtype">int</span>      newIndex, 
00682                Element *winnerKey, 
00683                <span class="keywordtype">int</span> *winnerIndex, <span class="comment">// old winner</span>
00684                <span class="keywordtype">int</span> *mask) <span class="comment">// 1 &lt;&lt; (ceil(log KNK) - dist-from-root)</span>
00685 {
00686   <span class="keywordflow">if</span> (node == 0) { <span class="comment">// winner part of root</span>
00687     *mask = 1 &lt;&lt; (logK - 1);    
00688     *winnerKey   = entry[0].key;
00689     *winnerIndex = entry[0].index;
00690     <span class="keywordflow">if</span> (cmp(entry[node].key,newKey)) 
00691     {
00692       entry[node].key   = newKey;
00693       entry[node].index = newIndex;
00694     }
00695   } <span class="keywordflow">else</span> {
00696     updateOnInsert(node &gt;&gt; 1, newKey, newIndex, winnerKey, winnerIndex, mask);
00697     Element looserKey   = entry[node].key;
00698     <span class="keywordtype">int</span> looserIndex = entry[node].index;
00699     <span class="keywordflow">if</span> ((*winnerIndex &amp; *mask) != (newIndex &amp; *mask)) { <span class="comment">// different subtrees</span>
00700       <span class="keywordflow">if</span> (cmp(looserKey,newKey)) { <span class="comment">// newKey will have influence here</span>
00701         <span class="keywordflow">if</span> (cmp(*winnerKey,newKey) ) { <span class="comment">// old winner loses here</span>
00702           entry[node].key   = *winnerKey;
00703           entry[node].index = *winnerIndex;
00704         } <span class="keywordflow">else</span> { <span class="comment">// new entry looses here</span>
00705           entry[node].key   = newKey;
00706           entry[node].index = newIndex;
00707         }
00708       } 
00709       *winnerKey   = looserKey;
00710       *winnerIndex = looserIndex;
00711     }
00712     <span class="comment">// note that nothing needs to be done if</span>
00713     <span class="comment">// the winner came from the same subtree</span>
00714     <span class="comment">// a) newKey &lt;= winnerKey =&gt; even more reason for the other tree to loose</span>
00715     <span class="comment">// b) newKey &gt;  winnerKey =&gt; the old winner will beat the new</span>
00716     <span class="comment">//                           entry further down the tree</span>
00717     <span class="comment">// also the same old winner is handed down the tree</span>
00718 
00719     *mask &gt;&gt;= 1; <span class="comment">// next level</span>
00720   }
00721 }
00722 
00723 
00724 <span class="comment">// make the tree two times as wide</span>
00725 <span class="comment">// may only be called if no free slots are left ?? necessary ??</span>
00726 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00727 <span class="keywordtype">void</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::doubleK()
00728 {
00729   <span class="comment">// make all new entries empty</span>
00730   <span class="comment">// and push them on the free stack</span>
00731   assert(lastFree == -1); <span class="comment">// stack was empty (probably not needed)</span>
00732   assert(k &lt; KNKMAX);
00733   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 2*k - 1;  i &gt;= int(k);  i--)
00734   {
00735     current[i] = &amp;dummy;
00736     segment[i] = NULL;
00737     lastFree++;
00738     empty[lastFree] = i;
00739   }
00740 
00741   <span class="comment">// double the size</span>
00742   k *= 2;  logK++;
00743 
00744   <span class="comment">// recompute looser tree information</span>
00745   rebuildLooserTree();
00746 }
00747 
00748 
00749 <span class="comment">// compact nonempty segments in the left half of the tree</span>
00750 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00751 <span class="keywordtype">void</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::compactTree()
00752 {
00753   assert(logK &gt; 0);
00754 
00755   <span class="comment">// compact all nonempty segments to the left</span>
00756   <span class="keywordtype">int</span> from = 0;
00757   <span class="keywordtype">int</span> to   = 0;
00758   <span class="keywordflow">for</span>(;  from &lt; int(k);  from++)
00759   {
00760     <span class="keywordflow">if</span> (not_sentinel(*(current[from])))
00761     {
00762       segment_size[to] = segment_size[from];
00763       current[to] = current[from];
00764       segment[to] = segment[from];
00765       to++;
00766     }<span class="comment">/*</span>
00767 <span class="comment">    else</span>
00768 <span class="comment">    {</span>
00769 <span class="comment">      if(segment[from])</span>
00770 <span class="comment">      {</span>
00771 <span class="comment">        STXXL_VERBOSE2("looser_tree::compactTree() deleting segment "&lt;&lt;from&lt;&lt;</span>
00772 <span class="comment">                                        " address: "&lt;&lt;segment[from]&lt;&lt;" size: "&lt;&lt;segment_size[from])</span>
00773 <span class="comment">        delete [] segment[from];</span>
00774 <span class="comment">        segment[from] = 0;</span>
00775 <span class="comment">        mem_cons_ -= segment_size[from];</span>
00776 <span class="comment">      }</span>
00777 <span class="comment">    }*/</span>
00778   }
00779 
00780   <span class="comment">// half degree as often as possible</span>
00781   <span class="keywordflow">while</span> (to &lt; int(k/2)) {
00782     k /= 2;  logK--;
00783   }
00784 
00785   <span class="comment">// overwrite garbage and compact the stack of empty segments</span>
00786   lastFree = -1; <span class="comment">// none free</span>
00787   <span class="keywordflow">for</span> (;  to &lt; int(k);  to++) {
00788     <span class="comment">// push </span>
00789     lastFree++;
00790     empty[lastFree] = to;
00791 
00792     current[to] = &amp;dummy;
00793   }
00794 
00795   <span class="comment">// recompute looser tree information</span>
00796   rebuildLooserTree();
00797 }
00798 
00799 
00800 <span class="comment">// insert segment beginning at to</span>
00801 <span class="comment">// require: spaceIsAvailable() == 1 </span>
00802 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00803 <span class="keywordtype">void</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::insert_segment(Element *to, <span class="keywordtype">unsigned</span> sz)
00804 {
00805   STXXL_VERBOSE2(<span class="stringliteral">"looser_tree::insert_segment("</span>&lt;&lt; to &lt;&lt;<span class="stringliteral">","</span>&lt;&lt; sz&lt;&lt;<span class="stringliteral">")"</span>)
00806   <span class="comment">//std::copy(to,to + sz,std::ostream_iterator&lt;ValTp_&gt;(std::cout, "\n"));</span>
00807   
00808   <span class="keywordflow">if</span> (sz &gt; 0)
00809   {
00810     assert( not_sentinel(to[0])   );
00811     assert( not_sentinel(to[sz-1]));
00812     <span class="comment">// get a free slot</span>
00813     <span class="keywordflow">if</span> (lastFree &lt; 0) { <span class="comment">// tree is too small</span>
00814       doubleK();
00815     }
00816     <span class="keywordtype">int</span> index = empty[lastFree];
00817     lastFree--; <span class="comment">// pop</span>
00818 
00819 
00820     <span class="comment">// link new segment</span>
00821     current[index] = segment[index] = to;
00822     segment_size[index] = (sz + 1)*<span class="keyword">sizeof</span>(value_type);
00823     mem_cons_ += (sz + 1)*<span class="keyword">sizeof</span>(value_type);
00824     size_ += sz;
00825      
00826     <span class="comment">// propagate new information up the tree</span>
00827     Element dummyKey;
00828     <span class="keywordtype">int</span> dummyIndex;
00829     <span class="keywordtype">int</span> dummyMask;
00830     updateOnInsert((index + k) &gt;&gt; 1, *to, index, 
00831                    &amp;dummyKey, &amp;dummyIndex, &amp;dummyMask);
00832   } <span class="keywordflow">else</span> {
00833     <span class="comment">// immediately deallocate</span>
00834     <span class="comment">// this is not only an optimization </span>
00835     <span class="comment">// but also needed to keep empty segments from</span>
00836     <span class="comment">// clogging up the tree</span>
00837     <span class="keyword">delete</span> [] to; 
00838   }
00839 }
00840 
00841 
00842 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00843 looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::~looser_tree()
00844 {
00845   STXXL_VERBOSE2(<span class="stringliteral">"looser_tree::~looser_tree()"</span>)
00846   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;k;++i)
00847   {
00848     <span class="keywordflow">if</span>(segment[i])
00849     {
00850       STXXL_VERBOSE2(<span class="stringliteral">"looser_tree::~looser_tree() deleting segment "</span>&lt;&lt;i)
00851       <span class="keyword">delete</span> [] segment[i];
00852       mem_cons_ -= segment_size[i];
00853     }
00854   }
00855   <span class="comment">// check whether we did not loose memory</span>
00856   assert(mem_cons_ == 0);
00857 }
00858 
00859 <span class="comment">// free an empty segment .</span>
00860 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00861 <span class="keywordtype">void</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::deallocateSegment(<span class="keywordtype">int</span> index)
00862 {
00863   <span class="comment">// reroute current pointer to some empty dummy segment</span>
00864   <span class="comment">// with a sentinel key</span>
00865         STXXL_VERBOSE2(<span class="stringliteral">"looser_tree::deallocateSegment() deleting segment "</span>&lt;&lt;
00866                 index&lt;&lt;<span class="stringliteral">" address: "</span>&lt;&lt;segment[index]&lt;&lt;<span class="stringliteral">" size: "</span>&lt;&lt;segment_size[index])
00867   current[index] = &amp;dummy;
00868 
00869   <span class="comment">// free memory</span>
00870   <span class="keyword">delete</span> [] segment[index];
00871   segment[index] = 0;
00872   mem_cons_ -= segment_size[index];
00873   
00874   <span class="comment">// push on the stack of free segment indices</span>
00875   lastFree++;
00876   empty[lastFree] = index;
00877 }
00878 
00879 
00880 <span class="comment">// delete the l smallest elements and write them to "to"</span>
00881 <span class="comment">// empty segments are deallocated</span>
00882 <span class="comment">// require:</span>
00883 <span class="comment">// - there are at least l elements</span>
00884 <span class="comment">// - segments are ended by sentinels</span>
00885 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00886 <span class="keywordtype">void</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::multi_merge(Element *to, <span class="keywordtype">unsigned</span> l)
00887 {
00888   STXXL_VERBOSE3(<span class="stringliteral">"looser_tree::multi_merge("</span>&lt;&lt; to &lt;&lt;<span class="stringliteral">","</span>&lt;&lt; l&lt;&lt;<span class="stringliteral">")"</span>)
00889   
00890   <span class="comment">/*</span>
00891 <span class="comment">  multi_merge_k(to,l);</span>
00892 <span class="comment">  */</span>
00893   <span class="keywordflow">switch</span>(logK) {
00894   <span class="keywordflow">case</span> 0: 
00895     assert(k == 1);
00896     assert(entry[0].index == 0);
00897     assert(lastFree == -1 || l == 0);
00898     <span class="comment">//memcpy(to, current[0], l * sizeof(Element));</span>
00899     std::copy(current[0],current[0]+l,to);
00900     current[0] += l;
00901     entry[0].key = **current;
00902     <span class="keywordflow">if</span> (segmentIsEmpty(0)) deallocateSegment(0); 
00903     <span class="keywordflow">break</span>;
00904   <span class="keywordflow">case</span> 1:
00905     assert(k == 2);
00906     merge(current + 0, current + 1, to, l,cmp);
00907     rebuildLooserTree();
00908     <span class="keywordflow">if</span> (segmentIsEmpty(0)) deallocateSegment(0); 
00909     <span class="keywordflow">if</span> (segmentIsEmpty(1)) deallocateSegment(1); 
00910     <span class="keywordflow">break</span>;
00911   <span class="keywordflow">case</span> 2:
00912     assert(k == 4);
00913     merge4(current + 0, current + 1, current + 2, current + 3, to, l,cmp);
00914     rebuildLooserTree();
00915     <span class="keywordflow">if</span> (segmentIsEmpty(0)) deallocateSegment(0); 
00916     <span class="keywordflow">if</span> (segmentIsEmpty(1)) deallocateSegment(1); 
00917     <span class="keywordflow">if</span> (segmentIsEmpty(2)) deallocateSegment(2); 
00918     <span class="keywordflow">if</span> (segmentIsEmpty(3)) deallocateSegment(3);
00919     <span class="keywordflow">break</span>;
00920   <span class="keywordflow">case</span>  3: multi_merge_f&lt;3&gt;(to, l); <span class="keywordflow">break</span>;
00921   <span class="keywordflow">case</span>  4: multi_merge_f&lt;4&gt;(to, l); <span class="keywordflow">break</span>;
00922   <span class="keywordflow">case</span>  5: multi_merge_f&lt;5&gt;(to, l); <span class="keywordflow">break</span>;
00923   <span class="keywordflow">case</span>  6: multi_merge_f&lt;6&gt;(to, l); <span class="keywordflow">break</span>;
00924   <span class="keywordflow">case</span>  7: multi_merge_f&lt;7&gt;(to, l); <span class="keywordflow">break</span>;
00925   <span class="keywordflow">case</span>  8: multi_merge_f&lt;8&gt;(to, l); <span class="keywordflow">break</span>;
00926   <span class="keywordflow">case</span>  9: multi_merge_f&lt;9&gt;(to, l); <span class="keywordflow">break</span>;
00927   <span class="keywordflow">case</span> 10: multi_merge_f&lt;10&gt;(to, l); <span class="keywordflow">break</span>; 
00928   <span class="keywordflow">default</span>: multi_merge_k(to, l); <span class="keywordflow">break</span>;
00929   }
00930   
00931   
00932   
00933   size_ -= l;
00934 
00935   <span class="comment">// compact tree if it got considerably smaller</span>
00936   <span class="keywordflow">if</span> (k &gt; 1 &amp;&amp; int(lastFree) &gt;= int(3*k/5 - 1) ) { 
00937     <span class="comment">// using k/2 would be worst case inefficient</span>
00938     compactTree(); 
00939   }
00940   <span class="comment">//std::copy(to,to + l,std::ostream_iterator&lt;ValTp_&gt;(std::cout, "\n"));</span>
00941 }
00942 
00943 
00944 <span class="comment">// is this segment empty and does not point to dummy yet?</span>
00945 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00946 <span class="keyword">inline</span> <span class="keywordtype">bool</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::segmentIsEmpty(<span class="keywordtype">int</span> i)
00947 {
00948   <span class="keywordflow">return</span> (is_sentinel(*(current[i])) &amp;&amp;  (current[i] != &amp;dummy));
00949 }
00950 
00951 <span class="comment">// multi-merge for fixed K</span>
00952 <span class="comment">/*</span>
00953 <span class="comment">template &lt;class ValTp_,class Cmp_,unsigned KNKMAX&gt; template &lt;unsigned LogK&gt;</span>
00954 <span class="comment">void looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::multi_merge_f&lt;LogK&gt;(Element *to, int l)</span>
00955 <span class="comment">{</span>
00956 <span class="comment">}</span>
00957 <span class="comment">*/</span>
00958 
00959 <span class="comment">// multi-merge for arbitrary K</span>
00960 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> KNKMAX&gt;
00961 <span class="keywordtype">void</span> looser_tree&lt;ValTp_,Cmp_,KNKMAX&gt;::
00962 multi_merge_k(Element *to, <span class="keywordtype">int</span> l)
00963 {
00964   Entry *currentPos;
00965   Element currentKey;
00966   <span class="keywordtype">int</span> currentIndex; <span class="comment">// leaf pointed to by current entry</span>
00967   <span class="keywordtype">int</span> kReg = k;
00968   Element *done = to + l;
00969   <span class="keywordtype">int</span>      winnerIndex = entry[0].index;
00970   Element  winnerKey   = entry[0].key;
00971   Element *winnerPos;
00972   
00973   <span class="keywordflow">while</span> (to != done)
00974   {
00975     winnerPos = current[winnerIndex];
00976     
00977     <span class="comment">// write result</span>
00978     *to   = winnerKey;
00979 
00980     <span class="comment">// advance winner segment</span>
00981     ++winnerPos;
00982     current[winnerIndex] = winnerPos;
00983     winnerKey = *winnerPos;
00984 
00985     <span class="comment">// remove winner segment if empty now</span>
00986     <span class="keywordflow">if</span> (is_sentinel(winnerKey)) <span class="comment">// </span>
00987       deallocateSegment(winnerIndex); 
00988     
00989     <span class="comment">// go up the entry-tree</span>
00990     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = (winnerIndex + kReg) &gt;&gt; 1;  i &gt; 0;  i &gt;&gt;= 1) {
00991       currentPos = entry + i;
00992       currentKey = currentPos-&gt;key;
00993       <span class="keywordflow">if</span> (cmp(winnerKey,currentKey)) {
00994         currentIndex      = currentPos-&gt;index;
00995         currentPos-&gt;key   = winnerKey;
00996         currentPos-&gt;index = winnerIndex;
00997         winnerKey         = currentKey;
00998         winnerIndex       = currentIndex;
00999       }
01000     }
01001 
01002     ++to;
01003   }
01004   entry[0].index = winnerIndex;
01005   entry[0].key   = winnerKey;  
01006 }
01007 
01008 };
01009 
01010 <span class="comment">/*</span>
01011 <span class="comment"></span>
01012 <span class="comment">KNBufferSize1 = 32; </span>
01013 <span class="comment">KNN = 512; // bandwidth</span>
01014 <span class="comment">KNKMAX = 64;  // maximal arity</span>
01015 <span class="comment">KNLevels = 4; // overall capacity &gt;= KNN*KNKMAX^KNLevels</span>
01016 <span class="comment">LogKNKMAX = 6;  // ceil(log KNK)</span>
01017 <span class="comment">*/</span>
01018 
01019 <span class="comment">// internal memory consumption &gt;= N_*(KMAX_^Levels_) + ext</span>
01020 
01021 <span class="keyword">template</span> &lt;
01022       <span class="keyword">class </span>Tp_,
01023       <span class="keyword">class </span>Cmp_,
01024       <span class="keywordtype">unsigned</span> BufferSize1_ = 32, <span class="comment">// equalize procedure call overheads etc. </span>
01025       <span class="keywordtype">unsigned</span> N_ = 512, <span class="comment">// bandwidth</span>
01026       <span class="keywordtype">unsigned</span> IntKMAX_ = 64, <span class="comment">// maximal arity for internal mergers</span>
01027       <span class="keywordtype">unsigned</span> IntLevels_ = 4, 
01028       <span class="keywordtype">unsigned</span> BlockSize_ = (2*1024*1024),
01029       <span class="keywordtype">unsigned</span> ExtKMAX_ = 64, <span class="comment">// maximal arity for external mergers</span>
01030       <span class="keywordtype">unsigned</span> ExtLevels_ = 2,
01031       <span class="keyword">class </span>AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY
01032       &gt;
01033 <span class="keyword">struct </span>priority_queue_config
01034 {
01035   <span class="keyword">typedef</span> Tp_ value_type;
01036   <span class="keyword">typedef</span> Cmp_ comparator_type;
01037   <span class="keyword">typedef</span> AllocStr_ alloc_strategy_type;
01038   <span class="keyword">enum</span>
01039   {
01040     BufferSize1 = BufferSize1_,
01041     N = N_,
01042     IntKMAX = IntKMAX_,
01043     IntLevels = IntLevels_,
01044     ExtLevels = ExtLevels_,
01045     BlockSize = BlockSize_,
01046     ExtKMAX = ExtKMAX_,
01047   };
01048 };
01049 
01051 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l01052"></a><a class="code" href="classstxxl_1_1priority__queue.html">01052</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1priority__queue.html">priority_queue</a>
01053 {
01054 <span class="keyword">public</span>:
01055   <span class="keyword">typedef</span> Config_ Config;
01056   <span class="keyword">enum</span>
01057   {
01058     BufferSize1 = Config::BufferSize1,
01059     N = Config::N,
01060     IntKMAX = Config::IntKMAX,
01061     IntLevels = Config::IntLevels,
01062     ExtLevels = Config::ExtLevels,
01063     Levels = Config::IntLevels + Config::ExtLevels,
01064     BlockSize = Config::BlockSize,
01065     ExtKMAX = Config::ExtKMAX
01066   };
01067   
<a name="l01069"></a><a class="code" href="classstxxl_1_1priority__queue.html#w1">01069</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::value_type <a class="code" href="classstxxl_1_1priority__queue.html#w1">value_type</a>;
<a name="l01071"></a><a class="code" href="classstxxl_1_1priority__queue.html#w2">01071</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::comparator_type <a class="code" href="classstxxl_1_1priority__queue.html#w2">comparator_type</a>;
01072   <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::alloc_strategy_type alloc_strategy_type; 
<a name="l01074"></a><a class="code" href="classstxxl_1_1priority__queue.html#w4">01074</a>   <span class="keyword">typedef</span> off_t <a class="code" href="classstxxl_1_1priority__queue.html#w4">size_type</a>;
01075   <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;BlockSize,value_type&gt;</a> <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>;
01076   
01077   
01078 <span class="keyword">protected</span>:
01079   
01080   <span class="keyword">typedef</span> std::priority_queue&lt;value_type,std::vector&lt;value_type&gt;,<a class="code" href="classstxxl_1_1priority__queue.html#w2">comparator_type</a>&gt; 
01081                       insert_heap_type;
01082   
01083   <span class="keyword">typedef</span> priority_queue_local::looser_tree&lt;
01084             <a class="code" href="classstxxl_1_1priority__queue.html#w1">value_type</a>,
01085             <a class="code" href="classstxxl_1_1priority__queue.html#w2">comparator_type</a>,
01086             IntKMAX&gt;  int_merger_type;
01087   
01088   <span class="keyword">typedef</span> priority_queue_local::ext_merger&lt;
01089             <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>,
01090             <a class="code" href="classstxxl_1_1priority__queue.html#w2">comparator_type</a>,
01091             ExtKMAX,
01092             alloc_strategy_type&gt;   ext_merger_type;
01093 
01094   
01095   int_merger_type itree[IntLevels];
01096   <a class="code" href="classstxxl_1_1prefetch__pool.html">prefetch_pool&lt;block_type&gt;</a> &amp; p_pool;
01097   <a class="code" href="classstxxl_1_1write__pool.html">write_pool&lt;block_type&gt;</a>    &amp; w_pool;
01098   ext_merger_type * etree;
01099 
01100   <span class="comment">// one delete buffer for each tree (extra space for sentinel)</span>
01101   <a class="code" href="classstxxl_1_1priority__queue.html#w1">value_type</a>   buffer2[Levels][N + 1]; <span class="comment">// tree-&gt;buffer2-&gt;buffer1</span>
01102   <a class="code" href="classstxxl_1_1priority__queue.html#w1">value_type</a> * minBuffer2[Levels];
01103 
01104   <span class="comment">// overall delete buffer</span>
01105   <a class="code" href="classstxxl_1_1priority__queue.html#w1">value_type</a>   buffer1[BufferSize1 + 1];
01106   <a class="code" href="classstxxl_1_1priority__queue.html#w1">value_type</a> * minBuffer1;
01107 
01108   <a class="code" href="classstxxl_1_1priority__queue.html#w2">comparator_type</a> cmp;
01109   
01110   <span class="comment">// insert buffer</span>
01111   insert_heap_type insertHeap;
01112 
01113   <span class="comment">// how many levels are active</span>
01114   <span class="keywordtype">int</span> activeLevels;
01115   
01116   <span class="comment">// total size not counting insertBuffer and buffer1</span>
01117   <a class="code" href="classstxxl_1_1priority__queue.html#w4">size_type</a> size_;
01118 
01119   <span class="comment">// private member functions</span>
01120   <span class="keywordtype">void</span> refillBuffer1();
01121   <span class="keywordtype">int</span> refillBuffer2(<span class="keywordtype">int</span> k);
01122   
01123   <span class="keywordtype">int</span> makeSpaceAvailable(<span class="keywordtype">int</span> level);
01124   <span class="keywordtype">void</span> emptyInsertHeap();
01125   
01126   <a class="code" href="classstxxl_1_1priority__queue.html#w1">value_type</a> getSupremum()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cmp.min_value(); } <span class="comment">//{ return buffer2[0][KNN].key; }</span>
01127   <span class="keywordtype">int</span> getSize1( )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ( buffer1 + BufferSize1) - minBuffer1; }
01128   <span class="keywordtype">int</span> getSize2(<span class="keywordtype">int</span> i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;(buffer2[i][N])     - minBuffer2[i]; }
01129   
01130     
01131   <span class="comment">// forbidden cals</span>
01132   priority_queue();
01133   priority_queue &amp; operator = (<span class="keyword">const</span> priority_queue &amp;);  
01134 <span class="keyword">public</span>:
01135     
01145   priority_queue(prefetch_pool&lt;block_type&gt; &amp; p_pool_, write_pool&lt;block_type&gt; &amp; w_pool_);
01146     
01147   <span class="comment">// not implemented yet</span>
01148   priority_queue(<span class="keyword">const</span> priority_queue &amp; );
01149     
01150   <span class="keyword">virtual</span> ~priority_queue();
01151   
01154   size_type size() <span class="keyword">const</span>;
01155   
<a name="l01158"></a><a class="code" href="classstxxl_1_1priority__queue.html#a4">01158</a>   <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (size()==0); }
01159   
01171   <span class="keyword">const</span> value_type &amp; top() <span class="keyword">const</span>;
01172   
01179   <span class="keywordtype">void</span>  pop();
01180   
01185   <span class="keywordtype">void</span>  push(<span class="keyword">const</span> value_type &amp; obj);
01186   
<a name="l01191"></a><a class="code" href="classstxxl_1_1priority__queue.html#a8">01191</a>   <span class="keywordtype">unsigned</span> mem_cons()<span class="keyword"> const </span>
01192 <span class="keyword">  </span>{
01193     <span class="keywordtype">unsigned</span> dynam_alloc_mem(0),i(0);
01194     <span class="comment">//dynam_alloc_mem += w_pool.mem_cons();</span>
01195     <span class="comment">//dynam_alloc_mem += p_pool.mem_cons();</span>
01196     <span class="keywordflow">for</span>(;i&lt;IntLevels;++i)
01197       dynam_alloc_mem += itree[i].mem_cons();
01198     <span class="keywordflow">for</span>(i=0;i&lt;ExtLevels;++i)
01199       dynam_alloc_mem += etree[i].mem_cons();
01200     
01201     <span class="keywordflow">return</span> (  <span class="keyword">sizeof</span>(*this) + 
01202               <span class="keyword">sizeof</span>(ext_merger_type)*ExtLevels + 
01203               dynam_alloc_mem );
01204   }
01205 };
01206 
01207 
01208 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;  
<a name="l01209"></a><a class="code" href="classstxxl_1_1priority__queue.html#a1">01209</a> <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1priority__queue.html">priority_queue&lt;Config_&gt;</a><a class="code" href="classstxxl_1_1priority__queue.html#w4">::size_type</a> <a class="code" href="classstxxl_1_1priority__queue.html">priority_queue&lt;Config_&gt;::size</a>()<span class="keyword"> const </span>
01210 <span class="keyword"></span>{ 
01211   <span class="keywordflow">return</span> 
01212     size_ + 
01213     insertHeap.size() - 1 + 
01214     ((buffer1 + BufferSize1) - minBuffer1); 
01215 }
01216 
01217 
01218 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l01219"></a><a class="code" href="classstxxl_1_1priority__queue.html#a2">01219</a> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classstxxl_1_1priority__queue.html">priority_queue&lt;Config_&gt;</a><a class="code" href="classstxxl_1_1priority__queue.html#w1">::value_type</a> &amp; <a class="code" href="classstxxl_1_1priority__queue.html">priority_queue&lt;Config_&gt;::top</a>()<span class="keyword"> const</span>
01220 <span class="keyword"></span>{
01221   assert(!insertHeap.empty());
01222   
01223   <span class="keywordflow">if</span>( <span class="comment">/*(!insertHeap.empty()) &amp;&amp; */</span> cmp(*minBuffer1,insertHeap.top()))
01224     <span class="keywordflow">return</span> insertHeap.top();
01225   
01226   <span class="keywordflow">return</span> *minBuffer1;
01227 }
01228 
01229 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l01230"></a><a class="code" href="classstxxl_1_1priority__queue.html#a3">01230</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue.html">priority_queue&lt;Config_&gt;::pop</a>()
01231 {
01232   <span class="comment">//STXXL_VERBOSE1("priority_queue::pop()")</span>
01233   assert(!insertHeap.empty());
01234   
01235   <span class="keywordflow">if</span>(<span class="comment">/*(!insertHeap.empty()) &amp;&amp; */</span> cmp(*minBuffer1,insertHeap.top()))
01236   {
01237     insertHeap.pop();
01238   }
01239   <span class="keywordflow">else</span>
01240   {
01241     assert(minBuffer1 &lt; buffer1 + BufferSize1);
01242     ++minBuffer1;
01243     <span class="keywordflow">if</span> (minBuffer1 == buffer1 + BufferSize1)
01244       refillBuffer1();
01245   }
01246 }
01247 
01248 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l01249"></a><a class="code" href="classstxxl_1_1priority__queue.html#a4">01249</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classstxxl_1_1priority__queue.html">priority_queue&lt;Config_&gt;::push</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1priority__queue.html#w1">value_type</a> &amp; obj)
01250 {
01251   <span class="comment">//STXXL_VERBOSE3("priority_queue::push("&lt;&lt; obj &lt;&lt;")")</span>
01252   <span class="keywordflow">if</span>(insertHeap.size() == N + 1) 
01253      emptyInsertHeap();
01254   
01255   assert(!insertHeap.empty());
01256   
01257   insertHeap.push(obj);
01258 }
01259 
01260 
01261 
01263 
01264 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l01265"></a><a class="code" href="classstxxl_1_1priority__queue.html#a5">01265</a> <a class="code" href="classstxxl_1_1priority__queue.html">priority_queue&lt;Config_&gt;::priority_queue</a>(<a class="code" href="classstxxl_1_1prefetch__pool.html">prefetch_pool&lt;block_type&gt;</a> &amp; p_pool_, <a class="code" href="classstxxl_1_1write__pool.html">write_pool&lt;block_type&gt;</a> &amp; w_pool_) : 
01266   p_pool(p_pool_),w_pool(w_pool_),
01267   activeLevels(0), size_(0)
01268 {
01269   STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::priority_queue()"</span>)
01270   etree = <span class="keyword">new</span> ext_merger_type[ExtLevels](p_pool,w_pool);
01271   <a class="code" href="classstxxl_1_1priority__queue.html#w1">value_type</a> sentinel = cmp.min_value();
01272   buffer1[BufferSize1] = sentinel; <span class="comment">// sentinel</span>
01273   insertHeap.push(sentinel); <span class="comment">// always keep the sentinel</span>
01274   minBuffer1 = buffer1 + BufferSize1; <span class="comment">// empty</span>
01275   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0;  i &lt; Levels;  i++)
01276   { 
01277     buffer2[i][N] = sentinel; <span class="comment">// sentinel</span>
01278     minBuffer2[i] = &amp;(buffer2[i][N]); <span class="comment">// empty</span>
01279   }
01280   
01281 }
01282 
01283 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
01284 <a class="code" href="classstxxl_1_1priority__queue.html">priority_queue&lt;Config_&gt;::~priority_queue</a>()
01285 {
01286   STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::~priority_queue()"</span>)
01287   <span class="keyword">delete</span> [] etree;
01288 }
01289 
01290 <span class="comment">//--------------------- Buffer refilling -------------------------------</span>
01291 
01292 <span class="comment">// refill buffer2[j] and return number of elements found</span>
01293 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
01294 <span class="keywordtype">int</span> priority_queue&lt;Config_&gt;::refillBuffer2(<span class="keywordtype">int</span> j)
01295 {
01296   STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::refillBuffer2("</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">")"</span>)
01297   
01298   value_type * oldTarget;
01299   <span class="keywordtype">int</span> deleteSize;
01300   <a class="code" href="classstxxl_1_1priority__queue.html#w4">size_type</a> treeSize = (j&lt;IntLevels) ? itree[j].size() : etree[ j - IntLevels].<a class="code" href="group__stlcontinternals.html#a1">size</a>();
01301   <span class="keywordtype">int</span> bufferSize = (&amp;(buffer2[j][0]) + N) - minBuffer2[j];
01302   <span class="keywordflow">if</span> (treeSize + bufferSize &gt;= <a class="code" href="classstxxl_1_1priority__queue.html#w4">size_type</a>(N) ) 
01303   { <span class="comment">// buffer will be filled</span>
01304     oldTarget = &amp;(buffer2[j][0]);
01305     deleteSize = N - bufferSize;
01306   }
01307   <span class="keywordflow">else</span>
01308   {
01309     oldTarget = &amp;(buffer2[j][0]) + N - int(treeSize) - bufferSize;
01310     deleteSize = treeSize;
01311   }
01312 
01313   <span class="comment">// shift  rest to beginning</span>
01314   <span class="comment">// possible hack:</span>
01315   <span class="comment">// - use memcpy if no overlap</span>
01316   memmove(oldTarget, minBuffer2[j], bufferSize * <span class="keyword">sizeof</span>(value_type));
01317   minBuffer2[j] = oldTarget;
01318 
01319   <span class="comment">// fill remaining space from tree</span>
01320   <span class="keywordflow">if</span>(j&lt;IntLevels)
01321     itree[j].multi_merge(oldTarget + bufferSize, deleteSize);
01322   <span class="keywordflow">else</span>
01323     etree[j-IntLevels].multi_merge(oldTarget + bufferSize, 
01324             oldTarget + bufferSize + deleteSize);
01325   
01326   <span class="comment">//STXXL_MSG(deleteSize + bufferSize)</span>
01327   <span class="comment">//std::copy(oldTarget,oldTarget + deleteSize + bufferSize,std::ostream_iterator&lt;value_type&gt;(std::cout, "\n"));</span>
01328   
01329   <span class="keywordflow">return</span> deleteSize + bufferSize;
01330 }
01331  
01332  
01333 <span class="comment">// move elements from the 2nd level buffers </span>
01334 <span class="comment">// to the buffer</span>
01335 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
01336 <span class="keywordtype">void</span> priority_queue&lt;Config_&gt;::refillBuffer1() 
01337 {
01338   STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::refillBuffer1()"</span>)
01339   
01340   size_type totalSize = 0;
01341   <span class="keywordtype">int</span> sz;
01342   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = activeLevels - 1;  i &gt;= 0;  i--)
01343   {
01344     <span class="keywordflow">if</span>((&amp;(buffer2[i][0]) + N) - minBuffer2[i] &lt; BufferSize1)
01345     {
01346       sz = refillBuffer2(i);
01347       <span class="comment">// max active level dry now?</span>
01348       <span class="keywordflow">if</span> (sz == 0 &amp;&amp; i == activeLevels - 1)
01349         --activeLevels;
01350       <span class="keywordflow">else</span> 
01351         totalSize += sz;
01352       
01353     }
01354     <span class="keywordflow">else</span>
01355     {
01356       totalSize += BufferSize1; <span class="comment">// actually only a sufficient lower bound</span>
01357     }
01358   }
01359   
01360   <span class="keywordflow">if</span>(totalSize &gt;= BufferSize1) <span class="comment">// buffer can be filled</span>
01361   { 
01362     minBuffer1 = buffer1;
01363     sz = BufferSize1; <span class="comment">// amount to be copied</span>
01364     size_ -= <a class="code" href="classstxxl_1_1priority__queue.html#w4">size_type</a>(BufferSize1); <span class="comment">// amount left in buffer2</span>
01365   }
01366   <span class="keywordflow">else</span>
01367   {
01368     minBuffer1 = buffer1 + BufferSize1 - totalSize;
01369     sz = totalSize;
01370     assert(size_ == sz); <span class="comment">// trees and buffer2 get empty</span>
01371     size_ = 0;
01372   }
01373 
01374   <span class="comment">// now call simplified refill routines</span>
01375   <span class="comment">// which can make the assumption that</span>
01376   <span class="comment">// they find all they are asked to find in the buffers</span>
01377   minBuffer1 = buffer1 + BufferSize1 - sz;
01378   STXXL_VERBOSE2(<span class="stringliteral">"Active levels = "</span>&lt;&lt;activeLevels)
01379   <span class="keywordflow">switch</span>(activeLevels)
01380   {
01381   <span class="keywordflow">case</span> 0: <span class="keywordflow">break</span>;
01382   <span class="keywordflow">case</span> 1: 
01383           std::copy(minBuffer2[0],minBuffer2[0] + sz,minBuffer1);
01384           minBuffer2[0] += sz;
01385           <span class="keywordflow">break</span>;
01386   <span class="keywordflow">case</span> 2: priority_queue_local::merge(
01387                 &amp;(minBuffer2[0]), 
01388                 &amp;(minBuffer2[1]), minBuffer1, sz,cmp);
01389           <span class="keywordflow">break</span>;
01390   <span class="keywordflow">case</span> 3: priority_queue_local::merge3(
01391                  &amp;(minBuffer2[0]), 
01392                  &amp;(minBuffer2[1]),
01393                  &amp;(minBuffer2[2]), minBuffer1, sz,cmp);
01394           <span class="keywordflow">break</span>;
01395   <span class="keywordflow">case</span> 4: 
01396     STXXL_VERBOSE2(<span class="stringliteral">"=1="</span>&lt;&lt;minBuffer2[0][0]) <span class="comment">//std::copy(minBuffer2[0],(&amp;(buffer2[0][0])) + N,std::ostream_iterator&lt;value_type&gt;(std::cout, ","));</span>
01397     STXXL_VERBOSE2(<span class="stringliteral">"=2="</span>&lt;&lt;minBuffer2[1][0]) <span class="comment">//std::copy(minBuffer2[1],(&amp;(buffer2[1][0])) + N,std::ostream_iterator&lt;value_type&gt;(std::cout, ","));</span>
01398     STXXL_VERBOSE2(<span class="stringliteral">"=3="</span>&lt;&lt;minBuffer2[2][0]) <span class="comment">//std::copy(minBuffer2[2],(&amp;(buffer2[2][0])) + N,std::ostream_iterator&lt;value_type&gt;(std::cout, ","));</span>
01399     STXXL_VERBOSE2(<span class="stringliteral">"=4="</span>&lt;&lt;minBuffer2[3][0]) <span class="comment">//std::copy(minBuffer2[3],(&amp;(buffer2[3][0])) + N,std::ostream_iterator&lt;value_type&gt;(std::cout, ","));</span>
01400           priority_queue_local::merge4(
01401                  &amp;(minBuffer2[0]), 
01402                  &amp;(minBuffer2[1]),
01403                  &amp;(minBuffer2[2]),
01404                  &amp;(minBuffer2[3]), minBuffer1, sz,cmp);
01405           <span class="keywordflow">break</span>;
01406   <span class="keywordflow">default</span>:
01407         STXXL_ERRMSG(<span class="stringliteral">"Number of buffers on 2nd level in stxxl::priority_queue is currently limited to 4"</span>)
01408         abort();
01409   }
01410   
01411   <span class="comment">//std::copy(minBuffer1,minBuffer1 + sz,std::ostream_iterator&lt;value_type&gt;(std::cout, "\n"));</span>
01412 }
01413 
01414 <span class="comment">//--------------------------------------------------------------------</span>
01415 
01416 <span class="comment">// check if space is available on level k and</span>
01417 <span class="comment">// empty this level if necessary leading to a recursive call.</span>
01418 <span class="comment">// return the level where space was finally available</span>
01419 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
01420 <span class="keywordtype">int</span> priority_queue&lt;Config_&gt;::makeSpaceAvailable(<span class="keywordtype">int</span> level)
01421 {
01422   STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::makeSpaceAvailable("</span>&lt;&lt;level&lt;&lt;<span class="stringliteral">")"</span>)
01423   <span class="keywordtype">int</span> finalLevel;
01424   assert(level &lt; Levels);
01425   assert(level &lt;= activeLevels);
01426   
01427   <span class="keywordflow">if</span> (level == activeLevels) 
01428     activeLevels++; 
01429   
01430   <span class="keyword">const</span> <span class="keywordtype">bool</span> spaceIsAvailable_ = 
01431     (level &lt; IntLevels) ? itree[level].spaceIsAvailable() 
01432                         : ((level == Levels - 1)?true:(etree[level - IntLevels].spaceIsAvailable())) ;
01433   
01434   <span class="keywordflow">if</span>(spaceIsAvailable_)
01435   { 
01436     finalLevel = level;
01437   }
01438   <span class="keywordflow">else</span>
01439   {
01440     finalLevel = makeSpaceAvailable(level + 1);
01441     
01442     <span class="keywordflow">if</span>(level &lt; IntLevels - 1) <span class="comment">// from internal to internal tree</span>
01443     {
01444       <span class="keywordtype">int</span> segmentSize = itree[level].size();
01445       value_type * newSegment = <span class="keyword">new</span> value_type[segmentSize + 1];
01446       itree[level].multi_merge(newSegment, segmentSize); <span class="comment">// empty this level</span>
01447       
01448       newSegment[segmentSize] = buffer1[BufferSize1]; <span class="comment">// sentinel</span>
01449       <span class="comment">// for queues where size &lt;&lt; #inserts</span>
01450       <span class="comment">// it might make sense to stay in this level if</span>
01451       <span class="comment">// segmentSize &lt; alpha * KNN * k^level for some alpha &lt; 1</span>
01452       itree[level + 1].insert_segment(newSegment, segmentSize);
01453     }
01454     <span class="keywordflow">else</span>
01455     { 
01456       <span class="keywordflow">if</span>(level == IntLevels - 1) <span class="comment">// from internal to external tree</span>
01457       {
01458         <span class="keyword">const</span> <span class="keywordtype">int</span> segmentSize = itree[IntLevels - 1].size();
01459         etree[0].insert_segment(itree[IntLevels - 1],segmentSize);
01460       }
01461       <span class="keywordflow">else</span> <span class="comment">// from external to external tree</span>
01462       {
01463         <span class="keyword">const</span> size_type segmentSize = etree[level - IntLevels].size();
01464         etree[level - IntLevels + 1].insert_segment(etree[level - IntLevels],segmentSize);
01465       }
01466     }
01467   }
01468   <span class="keywordflow">return</span> finalLevel;
01469 }
01470 
01471 
01472 <span class="comment">// empty the insert heap into the main data structure</span>
01473 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
01474 <span class="keywordtype">void</span> priority_queue&lt;Config_&gt;::emptyInsertHeap()
01475 {
01476   STXXL_VERBOSE2(<span class="stringliteral">"priority_queue::emptyInsertHeap()"</span>)
01477   <span class="keyword">const</span> value_type sup = getSupremum();
01478 
01479   <span class="comment">// build new segment</span>
01480   value_type *newSegment = <span class="keyword">new</span> value_type[N + 1];
01481   value_type *newPos = newSegment;
01482 
01483   <span class="comment">// put the new data there for now</span>
01484   <span class="comment">//insertHeap.sortTo(newSegment);</span>
01485   value_type * SortTo = newSegment;
01486   <span class="keyword">const</span> value_type * SortEnd = newSegment + N;
01487   <span class="keywordflow">while</span>(SortTo != SortEnd)
01488   {
01489     assert(!insertHeap.empty());
01490     *SortTo = insertHeap.top();
01491     insertHeap.pop();
01492     ++SortTo;
01493   }
01494   
01495   assert(insertHeap.size() == 1);
01496   
01497   newSegment[N] = sup; <span class="comment">// sentinel</span>
01498 
01499   <span class="comment">// copy the buffer1 and buffer2[0] to temporary storage</span>
01500   <span class="comment">// (the temporary can be eliminated using some dirty tricks)</span>
01501   <span class="keyword">const</span> <span class="keywordtype">int</span> tempSize = N + BufferSize1;
01502   value_type temp[tempSize + 1]; 
01503   <span class="keywordtype">int</span> sz1 = getSize1();
01504   <span class="keywordtype">int</span> sz2 = getSize2(0);
01505   value_type * pos = temp + tempSize - sz1 - sz2;
01506   std::copy(minBuffer1,minBuffer1 + sz1 ,pos);
01507   std::copy(minBuffer2[0],minBuffer2[0] + sz2, pos + sz1);
01508   temp[tempSize] = sup; <span class="comment">// sentinel</span>
01509 
01510   <span class="comment">// refill buffer1</span>
01511   <span class="comment">// (using more complicated code it could be made somewhat fuller</span>
01512   <span class="comment">// in certein circumstances)</span>
01513   priority_queue_local::merge(&amp;pos, &amp;newPos, minBuffer1, sz1,cmp);
01514 
01515   <span class="comment">// refill buffer2[0]</span>
01516   <span class="comment">// (as above we might want to take the opportunity</span>
01517   <span class="comment">// to make buffer2[0] fuller)</span>
01518   priority_queue_local::merge(&amp;pos, &amp;newPos, minBuffer2[0], sz2,cmp);
01519 
01520   <span class="comment">// merge the rest to the new segment</span>
01521   <span class="comment">// note that merge exactly trips into the footsteps</span>
01522   <span class="comment">// of itself</span>
01523   priority_queue_local::merge(&amp;pos, &amp;newPos, newSegment, N,cmp);
01524   
01525   <span class="comment">// and insert it</span>
01526   <span class="keywordtype">int</span> freeLevel = makeSpaceAvailable(0);
01527   assert(freeLevel == 0 || itree[0].<a class="code" href="group__stlcontinternals.html#a1">size</a>() == 0);
01528   itree[0].insert_segment(newSegment, N);
01529 
01530   <span class="comment">// get rid of invalid level 2 buffers</span>
01531   <span class="comment">// by inserting them into tree 0 (which is almost empty in this case)</span>
01532   <span class="keywordflow">if</span> (freeLevel &gt; 0)
01533   {
01534     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = freeLevel;  i &gt;= 0;  i--)
01535     { <span class="comment">// reverse order not needed </span>
01536       <span class="comment">// but would allow immediate refill</span>
01537       
01538       newSegment = <span class="keyword">new</span> value_type[getSize2(i) + 1]; <span class="comment">// with sentinel</span>
01539       std::copy(minBuffer2[i],minBuffer2[i] + getSize2(i) + 1,newSegment);
01540       itree[0].insert_segment(newSegment, getSize2(i));
01541       minBuffer2[i] = buffer2[i] + N; <span class="comment">// empty</span>
01542     }
01543   }
01544 
01545   <span class="comment">// update size</span>
01546   size_ += <a class="code" href="classstxxl_1_1priority__queue.html#w4">size_type</a>(N); 
01547 
01548   <span class="comment">// special case if the tree was empty before</span>
01549   <span class="keywordflow">if</span> (minBuffer1 == buffer1 + BufferSize1) 
01550     refillBuffer1();
01551 }
01552 
01553 <span class="keyword">namespace </span>priority_queue_local
01554 {
01555   <span class="keyword">struct </span>Parameters_for_priority_queue_not_found_Increase_IntM
01556   {
01557     <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
01558     <span class="keyword">typedef</span> Parameters_for_priority_queue_not_found_Increase_IntM result;
01559   };
01560   
01561   <span class="keyword">struct </span>dummy
01562   {
01563     <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
01564     <span class="keyword">typedef</span> dummy result;
01565   };
01566   
01567   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> E_,<span class="keywordtype">int</span> IntM_,<span class="keywordtype">unsigned</span> MaxS_,<span class="keywordtype">int</span> B_,<span class="keywordtype">int</span> m_,<span class="keywordtype">bool</span> stop = false&gt;
01568   <span class="keyword">struct </span>find_B_m
01569   {
01570     <span class="keyword">typedef</span> find_B_m&lt;E_,IntM_,MaxS_,B_,m_,stop&gt; Self;
01571     <span class="keyword">enum</span> { 
01572       k = IntM_/B_ ,
01573       E = E_,
01574       IntM = IntM_,
01575       B = B_,
01576       m = m_,
01577       c = k - m_,
01578       <span class="comment">// memory occ. by block must be at least 10 times larger than size of ext sequence</span>
01579       <span class="comment">// &amp;&amp; satisfy memory req &amp;&amp; if we have two ext mergers their degree must be at least 64=m/2</span>
01580       fits = c&gt;10 &amp;&amp; ((k-m)*(m)*(m*B/(E*4*1024))) &gt;= int(MaxS_) &amp;&amp; (MaxS_&lt;((k-m)*m/(2*E))*1024 || m &gt;= 128),
01581       step = 1
01582     };
01583     
01584     <span class="keyword">typedef</span> <span class="keyword">typename</span> find_B_m&lt;E,IntM,MaxS_,B,m+step,fits || (m &gt;= k- step)&gt;::result candidate1;
01585     <span class="keyword">typedef</span> <span class="keyword">typename</span> find_B_m&lt;E,IntM,MaxS_,B/2,1,fits || candidate1::fits &gt;::result candidate2;
01586     <span class="keyword">typedef</span> <span class="keyword">typename</span> IF&lt;fits,Self, typename IF&lt;candidate1::fits,candidate1,candidate2&gt;::result &gt;::result result;
01587     
01588   };
01589   
01590   <span class="comment">// specialization for the case when no valid parameters are found</span>
01591   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> E_,<span class="keywordtype">int</span> IntM_,<span class="keywordtype">unsigned</span> MaxS_,<span class="keywordtype">bool</span> stop&gt;
01592   <span class="keyword">struct </span>find_B_m&lt;E_,IntM_,MaxS_,2048,1,stop&gt;
01593   {
01594     <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
01595     <span class="keyword">typedef</span> Parameters_for_priority_queue_not_found_Increase_IntM result;
01596   };
01597   
01598   <span class="comment">// to speedup search</span>
01599   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> E_,<span class="keywordtype">int</span> IntM_,<span class="keywordtype">unsigned</span> MaxS_,<span class="keywordtype">int</span> B_,<span class="keywordtype">int</span> m_&gt;
01600   <span class="keyword">struct </span>find_B_m&lt;E_,IntM_,MaxS_,B_,m_,true&gt;
01601   {
01602     <span class="keyword">enum</span> { fits = <span class="keyword">false</span> };
01603     <span class="keyword">typedef</span> dummy result;
01604   };
01605   
01606   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> E_,<span class="keywordtype">int</span> IntM_,<span class="keywordtype">unsigned</span> MaxS_&gt;
01607   <span class="keyword">struct </span>find_settings
01608   {
01609     <span class="keyword">typedef</span> <span class="keyword">typename</span> find_B_m&lt;E_,IntM_,MaxS_,(8*1024*1024),1&gt;::result result;
01610   };
01611 
01612   <span class="keyword">struct </span>Parameters_not_found_Try_to_change_Tune_parameter
01613   {
01614     <span class="keyword">typedef</span> Parameters_not_found_Try_to_change_Tune_parameter result;
01615   };
01616   
01617   
01618   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> AI_,<span class="keywordtype">int</span> X_,<span class="keywordtype">int</span> CriticalSize_&gt;
01619   <span class="keyword">struct </span>compute_N
01620   {
01621     <span class="keyword">typedef</span> compute_N&lt;AI_,X_,CriticalSize_&gt; Self;
01622     <span class="keyword">enum</span>
01623     {
01624       X = X_,
01625       AI = AI_,
01626       N = X/(AI*AI)
01627     };
01628     <span class="keyword">typedef</span> <span class="keyword">typename</span> IF&lt;(N&gt;=CriticalSize_),Self, <span class="keyword">typename</span> compute_N&lt;AI/2,X,CriticalSize_&gt;::result &gt;::result result;
01629   };
01630   
01631   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> X_,<span class="keywordtype">int</span> CriticalSize_&gt;
01632   <span class="keyword">struct </span>compute_N&lt;1,X_,CriticalSize_&gt;
01633   {
01634     <span class="keyword">typedef</span> Parameters_not_found_Try_to_change_Tune_parameter result;
01635   };
01636 
01637 };
01638 
01640 
01643 
01645 
01709 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tp_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> IntM_,<span class="keywordtype">unsigned</span> MaxS_,<span class="keywordtype">unsigned</span> Tune_=6&gt;
<a name="l01710"></a><a class="code" href="classstxxl_1_1PRIORITY__QUEUE__GENERATOR.html">01710</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1PRIORITY__QUEUE__GENERATOR.html">PRIORITY_QUEUE_GENERATOR</a>
01711 {
01712   <span class="keyword">public</span>:
01713   <span class="keyword">typedef</span> <span class="keyword">typename</span> priority_queue_local::find_settings&lt;sizeof(Tp_),IntM_,MaxS_&gt;<a class="code" href="classstxxl_1_1priority__queue.html">::result</a> settings;
01714   <span class="keyword">enum</span>{
01715      B = settings::B,
01716      m = settings::m,
01717      X = B*(settings::k - m)/settings::E,
01718      Buffer1Size = 32 
01719   };
01720   <span class="keyword">typedef</span> <span class="keyword">typename</span> priority_queue_local::compute_N&lt;(1&lt;&lt;Tune_),X,4*Buffer1Size&gt;<a class="code" href="classstxxl_1_1priority__queue.html">::result</a> ComputeN; 
01721   <span class="keyword">enum</span>
01722   {
01723      N = ComputeN::N,
01724      AI = ComputeN::AI,
01725      AE = (m/2 &lt; 2)?2:(m/2)
01726   };
01727 <span class="keyword">public</span>:
01728   <span class="keyword">enum</span> {
01729     <span class="comment">// Estimation of maximum internal memory consumption (in bytes)</span>
01730     EConsumption = X*settings::E + settings::B*AE + ((MaxS_/X)/AE)*settings::B*1024
01731   };
01732   <span class="comment">/*</span>
01733 <span class="comment">      unsigned BufferSize1_ = 32, // equalize procedure call overheads etc. </span>
01734 <span class="comment">      unsigned N_ = 512, // bandwidth</span>
01735 <span class="comment">      unsigned IntKMAX_ = 64, // maximal arity for internal mergers</span>
01736 <span class="comment">      unsigned IntLevels_ = 4, </span>
01737 <span class="comment">      unsigned BlockSize_ = (2*1024*1024),</span>
01738 <span class="comment">      unsigned ExtKMAX_ = 64, // maximal arity for external mergers</span>
01739 <span class="comment">      unsigned ExtLevels_ = 2,</span>
01740 <span class="comment">  */</span>
01741   <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1priority__queue.html">priority_queue&lt;priority_queue_config&lt;Tp_,Cmp_,Buffer1Size,N,AI,2,B,AE,2&gt;</a> &gt; <a class="code" href="classstxxl_1_1priority__queue.html">result</a>;
01742 };
01743 
01745 
01746 __STXXL_END_NAMESPACE
01747 
01748 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Nov 26 10:56:53 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
