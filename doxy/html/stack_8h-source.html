<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: stack.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>stack.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef STXXL_STACK_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_STACK_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            stack.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Tue May 27 14:12:24 2003</span>
00008 <span class="comment"> *  Copyright  2003  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 
00013 <span class="preprocessor">#include "../common/utils.h"</span>
00014 <span class="preprocessor">#include "../mng/mng.h"</span>
00015 <span class="preprocessor">#include "../common/simple_vector.h"</span>
00016 <span class="preprocessor">#include "../common/tmeta.h"</span>
00017 <span class="preprocessor">#include "../mng/write_pool.h"</span>
00018 <span class="preprocessor">#include "../mng/prefetch_pool.h"</span>
00019 <span class="preprocessor">#include &lt;stack&gt;</span>
00020 <span class="preprocessor">#include &lt;vector&gt;</span>
00021 
00022  
00023  __STXXL_BEGIN_NAMESPACE
00024  
00027  
00028  <span class="keyword">template</span> &lt;<span class="keyword">class </span>ValTp,
00029            <span class="keywordtype">unsigned</span> BlocksPerPage = 4,
00030            <span class="keywordtype">unsigned</span> BlkSz = STXXL_DEFAULT_BLOCK_SIZE(ValTp),
00031            <span class="keyword">class </span>AllocStr = STXXL_DEFAULT_ALLOC_STRATEGY,
00032            <span class="keyword">class </span>SzTp = off_t&gt;
00033  <span class="keyword">struct </span>stack_config_generator
00034  {
00035    <span class="keyword">typedef</span> ValTp value_type;
00036    <span class="keyword">enum</span> { blocks_per_page = BlocksPerPage };
00037    <span class="keyword">typedef</span> AllocStr alloc_strategy;
00038    <span class="keyword">enum</span> { block_size = BlkSz };
00039    <span class="keyword">typedef</span> SzTp size_type;
00040  };
00041 
00042  
00044  
00050 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l00051"></a><a class="code" href="classstxxl_1_1normal__stack.html">00051</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1normal__stack.html">normal_stack</a>
00052 {
00053 <span class="keyword">public</span>:
00054   <span class="keyword">typedef</span> Config_ cfg;
00055   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::value_type value_type;
00056   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::alloc_strategy alloc_strategy;
00057   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::size_type size_type;
00058   <span class="keyword">enum</span> {  blocks_per_page = cfg::blocks_per_page,
00059           block_size = cfg::block_size,
00060        };
00061           
00062   <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;block_size,value_type&gt;</a> <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>;
00063   <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;block_size&gt;</a> <a class="code" href="structstxxl_1_1BID.html">bid_type</a>;
00064 
00065 <span class="keyword">private</span>:
00066   size_type size_;
00067   <span class="keywordtype">unsigned</span> cache_offset;
00068   value_type * current_element;
00069   simple_vector&lt;block_type&gt; cache;
00070   <span class="keyword">typename</span> simple_vector&lt;block_type&gt;::iterator front_page;
00071   <span class="keyword">typename</span> simple_vector&lt;block_type&gt;::iterator back_page;
00072   std::vector&lt;bid_type&gt; bids;
00073   alloc_strategy alloc_strategy_;
00074 <span class="keyword">public</span>:
00075   <a class="code" href="classstxxl_1_1normal__stack.html">normal_stack</a>(): 
00076            size_(0),
00077            cache_offset(0),
00078            current_element(NULL),
00079            cache(blocks_per_page*2),
00080            front_page(cache.begin() + blocks_per_page),
00081            back_page(cache.begin()),
00082            bids(0)
00083   {
00084     bids.reserve(blocks_per_page);
00085   }
00089   <span class="keyword">template</span> &lt;<span class="keyword">class</span> stack_type&gt;
<a name="l00090"></a><a class="code" href="classstxxl_1_1normal__stack.html#a1">00090</a>   <a class="code" href="classstxxl_1_1normal__stack.html">normal_stack</a>(<span class="keyword">const</span> stack_type &amp; stack_): 
00091            size_(0),
00092            cache_offset(0),
00093            current_element(NULL),
00094            cache(blocks_per_page*2),
00095            front_page(cache.begin() + blocks_per_page),
00096            back_page(cache.begin()),
00097            bids(0)
00098   {
00099     bids.reserve(blocks_per_page);
00100     
00101     stack_type stack_copy = stack_;
00102     <span class="keyword">const</span> size_type sz=stack_copy.size();
00103     size_type i;
00104     
00105     std::vector&lt;value_type&gt; tmp(sz);
00106     
00107     <span class="keywordflow">for</span>(i=0;i&lt;sz;i++)
00108     {
00109       tmp[sz - i - 1] = stack_copy.top();
00110       stack_copy.pop();
00111     }
00112     <span class="keywordflow">for</span>(i=0;i&lt;sz;i++)
00113       this-&gt;push(tmp[i]);
00114     
00115   }
00116   <span class="keyword">virtual</span> ~<a class="code" href="classstxxl_1_1normal__stack.html">normal_stack</a>()
00117   {
00118     STXXL_VERBOSE(__PRETTY_FUNCTION__);
00119     block_manager::get_instance()-&gt;delete_blocks(bids.begin(),bids.end());
00120   }
00121   size_type size()<span class="keyword"> const</span>
00122 <span class="keyword">  </span>{
00123     <span class="keywordflow">return</span> size_;
00124   }
00125   <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
00126 <span class="keyword">  </span>{
00127     <span class="keywordflow">return</span> (!size_);
00128   }
00129   value_type &amp; top()
00130   {
00131     assert(size_ &gt; 0);
00132     <span class="keywordflow">return</span> (*current_element);
00133   }
00134   <span class="keyword">const</span> value_type &amp; top()<span class="keyword"> const</span>
00135 <span class="keyword">  </span>{
00136     assert(size_ &gt; 0);
00137     <span class="keywordflow">return</span> (*current_element);
00138   }
00139   <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; val)
00140   {
00141     assert(cache_offset &lt;= 2*blocks_per_page*block_type::size);
00142     assert(cache_offset &gt;= 0);
00143     
00144     <span class="keywordflow">if</span>(cache_offset == 2*blocks_per_page*block_type::size) <span class="comment">// cache overflow</span>
00145     {
00146       STXXL_VERBOSE2(<span class="stringliteral">"growing, size: "</span>&lt;&lt;size_)
00147       
00148       bids.resize(bids.size() + blocks_per_page);
00149       <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::iterator cur_bid = bids.end() - blocks_per_page;
00150       block_manager::get_instance()-&gt;new_blocks(
00151           offset_allocator&lt;alloc_strategy&gt;(cur_bid-bids.begin(),alloc_strategy_),cur_bid,bids.end());
00152       
00153       simple_vector&lt;request_ptr&gt; requests(blocks_per_page);
00154       
00155       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;blocks_per_page;i++,cur_bid++)
00156       {
00157         requests[i] = (back_page + i)-&gt;write(*cur_bid);
00158       }
00159       
00160       
00161       std::swap(back_page,front_page);
00162       
00163       bids.reserve(bids.size() + blocks_per_page);
00164       
00165       cache_offset = blocks_per_page*block_type::size + 1;
00166       current_element = &amp;((*front_page)[0]);
00167       ++size_;
00168       
00169       <a class="code" href="group__iolayer.html#a3">wait_all</a>(requests.begin(),blocks_per_page);
00170       
00171       *current_element=val;
00172       
00173       <span class="keywordflow">return</span>;
00174     }
00175     
00176     current_element = element(cache_offset);
00177     *current_element=val;
00178     ++size_;
00179     ++cache_offset;
00180   }
00181   <span class="keywordtype">void</span> pop()
00182   {
00183     assert(cache_offset &lt;= 2*blocks_per_page*block_type::size);
00184     assert(cache_offset &gt; 0);
00185     assert(size_ &gt; 0);
00186     
00187     <span class="keywordflow">if</span>(cache_offset == 1 &amp;&amp; bids.size() &gt;= blocks_per_page)
00188     { 
00189       STXXL_VERBOSE2(<span class="stringliteral">"shrinking, size: "</span>&lt;&lt;size_)
00190      
00191       simple_vector&lt;request_ptr&gt; requests(blocks_per_page);
00192       
00193       <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::const_iterator cur_bid = bids.end() - 1;
00194       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=blocks_per_page-1 ;i&gt;=0;i--,cur_bid--)
00195         requests[i] = (front_page+i)-&gt;read(*cur_bid);
00196         
00197       std::swap(front_page,back_page);
00198             
00199       cache_offset = blocks_per_page*block_type::size;
00200       --size_;
00201       current_element = &amp;((*(back_page+(blocks_per_page - 1)))[block_type::size - 1]);
00202       
00203       <a class="code" href="group__iolayer.html#a3">wait_all</a>(requests.begin(),blocks_per_page);
00204       
00205       block_manager::get_instance()-&gt;delete_blocks(bids.end() - blocks_per_page,bids.end());
00206       bids.resize(bids.size() - blocks_per_page);
00207       
00208       <span class="keywordflow">return</span>;
00209     }
00210        
00211     --size_;
00212     
00213     current_element = element((--cache_offset) - 1);
00214   }
00215 <span class="keyword">private</span>:
00216   value_type * element(<span class="keywordtype">unsigned</span> offset)
00217   {
00218     <span class="keywordflow">if</span>(offset &lt; blocks_per_page*block_type::size)
00219       <span class="keywordflow">return</span> &amp;((*(back_page + offset/block_type::size))[offset%block_type::size]);
00220     
00221     <span class="keywordtype">unsigned</span> unbiased_offset = offset - blocks_per_page*block_type::size;
00222     <span class="keywordflow">return</span> &amp;((*(front_page + unbiased_offset/block_type::size))[unbiased_offset%block_type::size]);
00223   }
00224 };
00225 
00226 
00228 
00231 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l00232"></a><a class="code" href="classstxxl_1_1grow__shrink__stack.html">00232</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1grow__shrink__stack.html">grow_shrink_stack</a>
00233 {
00234 <span class="keyword">public</span>:
00235   <span class="keyword">typedef</span> Config_ cfg;
00236   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::value_type value_type;
00237   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::alloc_strategy alloc_strategy;
00238   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::size_type size_type;
00239   <span class="keyword">enum</span> {  blocks_per_page = cfg::blocks_per_page,
00240           block_size = cfg::block_size,
00241        };
00242           
00243   <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;block_size,value_type&gt;</a> <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>;
00244   <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;block_size&gt;</a> <a class="code" href="structstxxl_1_1BID.html">bid_type</a>;
00245 
00246 <span class="keyword">private</span>:
00247   size_type size_;
00248   <span class="keywordtype">unsigned</span> cache_offset;
00249   value_type * current_element;
00250   simple_vector&lt;block_type&gt; cache;
00251   <span class="keyword">typename</span> simple_vector&lt;block_type&gt;::iterator cache_buffers;
00252   <span class="keyword">typename</span> simple_vector&lt;block_type&gt;::iterator overlap_buffers;
00253   simple_vector&lt;request_ptr&gt; requests;
00254   std::vector&lt;bid_type&gt; bids;
00255   alloc_strategy alloc_strategy_;
00256 <span class="keyword">public</span>:
00257   <a class="code" href="classstxxl_1_1grow__shrink__stack.html">grow_shrink_stack</a>(): 
00258            size_(0),
00259            cache_offset(0),
00260            current_element(NULL),
00261            cache(blocks_per_page*2),
00262            cache_buffers(cache.begin()),
00263            overlap_buffers(cache.begin() + blocks_per_page),
00264            requests(blocks_per_page),
00265            bids(0)
00266   {
00267     bids.reserve(blocks_per_page);
00268   }
00272   <span class="keyword">template</span> &lt;<span class="keyword">class</span> stack_type&gt;
<a name="l00273"></a><a class="code" href="classstxxl_1_1grow__shrink__stack.html#a1">00273</a>   <a class="code" href="classstxxl_1_1grow__shrink__stack.html">grow_shrink_stack</a>(<span class="keyword">const</span> stack_type &amp; stack_): 
00274            size_(0),
00275            cache_offset(0),
00276            current_element(NULL),
00277            cache(blocks_per_page*2),
00278            cache_buffers(cache.begin()),
00279            overlap_buffers(cache.begin() + blocks_per_page),
00280            requests(blocks_per_page),
00281            bids(0)
00282   {
00283     bids.reserve(blocks_per_page);
00284     
00285     stack_type stack_copy = stack_;
00286     <span class="keyword">const</span> size_type sz=stack_copy.size();
00287     size_type i;
00288     
00289     std::vector&lt;value_type&gt; tmp(sz);
00290     
00291     <span class="keywordflow">for</span>(i=0;i&lt;sz;i++)
00292     {
00293       tmp[sz - i - 1] = stack_copy.top();
00294       stack_copy.pop();
00295     }
00296     <span class="keywordflow">for</span>(i=0;i&lt;sz;i++)
00297       this-&gt;push(tmp[i]);
00298     
00299   }
00300   <span class="keyword">virtual</span> ~<a class="code" href="classstxxl_1_1grow__shrink__stack.html">grow_shrink_stack</a>()
00301   {
00302     STXXL_VERBOSE(__PRETTY_FUNCTION__);
00303     <span class="keywordflow">if</span>(requests[0].get()) <a class="code" href="group__iolayer.html#a3">wait_all</a>(requests.begin(),blocks_per_page);  
00304     block_manager::get_instance()-&gt;delete_blocks(bids.begin(),bids.end());
00305   }
00306   size_type size()<span class="keyword"> const</span>
00307 <span class="keyword">  </span>{
00308     <span class="keywordflow">return</span> size_;
00309   }
00310   <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
00311 <span class="keyword">  </span>{
00312     <span class="keywordflow">return</span> (!size_);
00313   }
00314   value_type &amp; top()
00315   {
00316     assert(size_ &gt; 0);
00317     <span class="keywordflow">return</span> (*current_element);
00318   }
00319   <span class="keyword">const</span> value_type &amp; top()<span class="keyword"> const</span>
00320 <span class="keyword">  </span>{
00321     assert(size_ &gt; 0);
00322     <span class="keywordflow">return</span> (*current_element);
00323   }
00324   <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; val)
00325   {
00326     assert(cache_offset &lt;= blocks_per_page*block_type::size);
00327     assert(cache_offset &gt;= 0);
00328     
00329     <span class="keywordflow">if</span>(cache_offset == blocks_per_page*block_type::size) <span class="comment">// cache overflow</span>
00330     {
00331       STXXL_VERBOSE2(<span class="stringliteral">"growing, size: "</span>&lt;&lt;size_)
00332       
00333       bids.resize(bids.size() + blocks_per_page);
00334       <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::iterator cur_bid = bids.end() - blocks_per_page;
00335       block_manager::get_instance()-&gt;new_blocks(
00336           offset_allocator&lt;alloc_strategy&gt;(cur_bid-bids.begin(),alloc_strategy_),cur_bid,bids.end());
00337       
00338       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;blocks_per_page;i++,cur_bid++)
00339       {
00340         <span class="keywordflow">if</span>(requests[i].get()) requests[i]-&gt;wait();
00341         requests[i] = (cache_buffers + i)-&gt;write(*cur_bid);
00342       }
00343       
00344       std::swap(cache_buffers,overlap_buffers);
00345       
00346       bids.reserve(bids.size() + blocks_per_page);
00347       
00348       cache_offset = 1;
00349       current_element = &amp;((*cache_buffers)[0]);
00350       ++size_;
00351  
00352       *current_element=val;
00353       
00354       <span class="keywordflow">return</span>;
00355     }
00356     
00357     current_element = &amp;((*(cache_buffers + cache_offset/block_type::size))[cache_offset%block_type::size]);
00358     *current_element=val;
00359     ++size_;
00360     ++cache_offset;
00361   }
00362   <span class="keywordtype">void</span> pop()
00363   {
00364     assert(cache_offset &lt;= blocks_per_page*block_type::size);
00365     assert(cache_offset &gt; 0);
00366     assert(size_ &gt; 0);
00367     
00368     <span class="keywordflow">if</span>(cache_offset == 1 &amp;&amp; bids.size() &gt;= blocks_per_page)
00369     { 
00370       STXXL_VERBOSE2(<span class="stringliteral">"shrinking, size: "</span>&lt;&lt;size_)
00371       
00372       <span class="keywordflow">if</span>(requests[0].get())
00373         <a class="code" href="group__iolayer.html#a3">wait_all</a>(requests.begin(),blocks_per_page);
00374       
00375       std::swap(cache_buffers,overlap_buffers);
00376       
00377       <span class="keywordflow">if</span>(bids.size() &gt; blocks_per_page)
00378       {
00379         STXXL_VERBOSE2(<span class="stringliteral">"prefetching, size: "</span>&lt;&lt;size_)
00380         <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::const_iterator cur_bid = bids.end() - blocks_per_page - 1;
00381         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=blocks_per_page-1 ;i&gt;=0;i--,cur_bid--)
00382           requests[i] = (overlap_buffers+i)-&gt;read(*cur_bid);
00383         
00384       }
00385             
00386       block_manager::get_instance()-&gt;delete_blocks(bids.end() - blocks_per_page,bids.end());
00387       bids.resize(bids.size() - blocks_per_page);
00388       
00389       cache_offset = blocks_per_page*block_type::size;
00390       --size_;
00391       current_element = &amp;((*(cache_buffers+(blocks_per_page - 1)))[block_type::size - 1]);
00392       
00393       <span class="keywordflow">return</span>;
00394     }
00395        
00396     --size_;
00397     <span class="keywordtype">unsigned</span> cur_offset = (--cache_offset) - 1;
00398     current_element = &amp;((*(cache_buffers + cur_offset/block_type::size))[cur_offset%block_type::size]);
00399     
00400   }
00401   
00402 };
00403 
00405 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
<a name="l00406"></a><a class="code" href="classstxxl_1_1grow__shrink__stack2.html">00406</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1grow__shrink__stack2.html">grow_shrink_stack2</a>
00407 {
00408 <span class="keyword">public</span>:
00409   <span class="keyword">typedef</span> Config_ cfg;
00410   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::value_type value_type;
00411   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::alloc_strategy alloc_strategy;
00412   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::size_type size_type;
00413   <span class="keyword">enum</span> {  blocks_per_page = cfg::blocks_per_page, <span class="comment">// stack of this type has only one page</span>
00414           block_size = cfg::block_size,
00415        };
00416           
00417   <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;block_size,value_type&gt;</a> <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>;
00418   <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;block_size&gt;</a> <a class="code" href="structstxxl_1_1BID.html">bid_type</a>;
00419 
00420 <span class="keyword">private</span>:
00421   size_type size_;
00422   <span class="keywordtype">unsigned</span> cache_offset;
00423   <a class="code" href="classstxxl_1_1typed__block.html">block_type</a> * cache;
00424   value_type current;
00425   std::vector&lt;bid_type&gt; bids;
00426   alloc_strategy alloc_strategy_;
00427   <span class="keywordtype">unsigned</span> pref_aggr;
00428   <a class="code" href="classstxxl_1_1prefetch__pool.html">prefetch_pool&lt;block_type&gt;</a> &amp; p_pool;
00429   <a class="code" href="classstxxl_1_1write__pool.html">write_pool&lt;block_type&gt;</a>    &amp; w_pool;
00430   <span class="comment">// for a moment forbid default construction</span>
00431   <a class="code" href="classstxxl_1_1grow__shrink__stack2.html">grow_shrink_stack2</a>();
00432 <span class="keyword">public</span>:
<a name="l00437"></a><a class="code" href="classstxxl_1_1grow__shrink__stack2.html#a0">00437</a>   <a class="code" href="classstxxl_1_1grow__shrink__stack2.html">grow_shrink_stack2</a>(
00438        <a class="code" href="classstxxl_1_1prefetch__pool.html">prefetch_pool&lt;block_type&gt;</a> &amp; p_pool_,
00439        <a class="code" href="classstxxl_1_1write__pool.html">write_pool&lt;block_type&gt;</a>    &amp; w_pool_,
00440        <span class="keywordtype">unsigned</span> prefetch_aggressiveness = 0):
00441        size_(0),
00442        cache_offset(0),
00443        cache(new <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>),
00444        pref_aggr(prefetch_aggressiveness),
00445        p_pool(p_pool_),
00446        w_pool(w_pool_)
00447   {
00448     STXXL_VERBOSE2(<span class="stringliteral">"grow_shrink_stack2::grow_shrink_stack2(...)"</span>)
00449   }
00450   <span class="keyword">virtual</span> ~ grow_shrink_stack2()
00451   {
00452     STXXL_VERBOSE2(<span class="stringliteral">"grow_shrink_stack2::~grow_shrink_stack2()"</span>)
00453     <span class="keyword">const</span> <span class="keywordtype">int</span> bids_size = bids.size();
00454     <span class="keyword">const</span> <span class="keywordtype">int</span> last_pref = std::max(<span class="keywordtype">int</span>(bids_size) - <span class="keywordtype">int</span>(pref_aggr),0);
00455     <span class="keywordtype">int</span> i;
00456     <span class="keywordflow">for</span>(i=bids_size - 1 ; i &gt;= last_pref ; --i )
00457     {
00458         <span class="keywordflow">if</span>(p_pool.in_prefetching(bids[i]));
00459           p_pool.read(cache,bids[i])-&gt;wait();  <span class="comment">// clean the prefetch buffer</span>
00460     }
00461     <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::iterator cur = bids.begin();
00462     <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::const_iterator end = bids.end();
00463     <span class="keywordflow">for</span>(;cur!=end;++cur)
00464     {
00465        block_type * b = w_pool.steal(*cur);
00466        <span class="keywordflow">if</span>(b)
00467        {
00468          w_pool.add(cache); <span class="comment">// return buffer</span>
00469          cache = b;
00470        }
00471     }
00472     <span class="keyword">delete</span> cache;
00473     block_manager::get_instance()-&gt;delete_blocks(bids.begin(),bids.end());
00474   }
00475   size_type size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
00476     
00477   <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
00478 <span class="keyword">  </span>{
00479     <span class="keywordflow">return</span> (!size_);
00480   }
00481     
00482   <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; val)
00483   {
00484     STXXL_VERBOSE3(<span class="stringliteral">"grow_shrink_stack2::push("</span>&lt;&lt; val &lt;&lt;<span class="stringliteral">")"</span>)
00485     assert(cache_offset &lt;= block_type::size);
00486     
00487     <span class="keywordflow">if</span>(cache_offset == block_type::size)
00488     {
00489       STXXL_VERBOSE2(<span class="stringliteral">"grow_shrink_stack2::push("</span>&lt;&lt; val &lt;&lt;<span class="stringliteral">") growing, size: "</span>&lt;&lt;size_)
00490       
00491       bids.resize(bids.size() + 1);
00492       <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::iterator cur_bid = bids.end() - 1;
00493       block_manager::get_instance()-&gt;new_blocks(
00494           offset_allocator&lt;alloc_strategy&gt;(cur_bid-bids.begin(),alloc_strategy_),cur_bid,bids.end());
00495       w_pool.write(cache,bids.back());
00496       cache = w_pool.steal();
00497       <span class="keyword">const</span> <span class="keywordtype">int</span> bids_size = bids.size();
00498       <span class="keyword">const</span> <span class="keywordtype">int</span> last_pref = std::max(<span class="keywordtype">int</span>(bids_size) - <span class="keywordtype">int</span>(pref_aggr) - 1,0);
00499       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=bids_size - 2 ; i &gt;= last_pref ; --i )
00500       {
00501         <span class="keywordflow">if</span>(p_pool.in_prefetching(bids[i]))
00502             p_pool.read(cache,bids[i])-&gt;wait(); <span class="comment">//  clean prefetch buffers</span>
00503       }
00504       cache_offset = 0;
00505     }
00506     current = val;
00507     (*cache)[cache_offset] = val;
00508     ++size_;
00509     ++cache_offset;
00510     
00511     assert(cache_offset &gt; 0);
00512     assert(cache_offset &lt;= block_type::size);
00513   }
00514   value_type &amp; top()
00515   {
00516     assert(size_ &gt; 0);
00517     assert(cache_offset &gt; 0);
00518     assert(cache_offset &lt;= block_type::size);
00519     <span class="keywordflow">return</span> current;
00520   }
00521   <span class="keyword">const</span> value_type &amp; top()<span class="keyword"> const</span>
00522 <span class="keyword">  </span>{
00523     assert(size_ &gt; 0);
00524     assert(cache_offset &gt; 0);
00525     assert(cache_offset &lt;= block_type::size);
00526     <span class="keywordflow">return</span> current;
00527   }
00528   <span class="keywordtype">void</span> pop()
00529   {
00530     STXXL_VERBOSE3(<span class="stringliteral">"grow_shrink_stack2::pop()"</span>)
00531     assert(size_ &gt; 0);
00532     assert(cache_offset &gt; 0);
00533     assert(cache_offset &lt;= block_type::size);
00534     <span class="keywordflow">if</span>(cache_offset == 1 &amp;&amp; (!bids.empty()) )
00535     {
00536       STXXL_VERBOSE2(<span class="stringliteral">"grow_shrink_stack2::pop() shrinking, size = "</span>&lt;&lt;size_)
00537       
00538       bid_type last_block = bids.back();
00539       bids.pop_back();
00540       <span class="comment">/*block_type * b = w_pool.steal(last_block);</span>
00541 <span class="comment">      if(b)</span>
00542 <span class="comment">      {</span>
00543 <span class="comment">        STXXL_VERBOSE2("grow_shrink_stack2::pop() block is still in write buffer")</span>
00544 <span class="comment">        w_pool.add(cache);</span>
00545 <span class="comment">        cache = b;</span>
00546 <span class="comment">      }</span>
00547 <span class="comment">      else*/</span>
00548       {
00549         <span class="comment">//STXXL_VERBOSE2("grow_shrink_stack2::pop() block is no longer in write buffer"</span>
00550         <span class="comment">//  ", reading from prefetch/read pool")</span>
00551         p_pool.read(cache,last_block)-&gt;wait();
00552       }
00553       block_manager::get_instance()-&gt;delete_block(last_block);
00554       <span class="keyword">const</span> <span class="keywordtype">int</span> bids_size = bids.size();
00555       <span class="keyword">const</span> <span class="keywordtype">int</span> last_pref = std::max(<span class="keywordtype">int</span>(bids_size) - <span class="keywordtype">int</span>(pref_aggr),0);
00556       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=bids_size - 1; i &gt;= last_pref ; --i )
00557       {
00558         p_pool.hint(bids[i]); <span class="comment">// prefetch</span>
00559       }
00560       cache_offset = block_type::size + 1;
00561       
00562     }
00563     
00564     --cache_offset;
00565     <span class="keywordflow">if</span>(cache_offset &gt; 0)
00566       current = (*cache)[cache_offset - 1];
00567     --size_;
00568   }
<a name="l00572"></a><a class="code" href="classstxxl_1_1grow__shrink__stack2.html#a8">00572</a>   <span class="keywordtype">void</span> set_prefetch_aggr(<span class="keywordtype">unsigned</span> new_p)
00573   {
00574     <span class="keywordflow">if</span>(pref_aggr &gt; new_p)
00575     {
00576       <span class="keyword">const</span> <span class="keywordtype">int</span> bids_size = bids.size();
00577       <span class="keyword">const</span> <span class="keywordtype">int</span> last_pref = std::max(<span class="keywordtype">int</span>(bids_size) - <span class="keywordtype">int</span>(pref_aggr),0);
00578       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=bids_size - new_p - 1 ; i &gt;= last_pref ; --i )
00579       {
00580         <span class="keywordflow">if</span>(p_pool.in_prefetching(bids[i]))
00581             p_pool.read(cache,bids[i])-&gt;wait(); <span class="comment">//  clean prefetch buffers</span>
00582       }
00583     }
00584     <span class="keywordflow">else</span>
00585     <span class="keywordflow">if</span>(pref_aggr &lt; new_p)
00586     {
00587       <span class="keyword">const</span> <span class="keywordtype">int</span> bids_size = bids.size();
00588       <span class="keyword">const</span> <span class="keywordtype">int</span> last_pref = std::max(<span class="keywordtype">int</span>(bids_size) - <span class="keywordtype">int</span>(new_p),0);
00589       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=bids_size - 1 ; i &gt;= last_pref ; --i )
00590       {
00591         p_pool.hint(bids[i]); <span class="comment">// prefetch</span>
00592       }
00593     }
00594     pref_aggr = new_p;
00595   }
<a name="l00597"></a><a class="code" href="classstxxl_1_1grow__shrink__stack2.html#a9">00597</a>   <span class="keywordtype">unsigned</span> get_prefetch_aggr()<span class="keyword"> const</span>
00598 <span class="keyword">  </span>{
00599     <span class="keywordflow">return</span> pref_aggr;
00600   }
00601 };
00602 
00603 
00605 
00607 <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> CritSize, <span class="keyword">class</span> ExternalStack, <span class="keyword">class</span> InternalStack&gt;
<a name="l00608"></a><a class="code" href="classstxxl_1_1migrating__stack.html">00608</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1migrating__stack.html">migrating_stack</a>
00609 {
00610 <span class="keyword">public</span>:
00611   <span class="keyword">typedef</span> <span class="keyword">typename</span> ExternalStack::cfg cfg;
00612   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::value_type value_type;
00613   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::alloc_strategy alloc_strategy;
00614   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::size_type size_type;
00615   <span class="keyword">enum</span> {  blocks_per_page = cfg::blocks_per_page,
00616           block_size = cfg::block_size };
00617           
00618           
00619   <span class="keyword">typedef</span> InternalStack int_stack_type;
00620   <span class="keyword">typedef</span> ExternalStack ext_stack_type;
00621   
00622 <span class="keyword">private</span>:
00623   <span class="keyword">enum</span> { critical_size = CritSize };
00624     
00625   int_stack_type * int_impl;
00626   ext_stack_type * ext_impl;
00627 
00628 <span class="keyword">public</span>:
00629   <a class="code" href="classstxxl_1_1migrating__stack.html">migrating_stack</a>(): int_impl(<span class="keyword">new</span> int_stack_type()),ext_impl(NULL) {}
00630   <span class="comment">// not implemented yet</span>
00631   <span class="keyword">template</span> &lt;<span class="keyword">class</span> stack_type&gt; 
00632   <a class="code" href="classstxxl_1_1migrating__stack.html">migrating_stack</a>(<span class="keyword">const</span> stack_type &amp; stack_);  
<a name="l00634"></a><a class="code" href="classstxxl_1_1migrating__stack.html#a2">00634</a>   <span class="keywordtype">bool</span> internal() 
00635   { 
00636     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00637     <span class="keywordflow">return</span> int_impl; 
00638   }
<a name="l00640"></a><a class="code" href="classstxxl_1_1migrating__stack.html#a3">00640</a>   <span class="keywordtype">bool</span> external() 
00641   {
00642     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00643     <span class="keywordflow">return</span> ext_impl; 
00644   }
00645   
00646   <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
00647 <span class="keyword">  </span>{
00648     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00649     
00650     <span class="keywordflow">if</span>(int_impl)
00651       <span class="keywordflow">return</span> int_impl-&gt;empty();
00652     
00653     <span class="keywordflow">return</span> ext_impl-&gt;empty();
00654   }
00655   size_type size()<span class="keyword"> const</span>
00656 <span class="keyword">  </span>{
00657     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00658     
00659     <span class="keywordflow">if</span>(int_impl)
00660       <span class="keywordflow">return</span> int_impl-&gt;size();
00661     
00662     <span class="keywordflow">return</span> ext_impl-&gt;size();
00663   }
00664   value_type &amp; top()
00665   {
00666     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00667     
00668     <span class="keywordflow">if</span>(int_impl)
00669       <span class="keywordflow">return</span> int_impl-&gt;top();
00670     
00671     <span class="keywordflow">return</span> ext_impl-&gt;top();
00672   }
00673   <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; val)
00674   {
00675     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00676     
00677     <span class="keywordflow">if</span>(int_impl)
00678     {
00679       int_impl-&gt;push(val);
00680       <span class="keywordflow">if</span>(int_impl-&gt;size() == critical_size)
00681       {
00682         <span class="comment">// migrate to external stack</span>
00683         ext_impl = <span class="keyword">new</span> ext_stack_type(*int_impl);
00684         <span class="keyword">delete</span> int_impl;
00685         int_impl = NULL;
00686       }
00687     }
00688     <span class="keywordflow">else</span>
00689       ext_impl-&gt;push(val);
00690   }
00691   <span class="keywordtype">void</span> pop()
00692   {
00693     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00694     
00695     <span class="keywordflow">if</span>(int_impl)
00696       int_impl-&gt;pop();
00697     <span class="keywordflow">else</span>
00698       ext_impl-&gt;pop();
00699   }
00700   <span class="keyword">virtual</span> ~migrating_stack()
00701   {
00702     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00703     
00704     <span class="keywordflow">if</span>(int_impl)
00705       <span class="keyword">delete</span> int_impl;
00706     <span class="keywordflow">else</span>
00707       <span class="keyword">delete</span> ext_impl;
00708   }
00709 };
00710 
00712 
00713 
00716 
00717 <span class="keyword">enum</span> stack_externality { external, migrating, internal };
00718 <span class="keyword">enum</span> stack_behaviour { normal, grow_shrink, grow_shrink2 };
00719 
00721 
00756 <span class="keyword">template</span>  &lt;
00757             <span class="keyword">class </span>ValTp,
00758             stack_externality  Externality = external,
00759             stack_behaviour    Behaviour = normal,
00760             <span class="keywordtype">unsigned</span> BlocksPerPage = 4,
00761             <span class="keywordtype">unsigned</span> BlkSz = STXXL_DEFAULT_BLOCK_SIZE(ValTp),
00762 
00763             <span class="keyword">class </span>IntStackTp = std::stack&lt;ValTp&gt;,
00764             <span class="keywordtype">unsigned</span> MigrCritSize = (2*BlocksPerPage*BlkSz),
00765 
00766             <span class="keyword">class </span>AllocStr = STXXL_DEFAULT_ALLOC_STRATEGY,
00767             <span class="keyword">class </span>SzTp = off_t
00768           &gt;
<a name="l00769"></a><a class="code" href="classstxxl_1_1STACK__GENERATOR.html">00769</a> <span class="keyword">class </span><a class="code" href="classstxxl_1_1STACK__GENERATOR.html">STACK_GENERATOR</a>
00770 {
00771   <span class="keyword">typedef</span> stack_config_generator&lt;ValTp,BlocksPerPage,BlkSz,AllocStr,SzTp&gt; cfg;
00772   
00773   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1IF.html">IF</a>&lt;Behaviour==grow_shrink,
00774           <a class="code" href="classstxxl_1_1grow__shrink__stack.html">grow_shrink_stack&lt;cfg&gt;</a>,
00775           <a class="code" href="classstxxl_1_1grow__shrink__stack2.html">grow_shrink_stack2&lt;cfg&gt;</a> &gt;<a class="code" href="structstxxl_1_1IF.html">::result</a> <a class="code" href="structstxxl_1_1IF.html">GrShrTp</a>;
00776   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1IF.html">IF&lt;Behaviour==normal, normal_stack&lt;cfg&gt;</a>, <a class="code" href="structstxxl_1_1IF.html">GrShrTp</a> &gt;<a class="code" href="structstxxl_1_1IF.html">::result</a> <a class="code" href="structstxxl_1_1IF.html">ExtStackTp</a>;
00777   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1IF.html">IF</a>&lt;Externality==migrating, 
00778     <a class="code" href="classstxxl_1_1migrating__stack.html">migrating_stack&lt;MigrCritSize,ExtStackTp,IntStackTp&gt;</a>,<a class="code" href="structstxxl_1_1IF.html">ExtStackTp</a>&gt;<a class="code" href="structstxxl_1_1IF.html">::result</a> <a class="code" href="structstxxl_1_1IF.html">MigrOrNotStackTp</a>;
00779   
00780 <span class="keyword">public</span>:
00781   
00782   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1IF.html">IF&lt;Externality==internal,IntStackTp,MigrOrNotStackTp&gt;</a><a class="code" href="structstxxl_1_1IF.html">::result</a> <a class="code" href="structstxxl_1_1IF.html">result</a>;
00783 
00784 };
00785 
00787 
00788 __STXXL_END_NAMESPACE
00789  
00790 <span class="preprocessor"> #endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Nov 21 15:28:12 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
