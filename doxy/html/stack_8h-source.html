<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>stack.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>stack.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef STXXL_STACK_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_STACK_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            stack.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Tue May 27 14:12:24 2003</span>
00008 <span class="comment"> *  Copyright  2003  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 
00013 <span class="preprocessor">#include "../common/utils.h"</span>
00014 <span class="preprocessor">#include "../mng/mng.h"</span>
00015 <span class="preprocessor">#include "../common/simple_vector.h"</span>
00016 <span class="preprocessor">#include "../common/tmeta.h"</span>
00017 <span class="preprocessor">#include &lt;stack&gt;</span>
00018 <span class="preprocessor">#include &lt;vector&gt;</span>
00019  
00020  
00021  __STXXL_BEGIN_NAMESPACE
00022  
00025  
00026  <span class="keyword">template</span> &lt;<span class="keyword">class </span>ValTp,
00027            <span class="keywordtype">unsigned</span> BlocksPerPage = 4,
00028            <span class="keywordtype">unsigned</span> BlkSz = STXXL_DEFAULT_BLOCK_SIZE(ValTp),
00029            <span class="keyword">class </span>AllocStr = STXXL_DEFAULT_ALLOC_STRATEGY,
00030            <span class="keyword">class </span>SzTp = off_t&gt;
00031  <span class="keyword">struct </span>stack_config_generator
00032  {
00033    <span class="keyword">typedef</span> ValTp value_type;
00034    <span class="keyword">enum</span> { blocks_per_page = BlocksPerPage };
00035    <span class="keyword">typedef</span> AllocStr alloc_strategy;
00036    <span class="keyword">enum</span> { block_size = BlkSz };
00037    <span class="keyword">typedef</span> SzTp size_type;
00038  };
00039 
00040  
00042  
<a name="l00048"></a><a class="code" href="classstxxl_1_1normal__stack.html">00048</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
00049 <span class="keyword">class </span><a class="code" href="classstxxl_1_1normal__stack.html">normal_stack</a>
00050 {
00051 <span class="keyword">public</span>:
00052   <span class="keyword">typedef</span> Config_ cfg;
00053   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::value_type value_type;
00054   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::alloc_strategy alloc_strategy;
00055   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::size_type size_type;
00056   <span class="keyword">enum</span> {  blocks_per_page = cfg::blocks_per_page,
00057           block_size = cfg::block_size,
00058        };
00059           
00060   <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;block_size,value_type&gt;</a> block_type;
00061   <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;block_size&gt;</a> bid_type;
00062 
00063 <span class="keyword">private</span>:
00064   size_type size_;
00065   <span class="keywordtype">unsigned</span> cache_offset;
00066   value_type * current_element;
00067   simple_vector&lt;block_type&gt; cache;
00068   <span class="keyword">typename</span> simple_vector&lt;block_type&gt;::iterator front_page;
00069   <span class="keyword">typename</span> simple_vector&lt;block_type&gt;::iterator back_page;
00070   std::vector&lt;bid_type&gt; bids;
00071   alloc_strategy alloc_strategy_;
00072 <span class="keyword">public</span>:
00073   <a class="code" href="classstxxl_1_1normal__stack.html">normal_stack</a>(): 
00074            size_(0),
00075            cache_offset(0),
00076            current_element(NULL),
00077            cache(blocks_per_page*2),
00078            front_page(cache.begin() + blocks_per_page),
00079            back_page(cache.begin()),
00080            bids(0)
00081   {
00082     bids.reserve(blocks_per_page);
00083   }
<a name="l00087"></a><a class="code" href="classstxxl_1_1normal__stack.html#a1">00087</a>   <span class="keyword">template</span> &lt;<span class="keyword">class</span> stack_type&gt;
00088   <a class="code" href="classstxxl_1_1normal__stack.html">normal_stack</a>(<span class="keyword">const</span> stack_type &amp; stack_): 
00089            size_(0),
00090            cache_offset(0),
00091            current_element(NULL),
00092            cache(blocks_per_page*2),
00093            front_page(cache.begin() + blocks_per_page),
00094            back_page(cache.begin()),
00095            bids(0)
00096   {
00097     bids.reserve(blocks_per_page);
00098     
00099     stack_type stack_copy = stack_;
00100     <span class="keyword">const</span> size_type sz=stack_copy.size();
00101     size_type i;
00102     
00103     std::vector&lt;value_type&gt; tmp(sz);
00104     
00105     <span class="keywordflow">for</span>(i=0;i&lt;sz;i++)
00106     {
00107       tmp[sz - i - 1] = stack_copy.top();
00108       stack_copy.pop();
00109     }
00110     <span class="keywordflow">for</span>(i=0;i&lt;sz;i++)
00111       this-&gt;push(tmp[i]);
00112     
00113   }
00114   <span class="keyword">virtual</span> ~normal_stack()
00115   {
00116     STXXL_VERBOSE(__PRETTY_FUNCTION__);
00117     block_manager::get_instance()-&gt;delete_blocks(bids.begin(),bids.end());
00118   }
00119   size_type size()<span class="keyword"> const</span>
00120 <span class="keyword">  </span>{
00121     <span class="keywordflow">return</span> size_;
00122   }
00123   <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
00124 <span class="keyword">  </span>{
00125     <span class="keywordflow">return</span> (!size_);
00126   }
00127   value_type &amp; top()
00128   {
00129     assert(size_ &gt; 0);
00130     <span class="keywordflow">return</span> (*current_element);
00131   }
00132   <span class="keyword">const</span> value_type &amp; top()<span class="keyword"> const</span>
00133 <span class="keyword">  </span>{
00134     assert(size_ &gt; 0);
00135     <span class="keywordflow">return</span> (*current_element);
00136   }
00137   <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; val)
00138   {
00139     assert(cache_offset &lt;= 2*blocks_per_page*block_type::size);
00140     assert(cache_offset &gt;= 0);
00141     
00142     <span class="keywordflow">if</span>(cache_offset == 2*blocks_per_page*block_type::size) <span class="comment">// cache overflow</span>
00143     {
00144       STXXL_VERBOSE2(<span class="stringliteral">"growing, size: "</span>&lt;&lt;size_)
00145       
00146       bids.resize(bids.size() + blocks_per_page);
00147       <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::iterator cur_bid = bids.end() - blocks_per_page;
00148       block_manager::get_instance()-&gt;new_blocks(
00149           offset_allocator&lt;alloc_strategy&gt;(cur_bid-bids.begin(),alloc_strategy_),cur_bid,bids.end());
00150       
00151       simple_vector&lt;request_ptr&gt; requests(blocks_per_page);
00152       
00153       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;blocks_per_page;i++,cur_bid++)
00154       {
00155         requests[i] = (back_page + i)-&gt;write(*cur_bid);
00156       }
00157       
00158       
00159       std::swap(back_page,front_page);
00160       
00161       bids.reserve(bids.size() + blocks_per_page);
00162       
00163       cache_offset = blocks_per_page*block_type::size + 1;
00164       current_element = &amp;((*front_page)[0]);
00165       ++size_;
00166       
00167       <a class="code" href="group__iolayer.html#a3">wait_all</a>(requests.begin(),blocks_per_page);
00168       
00169       *current_element=val;
00170       
00171       <span class="keywordflow">return</span>;
00172     }
00173     
00174     current_element = element(cache_offset);
00175     *current_element=val;
00176     ++size_;
00177     ++cache_offset;
00178   }
00179   <span class="keywordtype">void</span> pop()
00180   {
00181     assert(cache_offset &lt;= 2*blocks_per_page*block_type::size);
00182     assert(cache_offset &gt; 0);
00183     assert(size_ &gt; 0);
00184     
00185     <span class="keywordflow">if</span>(cache_offset == 1 &amp;&amp; bids.size() &gt;= blocks_per_page)
00186     { 
00187       STXXL_VERBOSE2(<span class="stringliteral">"shrinking, size: "</span>&lt;&lt;size_)
00188      
00189       simple_vector&lt;request_ptr&gt; requests(blocks_per_page);
00190       
00191       <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::const_iterator cur_bid = bids.end() - 1;
00192       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=blocks_per_page-1 ;i&gt;=0;i--,cur_bid--)
00193         requests[i] = (front_page+i)-&gt;read(*cur_bid);
00194         
00195       std::swap(front_page,back_page);
00196             
00197       cache_offset = blocks_per_page*block_type::size;
00198       --size_;
00199       current_element = &amp;((*(back_page+(blocks_per_page - 1)))[block_type::size - 1]);
00200       
00201       <a class="code" href="group__iolayer.html#a3">wait_all</a>(requests.begin(),blocks_per_page);
00202       
00203       block_manager::get_instance()-&gt;delete_blocks(bids.end() - blocks_per_page,bids.end());
00204       bids.resize(bids.size() - blocks_per_page);
00205       
00206       <span class="keywordflow">return</span>;
00207     }
00208        
00209     --size_;
00210     
00211     current_element = element((--cache_offset) - 1);
00212   }
00213 <span class="keyword">private</span>:
00214   value_type * element(<span class="keywordtype">unsigned</span> offset)
00215   {
00216     <span class="keywordflow">if</span>(offset &lt; blocks_per_page*block_type::size)
00217       <span class="keywordflow">return</span> &amp;((*(back_page + offset/block_type::size))[offset%block_type::size]);
00218     
00219     <span class="keywordtype">unsigned</span> unbiased_offset = offset - blocks_per_page*block_type::size;
00220     <span class="keywordflow">return</span> &amp;((*(front_page + unbiased_offset/block_type::size))[unbiased_offset%block_type::size]);
00221   }
00222 };
00223 
00224 
00226 
<a name="l00229"></a><a class="code" href="classstxxl_1_1grow__shrink__stack.html">00229</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> Config_&gt;
00230 <span class="keyword">class </span><a class="code" href="classstxxl_1_1grow__shrink__stack.html">grow_shrink_stack</a>
00231 {
00232 <span class="keyword">public</span>:
00233   <span class="keyword">typedef</span> Config_ cfg;
00234   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::value_type value_type;
00235   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::alloc_strategy alloc_strategy;
00236   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::size_type size_type;
00237   <span class="keyword">enum</span> {  blocks_per_page = cfg::blocks_per_page,
00238           block_size = cfg::block_size,
00239        };
00240           
00241   <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;block_size,value_type&gt;</a> block_type;
00242   <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;block_size&gt;</a> bid_type;
00243 
00244 <span class="keyword">private</span>:
00245   size_type size_;
00246   <span class="keywordtype">unsigned</span> cache_offset;
00247   value_type * current_element;
00248   simple_vector&lt;block_type&gt; cache;
00249   <span class="keyword">typename</span> simple_vector&lt;block_type&gt;::iterator cache_buffers;
00250   <span class="keyword">typename</span> simple_vector&lt;block_type&gt;::iterator overlap_buffers;
00251   simple_vector&lt;request_ptr&gt; requests;
00252   std::vector&lt;bid_type&gt; bids;
00253   alloc_strategy alloc_strategy_;
00254 <span class="keyword">public</span>:
00255   <a class="code" href="classstxxl_1_1grow__shrink__stack.html">grow_shrink_stack</a>(): 
00256            size_(0),
00257            cache_offset(0),
00258            current_element(NULL),
00259            cache(blocks_per_page*2),
00260            cache_buffers(cache.begin()),
00261            overlap_buffers(cache.begin() + blocks_per_page),
00262            requests(blocks_per_page),
00263            bids(0)
00264   {
00265     bids.reserve(blocks_per_page);
00266   }
<a name="l00270"></a><a class="code" href="classstxxl_1_1grow__shrink__stack.html#a1">00270</a>   <span class="keyword">template</span> &lt;<span class="keyword">class</span> stack_type&gt;
00271   <a class="code" href="classstxxl_1_1grow__shrink__stack.html">grow_shrink_stack</a>(<span class="keyword">const</span> stack_type &amp; stack_): 
00272            size_(0),
00273            cache_offset(0),
00274            current_element(NULL),
00275            cache(blocks_per_page*2),
00276            cache_buffers(cache.begin()),
00277            overlap_buffers(cache.begin() + blocks_per_page),
00278            requests(blocks_per_page),
00279            bids(0)
00280   {
00281     bids.reserve(blocks_per_page);
00282     
00283     stack_type stack_copy = stack_;
00284     <span class="keyword">const</span> size_type sz=stack_copy.size();
00285     size_type i;
00286     
00287     std::vector&lt;value_type&gt; tmp(sz);
00288     
00289     <span class="keywordflow">for</span>(i=0;i&lt;sz;i++)
00290     {
00291       tmp[sz - i - 1] = stack_copy.top();
00292       stack_copy.pop();
00293     }
00294     <span class="keywordflow">for</span>(i=0;i&lt;sz;i++)
00295       this-&gt;push(tmp[i]);
00296     
00297   }
00298   <span class="keyword">virtual</span> ~grow_shrink_stack()
00299   {
00300     STXXL_VERBOSE(__PRETTY_FUNCTION__);
00301     <span class="keywordflow">if</span>(requests[0].get()) <a class="code" href="group__iolayer.html#a3">wait_all</a>(requests.begin(),blocks_per_page);  
00302     block_manager::get_instance()-&gt;delete_blocks(bids.begin(),bids.end());
00303   }
00304   size_type size()<span class="keyword"> const</span>
00305 <span class="keyword">  </span>{
00306     <span class="keywordflow">return</span> size_;
00307   }
00308   <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
00309 <span class="keyword">  </span>{
00310     <span class="keywordflow">return</span> (!size_);
00311   }
00312   value_type &amp; top()
00313   {
00314     assert(size_ &gt; 0);
00315     <span class="keywordflow">return</span> (*current_element);
00316   }
00317   <span class="keyword">const</span> value_type &amp; top()<span class="keyword"> const</span>
00318 <span class="keyword">  </span>{
00319     assert(size_ &gt; 0);
00320     <span class="keywordflow">return</span> (*current_element);
00321   }
00322   <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; val)
00323   {
00324     assert(cache_offset &lt;= blocks_per_page*block_type::size);
00325     assert(cache_offset &gt;= 0);
00326     
00327     <span class="keywordflow">if</span>(cache_offset == blocks_per_page*block_type::size) <span class="comment">// cache overflow</span>
00328     {
00329       STXXL_VERBOSE2(<span class="stringliteral">"growing, size: "</span>&lt;&lt;size_)
00330       
00331       bids.resize(bids.size() + blocks_per_page);
00332       <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::iterator cur_bid = bids.end() - blocks_per_page;
00333       block_manager::get_instance()-&gt;new_blocks(
00334           offset_allocator&lt;alloc_strategy&gt;(cur_bid-bids.begin(),alloc_strategy_),cur_bid,bids.end());
00335       
00336       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;blocks_per_page;i++,cur_bid++)
00337       {
00338         <span class="keywordflow">if</span>(requests[i].get()) requests[i]-&gt;wait();
00339         requests[i] = (cache_buffers + i)-&gt;write(*cur_bid);
00340       }
00341       
00342       std::swap(cache_buffers,overlap_buffers);
00343       
00344       bids.reserve(bids.size() + blocks_per_page);
00345       
00346       cache_offset = 1;
00347       current_element = &amp;((*cache_buffers)[0]);
00348       ++size_;
00349  
00350       *current_element=val;
00351       
00352       <span class="keywordflow">return</span>;
00353     }
00354     
00355     current_element = &amp;((*(cache_buffers + cache_offset/block_type::size))[cache_offset%block_type::size]);
00356     *current_element=val;
00357     ++size_;
00358     ++cache_offset;
00359   }
00360   <span class="keywordtype">void</span> pop()
00361   {
00362     assert(cache_offset &lt;= blocks_per_page*block_type::size);
00363     assert(cache_offset &gt; 0);
00364     assert(size_ &gt; 0);
00365     
00366     <span class="keywordflow">if</span>(cache_offset == 1 &amp;&amp; bids.size() &gt;= blocks_per_page)
00367     { 
00368       STXXL_VERBOSE2(<span class="stringliteral">"shrinking, size: "</span>&lt;&lt;size_)
00369       
00370       <span class="keywordflow">if</span>(requests[0].get())
00371         <a class="code" href="group__iolayer.html#a3">wait_all</a>(requests.begin(),blocks_per_page);
00372       
00373       std::swap(cache_buffers,overlap_buffers);
00374       
00375       <span class="keywordflow">if</span>(bids.size() &gt; blocks_per_page)
00376       {
00377         STXXL_VERBOSE2(<span class="stringliteral">"prefetching, size: "</span>&lt;&lt;size_)
00378         <span class="keyword">typename</span> std::vector&lt;bid_type&gt;::const_iterator cur_bid = bids.end() - blocks_per_page - 1;
00379         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=blocks_per_page-1 ;i&gt;=0;i--,cur_bid--)
00380           requests[i] = (overlap_buffers+i)-&gt;read(*cur_bid);
00381         
00382       }
00383             
00384       block_manager::get_instance()-&gt;delete_blocks(bids.end() - blocks_per_page,bids.end());
00385       bids.resize(bids.size() - blocks_per_page);
00386       
00387       cache_offset = blocks_per_page*block_type::size;
00388       --size_;
00389       current_element = &amp;((*(cache_buffers+(blocks_per_page - 1)))[block_type::size - 1]);
00390       
00391       <span class="keywordflow">return</span>;
00392     }
00393        
00394     --size_;
00395     <span class="keywordtype">unsigned</span> cur_offset = (--cache_offset) - 1;
00396     current_element = &amp;((*(cache_buffers + cur_offset/block_type::size))[cur_offset%block_type::size]);
00397     
00398   }
00399   
00400 };
00401 
00403 
<a name="l00405"></a><a class="code" href="classstxxl_1_1migrating__stack.html">00405</a> <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> CritSize, <span class="keyword">class</span> ExternalStack, <span class="keyword">class</span> InternalStack&gt;
00406 <span class="keyword">class </span><a class="code" href="classstxxl_1_1migrating__stack.html">migrating_stack</a>
00407 {
00408 <span class="keyword">public</span>:
00409   <span class="keyword">typedef</span> <span class="keyword">typename</span> ExternalStack::cfg cfg;
00410   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::value_type value_type;
00411   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::alloc_strategy alloc_strategy;
00412   <span class="keyword">typedef</span> <span class="keyword">typename</span> cfg::size_type size_type;
00413   <span class="keyword">enum</span> {  blocks_per_page = cfg::blocks_per_page,
00414           block_size = cfg::block_size };
00415           
00416           
00417   <span class="keyword">typedef</span> InternalStack int_stack_type;
00418   <span class="keyword">typedef</span> ExternalStack ext_stack_type;
00419   
00420 <span class="keyword">private</span>:
00421   <span class="keyword">enum</span> { critical_size = CritSize };
00422     
00423   int_stack_type * int_impl;
00424   ext_stack_type * ext_impl;
00425 
00426 <span class="keyword">public</span>:
00427   <a class="code" href="classstxxl_1_1migrating__stack.html">migrating_stack</a>(): int_impl(<span class="keyword">new</span> int_stack_type()),ext_impl(NULL) {}
00428   <span class="keyword">template</span> &lt;<span class="keyword">class</span> stack_type&gt;
00429   <a class="code" href="classstxxl_1_1migrating__stack.html">migrating_stack</a>(<span class="keyword">const</span> stack_type &amp; stack_)
00430   {
00431     STXXL_ERRMSG(__PRETTY_FUNCTION__ &lt;&lt; <span class="stringliteral">" is NOT IMPLEMENTED, aborting."</span>)
00432     abort();
00433   } 
00435   <span class="keywordtype">bool</span> internal() 
00436   { 
00437     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00438     <span class="keywordflow">return</span> int_impl; 
00439   }
00441   <span class="keywordtype">bool</span> external() 
00442   {
00443     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00444     <span class="keywordflow">return</span> ext_impl; 
00445   }
00446   
00447   <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
00448 <span class="keyword">  </span>{
00449     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00450     
00451     <span class="keywordflow">if</span>(int_impl)
00452       <span class="keywordflow">return</span> int_impl-&gt;empty();
00453     
00454     <span class="keywordflow">return</span> ext_impl-&gt;empty();
00455   }
00456   size_type size()<span class="keyword"> const</span>
00457 <span class="keyword">  </span>{
00458     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00459     
00460     <span class="keywordflow">if</span>(int_impl)
00461       <span class="keywordflow">return</span> int_impl-&gt;size();
00462     
00463     <span class="keywordflow">return</span> ext_impl-&gt;size();
00464   }
00465   value_type &amp; top()
00466   {
00467     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00468     
00469     <span class="keywordflow">if</span>(int_impl)
00470       <span class="keywordflow">return</span> int_impl-&gt;top();
00471     
00472     <span class="keywordflow">return</span> ext_impl-&gt;top();
00473   }
00474   <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; val)
00475   {
00476     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00477     
00478     <span class="keywordflow">if</span>(int_impl)
00479     {
00480       int_impl-&gt;push(val);
00481       <span class="keywordflow">if</span>(int_impl-&gt;size() == critical_size)
00482       {
00483         <span class="comment">// migrate to external stack</span>
00484         ext_impl = <span class="keyword">new</span> ext_stack_type(*int_impl);
00485         <span class="keyword">delete</span> int_impl;
00486         int_impl = NULL;
00487       }
00488     }
00489     <span class="keywordflow">else</span>
00490       ext_impl-&gt;push(val);
00491   }
00492   <span class="keywordtype">void</span> pop()
00493   {
00494     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00495     
00496     <span class="keywordflow">if</span>(int_impl)
00497       int_impl-&gt;pop();
00498     <span class="keywordflow">else</span>
00499       ext_impl-&gt;pop();
00500   }
00501   <span class="keyword">virtual</span> ~<a class="code" href="classstxxl_1_1migrating__stack.html">migrating_stack</a>()
00502   {
00503     assert((int_impl &amp;&amp; !ext_impl)||(!int_impl &amp;&amp; ext_impl));
00504     
00505     <span class="keywordflow">if</span>(int_impl)
00506       <span class="keyword">delete</span> int_impl;
00507     <span class="keywordflow">else</span>
00508       <span class="keyword">delete</span> ext_impl;
00509   }
00510 };
00511 
00513 
00514 <span class="comment">/*</span>
00515 <span class="comment">template &lt;class BaseStack&gt;</span>
00516 <span class="comment">class stack: public BaseStack</span>
00517 <span class="comment">{</span>
00518 <span class="comment">public:</span>
00519 <span class="comment">  typedef typename BaseStack::cfg cfg;</span>
00520 <span class="comment">  typedef typename cfg::value_type value_type;</span>
00521 <span class="comment">  typedef typename cfg::alloc_strategy alloc_strategy;</span>
00522 <span class="comment">  typedef typename cfg::size_type size_type;</span>
00523 <span class="comment">  enum {  blocks_per_page = cfg::blocks_per_page,</span>
00524 <span class="comment">          block_size = cfg::block_size };</span>
00525 <span class="comment">  </span>
00526 <span class="comment">  stack() : BaseStack() {}</span>
00527 <span class="comment">    </span>
00531 <span class="comment">  template &lt;class stack_type&gt;</span>
00532 <span class="comment">  stack(const stack_type &amp; stack_) : BaseStack(stack_) {} </span>
00533 <span class="comment">};</span>
00534 <span class="comment">*/</span>
00535 
00538 
00539 <span class="keyword">enum</span> stack_externality { external, migrating, internal };
00540 <span class="keyword">enum</span> stack_behaviour { normal, grow_shrink };
00541 
00543 
00578 <span class="keyword">template</span>  &lt;
00579             <span class="keyword">class </span>ValTp,
00580             stack_externality  Externality = external,
00581             stack_behaviour    Behaviour = normal,
00582             <span class="keywordtype">unsigned</span> BlocksPerPage = 4,
00583             <span class="keywordtype">unsigned</span> BlkSz = STXXL_DEFAULT_BLOCK_SIZE(ValTp),
00584 
00585             <span class="keyword">class </span>IntStackTp = std::stack&lt;ValTp&gt;,
00586             <span class="keywordtype">unsigned</span> MigrCritSize = (2*BlocksPerPage*BlkSz),
00587 
00588             <span class="keyword">class </span>AllocStr = STXXL_DEFAULT_ALLOC_STRATEGY,
00589             <span class="keyword">class </span>SzTp = off_t
<a name="l00590"></a><a class="code" href="classstxxl_1_1STACK__GENERATOR.html">00590</a>           &gt;
00591 <span class="keyword">class </span><a class="code" href="classstxxl_1_1STACK__GENERATOR.html">STACK_GENERATOR</a>
00592 {
00593   <span class="keyword">typedef</span> stack_config_generator&lt;ValTp,BlocksPerPage,BlkSz,AllocStr,SzTp&gt; cfg;
00594   
00595   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1IF.html">IF&lt;Behaviour==normal, normal_stack&lt;cfg&gt;</a>,<a class="code" href="classstxxl_1_1grow__shrink__stack.html">grow_shrink_stack&lt;cfg&gt;</a> &gt;::result ExtStackTp;
00596   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1IF.html">IF</a>&lt;Externality==migrating, 
00597     <a class="code" href="classstxxl_1_1migrating__stack.html">migrating_stack&lt;MigrCritSize,ExtStackTp,IntStackTp&gt;</a>,ExtStackTp&gt;::result MigrOrNotStackTp;
00598   
00599 <span class="keyword">public</span>:
00600   
00601   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1IF.html">IF&lt;Externality==internal,IntStackTp,MigrOrNotStackTp&gt;</a>::result result;
00602 
00603 };
00604 
00606 
00607 __STXXL_END_NAMESPACE
00608  
00609 <span class="preprocessor"> #endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Jul 1 11:08:36 2003 for &lt;stxxl&gt; by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
