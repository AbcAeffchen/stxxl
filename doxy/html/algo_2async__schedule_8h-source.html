<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: async_schedule.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>async_schedule.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef ASYNC_SCHEDULE_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define ASYNC_SCHEDULE_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            async_schedule.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Fri Oct 25 16:08:06 2002</span>
00008 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 <span class="preprocessor">#include "../io/io.h"</span>
00012 <span class="preprocessor">#include "../common/utils.h"</span>
00013 <span class="preprocessor">#include &lt;queue&gt;</span>
00014 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00015 
00016 __STXXL_BEGIN_NAMESPACE
00017 
00018 <span class="keyword">struct </span>sim_event <span class="comment">// only one type of event: WRITE COMPLETED</span>
00019 {
00020         <span class="keywordtype">int</span> timestamp;
00021         <span class="keywordtype">int</span> iblock;
00022         sim_event(<span class="keywordtype">int</span> t, <span class="keywordtype">int</span> b):timestamp(t),iblock(b) {};
00023 };
00024 
00025 <span class="keyword">struct </span>sim_event_cmp
00026 {
00027         <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> sim_event &amp; a, <span class="keyword">const</span> sim_event &amp; b)<span class="keyword"> const</span>
00028 <span class="keyword">        </span>{
00029                 <span class="keywordflow">return</span> a.timestamp &gt; b.timestamp;
00030         }
00031 };
00032 
00033 <span class="keywordtype">int</span> simulate_async_write(
00034         <span class="keywordtype">int</span> *disks,
00035         <span class="keyword">const</span> <span class="keywordtype">int</span> L,
00036         <span class="keyword">const</span> <span class="keywordtype">int</span> m_init,
00037         <span class="keyword">const</span> <span class="keywordtype">int</span> D,
00038         std::pair&lt;int,int&gt; * o_time)
00039 {
00040         <span class="keyword">typedef</span> std::priority_queue&lt;sim_event,std::vector&lt;sim_event&gt;,sim_event_cmp&gt; event_queue_type;
00041         <span class="keyword">typedef</span> std::queue&lt;int&gt; disk_queue_type;
00042         
00043         disk_queue_type * disk_queues = <span class="keyword">new</span> disk_queue_type[L];
00044         event_queue_type event_queue;
00045         
00046         <span class="keywordtype">int</span> m = m_init;
00047         <span class="keywordtype">int</span> i = L - 1;
00048         <span class="keywordtype">int</span> oldtime = 0;
00049         <span class="keywordtype">bool</span> * disk_busy = <span class="keyword">new</span> <span class="keywordtype">bool</span> [D];
00050 
00051         <span class="keywordflow">while</span>(m &amp;&amp; (i&gt;=0))
00052         {
00053                 <span class="keywordtype">int</span> disk = disks[i];
00054                 disk_queues[disk].push(i);
00055                 i--;
00056                 m--;
00057         }
00058         
00059         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;D;i++)
00060                 <span class="keywordflow">if</span>(!disk_queues[i].empty())
00061                 {
00062                         <span class="keywordtype">int</span> j = disk_queues[i].front();
00063                         disk_queues[i].pop();
00064                         event_queue.push(sim_event(1,j));
00065 <span class="comment">//                      STXXL_MSG("Block "&lt;&lt;j&lt;&lt;" scheduled")</span>
00066                 }
00067         
00068         <span class="keywordflow">while</span>(! event_queue.empty())
00069         {
00070                 sim_event cur = event_queue.top();
00071                 event_queue.pop();
00072                 <span class="keywordflow">if</span>(oldtime != cur.timestamp)
00073                 {
00074                         <span class="comment">// clear disk_busy</span>
00075                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;D;i++)
00076                                 disk_busy[i] = <span class="keyword">false</span>;
00077                         oldtime = cur.timestamp;
00078                 }
00079                         
00080                 
00081                 STXXL_MSG(<span class="stringliteral">"Block "</span>&lt;&lt; cur.iblock &lt;&lt;<span class="stringliteral">" put out, time "</span> &lt;&lt; cur.timestamp&lt;&lt;<span class="stringliteral">" disk: "</span>&lt;&lt;disks[cur.iblock])
00082                 o_time[cur.iblock] = std::pair&lt;int,int&gt;(cur.iblock,cur.timestamp);
00083                 
00084                 m++;
00085                 <span class="keywordflow">if</span>(i &gt;= 0)
00086                 {
00087                         m--;
00088                         <span class="keywordtype">int</span> disk = disks[i];
00089                         <span class="keywordflow">if</span>(disk_busy[disk])
00090                         {
00091                                 disk_queues[disk].push(i);
00092                         }
00093                         <span class="keywordflow">else</span>
00094                         {
00095 <span class="comment">//                              STXXL_MSG("Block "&lt;&lt;i&lt;&lt;" scheduled for time "&lt;&lt; cur.timestamp + 1)</span>
00096                                 event_queue.push(sim_event(cur.timestamp + 1, i));
00097                                 disk_busy[disk] = <span class="keyword">true</span>;
00098                         }       
00099                         
00100                         i--;
00101                 }
00102                 
00103                 <span class="comment">// add next block to write</span>
00104                 <span class="keywordtype">int</span> disk = disks[cur.iblock];
00105                 <span class="keywordflow">if</span>(!disk_busy[disk] &amp;&amp; !disk_queues[disk].empty())
00106                 {
00107 <span class="comment">//                      STXXL_MSG("Block "&lt;&lt;disk_queues[disk].front()&lt;&lt;" scheduled for time "&lt;&lt; cur.timestamp + 1)</span>
00108                         event_queue.push(sim_event(cur.timestamp + 1,disk_queues[disk].front()));
00109                         disk_queues[disk].pop();
00110                         disk_busy[disk] = <span class="keyword">true</span>;
00111                 }
00112                 
00113         };
00114         
00115         assert(m == m_init );
00116         assert(i == -1);
00117         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;D;i++)
00118                 assert(disk_queues[i].empty());
00119         
00120         <span class="keyword">delete</span> [] disk_busy;
00121         <span class="keyword">delete</span> [] disk_queues;
00122 
00123         <span class="keywordflow">return</span> (oldtime - 1);
00124 }
00125 
00126 
00127 <span class="keyword">struct </span>write_time_cmp
00128 {
00129         <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> std::pair&lt;int,int&gt; &amp; a, <span class="keyword">const</span> std::pair&lt;int,int&gt; &amp; b)
00130         {
00131                 <span class="keywordflow">return</span> a.second &gt; b.second;
00132         }
00133 };
00134 
00135 <span class="keywordtype">void</span> compute_prefetch_schedule(
00136                 <span class="keywordtype">int</span> * first,
00137                 <span class="keywordtype">int</span> * last,
00138                 <span class="keywordtype">int</span> * out_first,
00139                 <span class="keywordtype">int</span> m,
00140                 <span class="keywordtype">int</span> D)
00141 {
00142         <span class="keyword">typedef</span> std::pair&lt;int,int&gt;  pair_type;
00143         <span class="keywordtype">int</span> L = last - first;
00144         pair_type * write_order = <span class="keyword">new</span> pair_type[L];
00145         
00146         <span class="keywordtype">int</span> w_steps=simulate_async_write(first,L,m,D,write_order);
00147         
00148         STXXL_MSG(<span class="stringliteral">"Write steps: "</span> &lt;&lt; w_steps )
00149         
00150         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;L;i++)
00151                 STXXL_MSG(first[i] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; write_order[i].first &lt;&lt; <span class="stringliteral">" "</span>&lt;&lt; write_order[i].second )
00152 
00153         std::stable_sort(write_order,write_order + L,write_time_cmp());
00154         
00155         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;L;i++)
00156         {
00157                 out_first[i] = write_order[i].first;
00158                 <span class="comment">//if(out_first[i] != i)</span>
00159                         STXXL_MSG(i &lt;&lt; <span class="stringliteral">" "</span>&lt;&lt; out_first[i])
00160         }
00161         
00162         <span class="keyword">delete</span> [] write_order;
00163 }
00164 
00165 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> run_type&gt;
00166 <span class="keywordtype">void</span> simulate_async_write(
00167                                                                                         <span class="keyword">const</span> run_type &amp; input,
00168                                                                                         <span class="keyword">const</span> <span class="keywordtype">int</span> m_init,
00169                                                                                         <span class="keyword">const</span> <span class="keywordtype">int</span> D,
00170                                                                                         std::pair&lt;int,int&gt; * o_time)
00171 {
00172         <span class="keyword">typedef</span> std::priority_queue&lt;sim_event,std::vector&lt;sim_event&gt;,sim_event_cmp&gt; event_queue_type;
00173         <span class="keyword">typedef</span> std::queue&lt;int&gt; disk_queue_type;
00174         
00175         <span class="keyword">const</span> <span class="keywordtype">int</span> L = input.size();
00176         disk_queue_type * disk_queues = <span class="keyword">new</span> disk_queue_type[L];
00177         event_queue_type event_queue;
00178         
00179         <span class="keywordtype">int</span> m = m_init;
00180         <span class="keywordtype">int</span> i = L - 1;
00181         <span class="keywordtype">int</span> oldtime = 0;
00182         <span class="keywordtype">bool</span> * disk_busy = <span class="keyword">new</span> <span class="keywordtype">bool</span> [D];
00183                        
00184         <span class="keywordflow">while</span>(m &amp;&amp; (i&gt;=0))
00185         {
00186                 <span class="keywordtype">int</span> disk = input[i].bid.storage-&gt;get_disk_number();
00187                 disk_queues[disk].push(i);
00188                 i--;
00189                 m--;
00190         }
00191         
00192         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;D;i++)
00193                 <span class="keywordflow">if</span>(!disk_queues[i].empty())
00194                 {
00195                         <span class="keywordtype">int</span> j = disk_queues[i].front();
00196                         disk_queues[i].pop();
00197                         event_queue.push(sim_event(1,j));
00198                 }
00199         
00200         <span class="keywordflow">while</span>(! event_queue.empty())
00201         {
00202                 sim_event cur = event_queue.top();
00203                 event_queue.pop();
00204                 <span class="keywordflow">if</span>(oldtime != cur.timestamp)
00205     {
00206                         <span class="comment">// clear disk_busy</span>
00207                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;D;i++)
00208                                 disk_busy[i] = <span class="keyword">false</span>;
00209                         
00210                         oldtime = cur.timestamp;
00211     }
00212                 o_time[cur.iblock] = std::pair&lt;int,int&gt;(cur.iblock,cur.timestamp + 1);
00213                 
00214                 m++;
00215                 <span class="keywordflow">if</span>(i &gt;= 0)
00216                 {
00217                         m--;
00218                         <span class="keywordtype">int</span> disk = input[i].bid.storage-&gt;get_disk_number();
00219                         <span class="keywordflow">if</span>(disk_busy[disk])
00220                         {
00221                                 disk_queues[disk].push(i);
00222                         }
00223                         <span class="keywordflow">else</span>
00224                         {
00225                                 event_queue.push(sim_event(cur.timestamp + 1, i));
00226                                 disk_busy[disk] = <span class="keyword">true</span>;
00227                         }       
00228                         
00229                         i--;
00230                 }
00231                 
00232                 <span class="comment">// add next block to write</span>
00233                 <span class="keywordtype">int</span> disk = input[cur.iblock].bid.storage-&gt;get_disk_number();
00234                 <span class="keywordflow">if</span>(!disk_busy[disk] &amp;&amp; !disk_queues[disk].empty())
00235                 {
00236                         event_queue.push(sim_event(cur.timestamp + 1,disk_queues[disk].front()));
00237                         disk_queues[disk].pop();
00238                         disk_busy[disk] = <span class="keyword">true</span>;
00239                 }
00240                 
00241         };
00242         
00243         <span class="keyword">delete</span> [] disk_busy;
00244         <span class="keyword">delete</span> [] disk_queues;
00245 }
00246 
00247 
00248 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> run_type&gt;
00249 <span class="keywordtype">void</span> compute_prefetch_schedule(
00250                 <span class="keyword">const</span> run_type &amp; input,
00251                 <span class="keywordtype">int</span> * out_first,
00252                 <span class="keywordtype">int</span> m,
00253                 <span class="keywordtype">int</span> D)
00254 {
00255         <span class="keyword">typedef</span> std::pair&lt;int,int&gt;  pair_type;
00256         <span class="keyword">const</span> <span class="keywordtype">int</span> L = input.size();
00257         pair_type * write_order = <span class="keyword">new</span> pair_type[L];
00258         
00259         simulate_async_write(input,m,D,write_order);
00260         
00261         std::stable_sort(write_order,write_order + L,write_time_cmp());
00262         
00263         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;L;i++)
00264                 out_first[i] = write_order[i].first;
00265 
00266         <span class="keyword">delete</span> [] write_order;
00267 }
00268 
00269 
00270 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> bid_iterator_type&gt;
00271 <span class="keywordtype">void</span> simulate_async_write(
00272                                                                                         bid_iterator_type input,
00273                                                                                         <span class="keyword">const</span> <span class="keywordtype">int</span> L,
00274                                                                                         <span class="keyword">const</span> <span class="keywordtype">int</span> m_init,
00275                                                                                         <span class="keyword">const</span> <span class="keywordtype">int</span> D,
00276                                                                                         std::pair&lt;int,int&gt; * o_time)
00277 {
00278         <span class="keyword">typedef</span> std::priority_queue&lt;sim_event,std::vector&lt;sim_event&gt;,sim_event_cmp&gt; event_queue_type;
00279         <span class="keyword">typedef</span> std::queue&lt;int&gt; disk_queue_type;
00280         
00281         disk_queue_type * disk_queues = <span class="keyword">new</span> disk_queue_type[L];
00282         event_queue_type event_queue;
00283         
00284         <span class="keywordtype">int</span> m = m_init;
00285         <span class="keywordtype">int</span> i = L - 1;
00286         <span class="keywordtype">int</span> oldtime = 0;
00287         <span class="keywordtype">bool</span> * disk_busy = <span class="keyword">new</span> <span class="keywordtype">bool</span> [D];
00288                        
00289         <span class="keywordflow">while</span>(m &amp;&amp; (i&gt;=0))
00290         {
00291                 <span class="keywordtype">int</span> disk = (*(input + i)).storage-&gt;get_disk_number();
00292                 disk_queues[disk].push(i);
00293                 i--;
00294                 m--;
00295         }
00296         
00297         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;D;i++)
00298                 <span class="keywordflow">if</span>(!disk_queues[i].empty())
00299                 {
00300                         <span class="keywordtype">int</span> j = disk_queues[i].front();
00301                         disk_queues[i].pop();
00302                         event_queue.push(sim_event(1,j));
00303                 }
00304         
00305         <span class="keywordflow">while</span>(! event_queue.empty())
00306         {
00307                 sim_event cur = event_queue.top();
00308                 event_queue.pop();
00309                 <span class="keywordflow">if</span>(oldtime != cur.timestamp)
00310     {
00311                         <span class="comment">// clear disk_busy</span>
00312                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;D;i++)
00313                                 disk_busy[i] = <span class="keyword">false</span>;
00314                         
00315                         oldtime = cur.timestamp;
00316     }
00317                 o_time[cur.iblock] = std::pair&lt;int,int&gt;(cur.iblock,cur.timestamp + 1);
00318                 
00319                 m++;
00320                 <span class="keywordflow">if</span>(i &gt;= 0)
00321                 {
00322                         m--;
00323                         <span class="keywordtype">int</span> disk = (*(input + i)).storage-&gt;get_disk_number();
00324                         <span class="keywordflow">if</span>(disk_busy[disk])
00325                         {
00326                                 disk_queues[disk].push(i);
00327                         }
00328                         <span class="keywordflow">else</span>
00329                         {
00330                                 event_queue.push(sim_event(cur.timestamp + 1, i));
00331                                 disk_busy[disk] = <span class="keyword">true</span>;
00332                         }       
00333                         
00334                         i--;
00335                 }
00336                 
00337                 <span class="comment">// add next block to write</span>
00338                 <span class="keywordtype">int</span> disk = (*(input + cur.iblock)).storage-&gt;get_disk_number();
00339                 <span class="keywordflow">if</span>(!disk_busy[disk] &amp;&amp; !disk_queues[disk].empty())
00340                 {
00341                         event_queue.push(sim_event(cur.timestamp + 1,disk_queues[disk].front()));
00342                         disk_queues[disk].pop();
00343                         disk_busy[disk] = <span class="keyword">true</span>;
00344                 }
00345                 
00346         };
00347         
00348         <span class="keyword">delete</span> [] disk_busy;
00349         <span class="keyword">delete</span> [] disk_queues;
00350 }
00351 
00352 
00353 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> bid_iterator_type&gt;
00354 <span class="keywordtype">void</span> compute_prefetch_schedule(
00355                 bid_iterator_type input_begin,
00356                 bid_iterator_type input_end,
00357                 <span class="keywordtype">int</span> * out_first,
00358                 <span class="keywordtype">int</span> m,
00359                 <span class="keywordtype">int</span> D)
00360 {
00361         <span class="keyword">typedef</span> std::pair&lt;int,int&gt;  pair_type;
00362         <span class="keyword">const</span> <span class="keywordtype">int</span> L = input_end - input_begin;
00363         pair_type * write_order = <span class="keyword">new</span> pair_type[L];
00364         
00365         simulate_async_write(input_begin,L,m,D,write_order);
00366         
00367         std::stable_sort(write_order,write_order + L,write_time_cmp());
00368         
00369         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;L;i++)
00370                 out_first[i] = write_order[i].first;
00371 
00372         <span class="keyword">delete</span> [] write_order;
00373 }
00374 
00375 
00376 __STXXL_END_NAMESPACE
00377 
00378 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Nov 21 15:28:10 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
