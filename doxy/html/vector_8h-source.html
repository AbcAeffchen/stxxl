<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: vector.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>vector.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef STXXL_VECTOR_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_VECTOR_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            vector.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Sat Aug 24 23:54:35 2002</span>
00008 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 
00013 <span class="preprocessor">#include "../mng/mng.h"</span>
00014 <span class="preprocessor">#include "../common/tmeta.h"</span>
00015 <span class="preprocessor">#include "pager.h"</span>
00016 <span class="preprocessor">#include &lt;vector&gt;</span>
00017 
00018 
00019 <span class="keyword">namespace </span>stxxl
00020 {
00023   
00024         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BlkSize_ &gt;
00025                 <span class="keyword">class </span>bid_vector:<span class="keyword">public</span> std::vector &lt; BID &lt; BlkSize_ &gt; &gt;
00026         {
00027         <span class="keyword">public</span>:
00028                 <span class="keyword">enum</span>
00029                 { block_size = BlkSize_ };
00030                 <span class="keyword">typedef</span> bid_vector &lt; block_size &gt; _Self;
00031                 <span class="keyword">typedef</span> std::vector &lt; BID &lt; BlkSize_ &gt; &gt;_Derived;
00032                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> size_type;
00033 
00034                 bid_vector (size_type _sz):_Derived (_sz)
00035                 {
00036                 };
00037         };
00038   
00039 
00040         <span class="keyword">template</span> &lt; 
00041     <span class="keyword">typename</span> Tp_,
00042     <span class="keywordtype">unsigned</span> PgSz_,
00043     <span class="keyword">typename</span> PgTp_,
00044     <span class="keywordtype">unsigned</span> BlkSize_ ,
00045                 <span class="keyword">typename</span> AllocStr_ ,
00046     <span class="keyword">typename</span> SzTp_ &gt;
00047         <span class="keyword">class </span>vector;
00048         
00049         
00050         <span class="keyword">template</span> &lt; <span class="keyword">typename</span> Tp_, <span class="keyword">typename</span> AllocStr_, <span class="keyword">typename</span> SzTp_, <span class="keyword">typename</span> DiffTp_,
00051                         <span class="keywordtype">unsigned</span> BlkSize_,<span class="keyword">typename</span> PgTp_,<span class="keywordtype">unsigned</span> PgSz_ &gt; <span class="keyword">class </span>const_vector_iterator;
00052 
00053         
00055         <span class="keyword">template</span> &lt; <span class="keyword">typename</span> Tp_, <span class="keyword">typename</span> AllocStr_, <span class="keyword">typename</span> SzTp_,<span class="keyword">typename</span> DiffTp_,
00056                 <span class="keywordtype">unsigned</span> BlkSize_, <span class="keyword">typename</span> PgTp_, <span class="keywordtype">unsigned</span> PgSz_ &gt; 
<a name="l00057"></a><a class="code" href="classstxxl_1_1vector__iterator.html">00057</a>   <span class="keyword">class </span><a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a>
00058         {
00059                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> &lt; Tp_, AllocStr_, SzTp_,DiffTp_,
00060                         BlkSize_,PgTp_,PgSz_ &gt; <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a>;
00061                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> &lt; Tp_, AllocStr_, SzTp_,DiffTp_,
00062                         BlkSize_,PgTp_,PgSz_ &gt; <a class="code" href="classstxxl_1_1const__vector__iterator.html">_CIterator</a>;
00063                 <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classstxxl_1_1const__vector__iterator.html">_CIterator</a>;
00064 <span class="keyword">public</span>:
00065                 <span class="keyword">typedef</span> SzTp_ size_type;
00066                 <span class="keyword">typedef</span> DiffTp_ difference_type;
00067                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> block_offset_type;
00068                 <span class="keyword">typedef</span> vector &lt; Tp_, PgSz_, PgTp_, BlkSize_, AllocStr_,SzTp_&gt; <a class="code" href="classstxxl_1_1vector.html">vector_type</a>;
00069                 <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classstxxl_1_1vector.html">vector_type</a>;
00070                 <span class="keyword">typedef</span> bid_vector &lt; BlkSize_ &gt; bids_container_type;
00071                 <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::iterator bids_container_iterator;
00072                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;BlkSize_, Tp_&gt;</a> <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>;
00073                 <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt; BlkSize_ &gt;</a> <a class="code" href="structstxxl_1_1BID.html">bid_type</a>;
00074         
00075                 <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
00076                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::value_type value_type;
00077                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::reference reference;
00078                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::const_reference const_reference;
00079                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::pointer pointer;
00080                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::const_pointer const_pointer;
00081                 
00082                 <span class="keyword">enum</span>{ block_size = BlkSize_ };
00083 
00084         <span class="keyword">protected</span>:
00085                 size_type offset;
00086                 <a class="code" href="classstxxl_1_1vector.html">vector_type</a> *p_vector;
00087         <span class="keyword">private</span>:
00088                   <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> (<a class="code" href="classstxxl_1_1vector.html">vector_type</a> * v, size_type o):offset (o),
00089                         p_vector (v)
00090                 {
00091                 };
00092 <span class="keyword">public</span>:
00093           <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> ():offset (0), p_vector (NULL)
00094                 {
00095                 };
00096                 <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> &amp; a):
00097                         offset (a.offset),
00098                         p_vector (a.p_vector)
00099                 {
00100                 };
00101                 block_offset_type block_offset ()<span class="keyword"> const</span>
00102 <span class="keyword">                </span>{
00103                         <span class="keywordflow">return</span> static_cast &lt; block_offset_type &gt;
00104                                 (offset % block_type::size);
00105                 };
00106                 bids_container_iterator bid ()<span class="keyword"> const</span>
00107 <span class="keyword">                </span>{
00108                         <span class="keywordflow">return</span> p_vector-&gt;<a class="code" href="classstxxl_1_1vector.html#d0">bid</a> (offset);
00109                 };
00110                 
00111                 difference_type operator - (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> &amp; a)
00112                 {
00113                         <span class="keywordflow">return</span> offset - a.<a class="code" href="classstxxl_1_1vector__iterator.html#p0">offset</a>;
00114                 };
00115                 
00116                 <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> operator - (size_type op)
00117                 {
00118                         <span class="keywordflow">return</span> <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a>(p_vector,offset - op);
00119                 };
00120                 
00121                 <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> operator + (size_type op)
00122                 {
00123                         <span class="keywordflow">return</span> <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a>(p_vector,offset + op);
00124                 };
00125                 
00126                 reference operator *()
00127                 {
00128                         <span class="keywordflow">return</span> p_vector-&gt;<a class="code" href="classstxxl_1_1vector.html#d4">element</a>(offset);
00129                 }
00130     
00131     const_reference operator *()<span class="keyword"> const</span>
00132 <span class="keyword">                </span>{
00133                         <span class="keywordflow">return</span> p_vector-&gt;<a class="code" href="classstxxl_1_1vector.html#d5">const_element</a>(offset);
00134                 }
00135                 
00136                 <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> &amp; operator ++()
00137                 {
00138                         offset++;
00139                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00140                 }
00141                 <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> operator ++(<span class="keywordtype">int</span>)
00142                 {
00143                         <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> __tmp = *<span class="keyword">this</span>;
00144                         offset++;
00145                         <span class="keywordflow">return</span> __tmp;
00146                 }
00147                 <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> &amp; operator --()
00148                 {
00149                         offset--;
00150                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00151                 }
00152                 <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> operator --(<span class="keywordtype">int</span>)
00153                 {
00154                         <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> __tmp = *<span class="keyword">this</span>;
00155                         offset--;
00156                         <span class="keywordflow">return</span> __tmp;
00157                 }
00158                 <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> &amp;a)<span class="keyword"> const</span>
00159 <span class="keyword">                </span>{
00160                         <span class="keywordflow">return</span> ((offset) == (a.<a class="code" href="classstxxl_1_1vector__iterator.html#p0">offset</a>));
00161                 }
00162                 <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> &amp;a)<span class="keyword"> const</span>
00163 <span class="keyword">                </span>{
00164                         <span class="keywordflow">return</span> ((offset) != (a.<a class="code" href="classstxxl_1_1vector__iterator.html#p0">offset</a>));
00165                 }
00166                 <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1vector__iterator.html">_Self</a> &amp;a)<span class="keyword"> const</span>
00167 <span class="keyword">                </span>{
00168                         <span class="keywordflow">return</span> ((offset) &lt; (a.<a class="code" href="classstxxl_1_1vector__iterator.html#p0">offset</a>));
00169                 }       
00170                 
00171                 <span class="keywordtype">void</span> flush()
00172                 {
00173                         p_vector-&gt;<a class="code" href="classstxxl_1_1vector.html#a17">flush</a>();
00174                 }
00175         };
00176 
00178         <span class="keyword">template</span> &lt; <span class="keyword">typename</span> Tp_, <span class="keyword">typename</span> AllocStr_, <span class="keyword">typename</span> SzTp_,<span class="keyword">typename</span> DiffTp_,
00179                 <span class="keywordtype">unsigned</span> BlkSize_, <span class="keyword">typename</span> PgTp_, <span class="keywordtype">unsigned</span> PgSz_ &gt;
<a name="l00180"></a><a class="code" href="classstxxl_1_1const__vector__iterator.html">00180</a>         <span class="keyword">class </span><a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a>
00181         {
00182                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> &lt; Tp_, AllocStr_, SzTp_,DiffTp_,
00183                         BlkSize_,PgTp_,PgSz_ &gt; <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a>;
00184                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> &lt; Tp_, AllocStr_, SzTp_,DiffTp_,
00185                         BlkSize_,PgTp_,PgSz_ &gt; <a class="code" href="classstxxl_1_1vector__iterator.html">_NonConstIterator</a>;
00186 <span class="keyword">public</span>:
00187                 <span class="keyword">typedef</span> SzTp_ size_type;
00188                 <span class="keyword">typedef</span> DiffTp_ difference_type;
00189                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> block_offset_type;
00190                 <span class="keyword">typedef</span> vector &lt; Tp_, PgSz_, PgTp_, BlkSize_, AllocStr_,SzTp_&gt; <a class="code" href="classstxxl_1_1vector.html">vector_type</a>;
00191                 <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classstxxl_1_1vector.html">vector_type</a>;
00192                 <span class="keyword">typedef</span> bid_vector &lt; BlkSize_ &gt; bids_container_type;
00193                 <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::iterator bids_container_iterator;
00194                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;BlkSize_, Tp_&gt;</a> <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>;
00195                 <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt; BlkSize_ &gt;</a> <a class="code" href="structstxxl_1_1BID.html">bid_type</a>;
00196 
00197     <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
00198                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::value_type value_type;
00199                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::reference reference;
00200                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::const_reference const_reference;
00201                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::pointer pointer;
00202                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::const_pointer const_pointer;
00203                 
00204                 <span class="keyword">enum</span> { block_size = BlkSize_ };
00205 
00206 <span class="keyword">protected</span>:
00207                   size_type offset;
00208                 <a class="code" href="classstxxl_1_1vector.html">vector_type</a> *p_vector;
00209               <span class="keyword">private</span>:
00210                   <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> (<a class="code" href="classstxxl_1_1vector.html">vector_type</a> * v, size_type o):offset (o),
00211                         p_vector (v)
00212                 {
00213                 };
00214 <span class="keyword">public</span>:
00215           <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> ():offset (0), p_vector (NULL)
00216                 {
00217                 };
00218                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> &amp; a):
00219                         offset (a.offset),
00220                         p_vector (a.p_vector)
00221                 {
00222                 };
00223                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1vector__iterator.html">_NonConstIterator</a> &amp; a):offset (a.offset),
00224                         p_vector (a.p_vector)
00225                 {
00226                 };
00227                 block_offset_type block_offset ()<span class="keyword"> const</span>
00228 <span class="keyword">                </span>{
00229                         <span class="keywordflow">return</span> static_cast &lt; block_offset_type &gt;
00230                                 (offset % block_type::size);
00231                 };
00232                 bids_container_iterator bid ()<span class="keyword"> const</span>
00233 <span class="keyword">                </span>{
00234                         <span class="keywordflow">return</span> p_vector-&gt;<a class="code" href="classstxxl_1_1vector.html#d0">bid</a> (offset);
00235                 };
00236                 
00237                 difference_type operator - (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> &amp; a)
00238                 {
00239                         <span class="keywordflow">return</span> offset - a.<a class="code" href="classstxxl_1_1const__vector__iterator.html#p0">offset</a>;
00240                 };
00241                 
00242                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> operator - (size_type op)
00243                 {
00244                         <span class="keywordflow">return</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a>(p_vector,offset - op);
00245                 };
00246                 
00247                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> operator + (size_type op)
00248                 {
00249                         <span class="keywordflow">return</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a>(p_vector,offset + op);
00250                 };
00251                 
00252                 const_reference operator *()<span class="keyword"> const</span>
00253 <span class="keyword">                </span>{
00254                         <span class="keywordflow">return</span> p_vector-&gt;<a class="code" href="classstxxl_1_1vector.html#d5">const_element</a>(offset);
00255                 }
00256                 
00257                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> &amp; operator ++()
00258                 {
00259                         offset++;
00260                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00261                 }
00262                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> operator ++(<span class="keywordtype">int</span>)
00263                 {
00264                         <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> __tmp = *<span class="keyword">this</span>;
00265                         offset++;
00266                         <span class="keywordflow">return</span> _tmp;
00267                 }
00268                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> &amp; operator --()
00269                 {
00270                         offset--;
00271                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00272                 }
00273                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> operator --(<span class="keywordtype">int</span>)
00274                 {
00275                         <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> __tmp = *<span class="keyword">this</span>;
00276                         offset--;
00277                         <span class="keywordflow">return</span> __tmp;
00278                 }
00279                 <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> &amp;a)<span class="keyword"> const</span>
00280 <span class="keyword">                </span>{
00281                         <span class="keywordflow">return</span> ((p_vector + offset) == (a.<a class="code" href="classstxxl_1_1const__vector__iterator.html#p1">p_vector</a> + a.<a class="code" href="classstxxl_1_1const__vector__iterator.html#p0">offset</a>));
00282                 }
00283                 <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> &amp;a)<span class="keyword"> const</span>
00284 <span class="keyword">                </span>{
00285                         <span class="keywordflow">return</span> ((p_vector + offset) != (a.<a class="code" href="classstxxl_1_1const__vector__iterator.html#p1">p_vector</a> + a.<a class="code" href="classstxxl_1_1const__vector__iterator.html#p0">offset</a>));
00286                 }       
00287                 <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">_Self</a> &amp;a)<span class="keyword"> const</span>
00288 <span class="keyword">                </span>{
00289                         <span class="keywordflow">return</span> ((p_vector + offset) &lt; (a.<a class="code" href="classstxxl_1_1const__vector__iterator.html#p1">p_vector</a> + a.<a class="code" href="classstxxl_1_1const__vector__iterator.html#p0">offset</a>));
00290                 }       
00291                 <span class="keywordtype">void</span> flush()
00292                 {
00293                         p_vector-&gt;<a class="code" href="classstxxl_1_1vector.html#a17">flush</a>();
00294                 }
00295         };      
00296         
00298   
00311         <span class="keyword">template</span> &lt; 
00312     <span class="keyword">typename</span> Tp_,
00313     <span class="keywordtype">unsigned</span> PgSz_ = 4,
00314     <span class="keyword">typename</span> PgTp_ = <a class="code" href="classstxxl_1_1lru__pager.html">lru_pager&lt;8&gt;</a>,
00315                 <span class="keywordtype">unsigned</span> BlkSize_ = STXXL_DEFAULT_BLOCK_SIZE (Tp_),
00316     <span class="keyword">typename</span> AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY,
00317     <span class="keyword">typename</span> SzTp_ = off_t
00318                 &gt;
<a name="l00319"></a><a class="code" href="classstxxl_1_1vector.html">00319</a>         <span class="keyword">class </span><a class="code" href="classstxxl_1_1vector.html">vector</a> 
00320   {
00321   <span class="keyword">public</span>:
00322                 <span class="keyword">typedef</span> Tp_ value_type;
00323                 <span class="keyword">typedef</span> value_type &amp; reference;
00324                 <span class="keyword">typedef</span> <span class="keyword">const</span> value_type &amp; const_reference;
00325                 <span class="keyword">typedef</span> value_type * pointer;
00326                 <span class="keyword">typedef</span> SzTp_ size_type;
00327                 <span class="keyword">typedef</span> SzTp_ difference_type;
00328                 <span class="keyword">typedef</span> <span class="keyword">const</span> value_type *const_pointer;
00329                 
00330                 <span class="keyword">typedef</span> PgTp_ pager_type;
00331                 <span class="keyword">typedef</span> AllocStr_ alloc_strategy;
00332 
00333                 <span class="keyword">enum</span>{ 
00334                         block_size = BlkSize_, 
00335                         page_size = PgSz_,
00336                         n_pages = pager_type::n_pages,
00337                         on_disk = -1 };
00338 
00339                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> &lt; value_type, alloc_strategy, size_type,
00340                         difference_type,block_size,pager_type,page_size &gt; <a class="code" href="classstxxl_1_1vector__iterator.html">iterator</a>;
00341                 <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classstxxl_1_1vector__iterator.html">iterator</a>;
00342                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> &lt; value_type, alloc_strategy,
00343                         size_type,difference_type, block_size,pager_type,page_size &gt; <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_iterator</a>;
00344                 <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classstxxl_1_1const__vector__iterator.html">const_iterator</a>;
00345 
00346                 <span class="keyword">typedef</span> bid_vector &lt; block_size &gt; bids_container_type;
00347                 <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::
00348                         iterator bids_container_iterator;
00349                 <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::
00350                         const_iterator const_bids_container_iterator;
00351                 
00352                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;BlkSize_, Tp_&gt;</a> <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>;
00353                 
00354 
00355 <span class="keyword">private</span>:
00356                 alloc_strategy _alloc_strategy;
00357                 size_type _size;
00358                 bids_container_type _bids;
00359                 <span class="comment">//bids_container_iterator _bids_finish;</span>
00360                 <span class="keyword">mutable</span> pager_type pager;
00361 
00362                 <span class="keyword">enum</span> { uninitialized = 1, dirty= 2 };
00363                 <span class="keyword">mutable</span> std::vector&lt;unsigned char&gt; _page_status;
00364                 <span class="keyword">mutable</span> std::vector&lt;int&gt; _last_page;
00365                 <span class="keyword">mutable</span> simple_vector&lt;int&gt; _page_no;
00366                 <span class="keyword">mutable</span> std::queue&lt;int&gt; _free_pages;
00367                 <span class="keyword">mutable</span> simple_vector&lt;block_type&gt; _cache;
00368                 <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *bm;
00369                 <a class="code" href="classstxxl_1_1config.html">config</a> *cfg;
00370                 
00371 <span class="keyword">public</span>:
00372                 <a class="code" href="classstxxl_1_1vector.html">vector</a> (size_type n = 0):
00373                         _size (n),
00374                         _bids (div_and_round_up (n, block_type::size)),
00375                         _page_status(div_and_round_up (_bids.size(), page_size)),
00376                         _last_page(div_and_round_up (_bids.size(), page_size)),
00377                         _page_no(n_pages),
00378                         _cache(n_pages * page_size)
00379                 {
00380                         bm = block_manager::get_instance ();
00381                         cfg = config::get_instance ();
00382                         
00383                         <span class="keywordtype">int</span> all_pages = div_and_round_up (_bids.size(), page_size);
00384                         <span class="keywordtype">int</span> i=0;
00385                         <span class="keywordflow">for</span>(;i&lt;all_pages;i++)
00386                         {
00387                                 _page_status[i] = uninitialized;
00388                                 _last_page[i] = on_disk;
00389                         }
00390                         
00391                         <span class="keywordflow">for</span>(i=0;i&lt;n_pages;i++)
00392                                 _free_pages.push(i);
00393                 
00394 
00395                         bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a> (_alloc_strategy, _bids.begin (),
00396                                         _bids.end ());
00397                 }
00398     size_type capacity()
00399     {
00400       <span class="keywordflow">return</span> size_type(_bids.size())*block_type::size;
00401     }
00402     <span class="keywordtype">void</span> reserve(size_type n)
00403     {
00404       <span class="keywordflow">if</span>(n&lt;=capacity())
00405         <span class="keywordflow">return</span>;
00406       
00407       <span class="keywordtype">unsigned</span> old_bids_size = _bids.size();
00408       <span class="keywordtype">unsigned</span> new_bids_size = div_and_round_up (n, block_type::size);
00409       <span class="keywordtype">unsigned</span> new_pages = div_and_round_up(new_bids_size, page_size); 
00410       _page_status.resize(new_pages,uninitialized);
00411       _last_page.resize(new_pages,on_disk);
00412       
00413       _bids.resize(new_bids_size);
00414       bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(<a class="code" href="structstxxl_1_1offset__allocator.html">offset_allocator&lt;alloc_strategy&gt;</a>(old_bids_size,_alloc_strategy),
00415           _bids.begin() + old_bids_size,_bids.end());
00416     }
00417     <span class="keywordtype">void</span> resize(size_type n)
00418     {
00419           reserve(n);           
00420           <span class="comment">/*</span>
00421 <span class="comment">      unsigned old_bids_size = _bids.size();</span>
00422 <span class="comment">      unsigned new_bids_size = div_and_round_up (n, block_type::size);</span>
00423 <span class="comment">      </span>
00424 <span class="comment">      </span>
00425 <span class="comment">          if(new_bids_size &gt; old_bids_size)</span>
00426 <span class="comment">      {</span>
00427 <span class="comment">        reserve(n);</span>
00428 <span class="comment">      }</span>
00429 <span class="comment">      else if(new_bids_size &lt; old_bids_size)</span>
00430 <span class="comment">      {</span>
00431 <span class="comment">        bm-&gt;delete_blocks(_bids.begin() + new_bids_size,_bids.end());</span>
00432 <span class="comment">        _bids.resize(new_bids_size);</span>
00433 <span class="comment">        </span>
00434 <span class="comment">        unsigned first_page_to_evict = div_and_round_up(new_bids_size, page_size);</span>
00435 <span class="comment">        std::fill(_page_status.begin() + first_page_to_evict,</span>
00436 <span class="comment">                  _page_status.end(), 0); // clear dirty flag, so this pages </span>
00437 <span class="comment">                                          // will be never written</span>
00438 <span class="comment">      }*/</span>
00439       _size = n;
00440     }
00441     <span class="keywordtype">void</span> push_back(const_reference obj)
00442     {
00443       size_type old_size = _size;
00444       resize(old_size + 1);
00445       element(old_size) = obj;
00446     }
00447     <span class="keywordtype">void</span> pop_back()
00448     {
00449       resize(_size - 1);
00450     }
00451     reference back()
00452     {
00453       <span class="keywordflow">return</span> element(_size - 1);
00454     }
00455     reference front()
00456     {
00457       <span class="keywordflow">return</span> element(0);
00458     }
00459     <a class="code" href="classstxxl_1_1vector.html">vector</a> (<a class="code" href="classstxxl_1_1file.html">file</a> * from):
00460                         _size(from-&gt;size()/<span class="keyword">sizeof</span>(value_type)),
00461                         _bids(div_and_round_up(_size,block_type::size)),
00462                         _page_status(div_and_round_up (_bids.size(), page_size)),
00463                         _last_page(div_and_round_up (_bids.size(), page_size)),
00464                         _page_no(n_pages),
00465                         _cache(n_pages * page_size)
00466                 {
00467                         <span class="comment">// initialize from file</span>
00468                         assert(from-&gt;get_disk_number() == -1);
00469                         
00470                         <span class="keywordtype">int</span> all_pages = div_and_round_up (_bids.size(), page_size);
00471                         <span class="keywordtype">int</span> i=0;
00472                         <span class="keywordflow">for</span>(;i&lt;all_pages;i++)
00473                         {
00474                                 _page_status[i] = 0;
00475                                 _last_page[i] = on_disk;
00476                         }
00477                         
00478                         <span class="keywordflow">for</span>(i=0;i&lt;n_pages;i++)
00479                                 _free_pages.push(i);
00480                 
00481                         
00482                         size_type offset = 0; 
00483                         bids_container_iterator it = _bids.begin();
00484                         <span class="keywordflow">for</span>(;it!=_bids.end();it++,offset+=(block_type::size*<span class="keyword">sizeof</span>(value_type)) )
00485                         {
00486                                 (*it).storage = from;
00487                                 (*it).offset = offset;
00488                         }
00489                         
00490                 }
00491     <a class="code" href="classstxxl_1_1vector.html">vector</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1vector.html">vector</a> &amp; obj)
00492     {
00493       STXXL_MSG(<span class="stringliteral">"stxxl::vector copy constructor is not implemented yet"</span>);
00494       abort();
00495     }
00496                 size_type size ()<span class="keyword"> const</span>
00497 <span class="keyword">                </span>{
00498                         <span class="keywordflow">return</span> _size;
00499                 }
00500                 <a class="code" href="classstxxl_1_1vector__iterator.html">iterator</a> begin ()
00501                 {
00502                         <span class="keywordflow">return</span> <a class="code" href="classstxxl_1_1vector__iterator.html">iterator</a> (<span class="keyword">this</span>, 0);
00503                 }
00504                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_iterator</a> begin ()<span class="keyword"> const</span>
00505 <span class="keyword">                </span>{
00506                         <span class="keywordflow">return</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_iterator</a> (<span class="keyword">this</span>, 0);
00507                 }
00508                 <a class="code" href="classstxxl_1_1vector__iterator.html">iterator</a> end ()
00509                 {
00510                         <span class="keywordflow">return</span> <a class="code" href="classstxxl_1_1vector__iterator.html">iterator</a> (<span class="keyword">this</span>, _size);
00511                 }
00512                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_iterator</a> end ()<span class="keyword"> const</span>
00513 <span class="keyword">                </span>{
00514                         <span class="keywordflow">return</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_iterator</a> (<span class="keyword">this</span>, _size);
00515                 }
00516                 reference operator [] (size_type offset)
00517                 {
00518                         <span class="keywordflow">return</span> element(offset);
00519                 }
00520                 const_reference operator [] (size_type offset)<span class="keyword"> const</span>
00521 <span class="keyword">                </span>{
00522                         <span class="keywordflow">return</span> const_element(offset);
00523                 }
00524                 
00525                 <span class="keywordtype">void</span> flush()
00526                 {
00527                         simple_vector&lt;bool&gt; non_free_pages(n_pages);
00528                         <span class="keywordtype">int</span> i=0;
00529                         <span class="keywordflow">for</span>(;i&lt;n_pages;i++)
00530                                 non_free_pages[i] = <span class="keyword">true</span>;
00531                         
00532                         <span class="keywordflow">while</span>(!_free_pages.empty())
00533                         {
00534                                 non_free_pages[_free_pages.front()] = <span class="keyword">false</span>;
00535                                 _free_pages.pop();
00536                         }
00537                                 
00538                         <span class="keywordflow">for</span>(i=0;i&lt;n_pages;i++)
00539                         {
00540                                 _free_pages.push(i);
00541                                 <span class="keywordtype">int</span> page_no = _page_no[i];
00542                                 <span class="keywordflow">if</span>(non_free_pages[i])
00543                                 {
00544                                         <span class="comment">// STXXL_MSG("Flushing page "&lt;&lt;i&lt;&lt; " address: "&lt;&lt;(page_no*block_type::size*page_size));</span>
00545                                         <span class="keywordflow">if</span>(_page_status[page_no] &amp; dirty)
00546                                                 write_page(page_no,i);
00547                                 
00548                                         _last_page[page_no] = on_disk;
00549                                         _page_status[page_no] = 0;
00550                                 }
00551                         };
00552                 }
00553 <span class="keyword">private</span>:
00554                 bids_container_iterator bid (<span class="keyword">const</span> size_type &amp; offset)
00555                 {
00556                         <span class="keywordflow">return</span> (_bids.begin () +
00557                                 static_cast &lt; typename bids_container_type::size_type &gt;
00558                                 (offset / block_type::size));
00559                 }
00560                 const_bids_container_iterator bid (<span class="keyword">const</span> size_type &amp; offset)<span class="keyword"> const</span>
00561 <span class="keyword">                </span>{
00562                         <span class="keywordflow">return</span> (_bids.begin () +
00563                                 static_cast &lt; typename bids_container_type::size_type &gt;
00564                                 (offset / block_type::size));
00565                 }
00566                 <span class="keywordtype">void</span> read_page(<span class="keywordtype">int</span> page_no, <span class="keywordtype">int</span> cache_page)<span class="keyword"> const</span>
00567 <span class="keyword">                </span>{
00568                         <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> * reqs = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> [page_size];
00569                         <span class="keywordtype">int</span> block_no = page_no*page_size;
00570                         <span class="keywordtype">int</span> last_block =        std::min(block_no + page_size,<span class="keywordtype">int</span>(_bids.size()));
00571                         <span class="keywordtype">int</span> i=cache_page*page_size,j=0;
00572                         <span class="keywordflow">for</span>(;block_no &lt; last_block; block_no++,i++,j++)
00573                                 reqs[j] = _cache[i].read(_bids[block_no]);
00574                         <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,last_block - page_no*page_size);
00575                         <span class="keyword">delete</span> [] reqs;
00576                 }
00577                 <span class="keywordtype">void</span> write_page(<span class="keywordtype">int</span> page_no, <span class="keywordtype">int</span> cache_page)<span class="keyword"> const</span>
00578 <span class="keyword">                </span>{
00579                         <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> * reqs = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> [page_size];
00580                         <span class="keywordtype">int</span> block_no = page_no*page_size;
00581                         <span class="keywordtype">int</span> last_block = std::min(block_no + page_size,<span class="keywordtype">int</span>(_bids.size()));
00582                         <span class="keywordtype">int</span> i=cache_page*page_size,j=0;
00583                         <span class="keywordflow">for</span>(;block_no &lt; last_block; block_no++,i++,j++)
00584                         {
00585                                 reqs[j] = _cache[i].write(_bids[block_no]);
00586                         }
00587                         <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,last_block - page_no*page_size);
00588                         <span class="keyword">delete</span> [] reqs;
00589                 }
00590                 reference element(size_type offset)
00591                 {
00592                         <span class="keywordtype">int</span> page_no = offset/(block_type::size*page_size);
00593                         <span class="keywordtype">int</span> page_offset = offset % (block_type::size*page_size);
00594                         <span class="keywordtype">int</span> last_page = _last_page[page_no];
00595                         <span class="keywordflow">if</span>(last_page &lt; 0)  <span class="comment">// == on_disk</span>
00596                         { 
00597                                 <span class="keywordflow">if</span>(_free_pages.empty()) <span class="comment">// has to kick</span>
00598                                 {
00599                                         <span class="keywordtype">int</span> kicked_page = pager.kick();
00600                                         pager.hit(kicked_page);
00601                                         <span class="keywordtype">int</span> old_page_no = _page_no[kicked_page];
00602                                         _last_page[page_no] = kicked_page;
00603                                         _last_page[old_page_no] = on_disk;
00604                                         _page_no[kicked_page] = page_no;
00605                                                                 
00606                                         <span class="comment">// what to do with the old page ?</span>
00607                                         <span class="keywordflow">if</span>(_page_status[old_page_no] &amp; dirty)
00608                                         {
00609                                                 <span class="comment">// has to store changes</span>
00610                                                 write_page(old_page_no,kicked_page);
00611                                         }
00612                                         
00613                                         <span class="keywordflow">if</span>(_page_status[page_no] != uninitialized)
00614                                         {
00615                                                 read_page(page_no,kicked_page);
00616                                         }
00617                                         
00618                                         _page_status[page_no] = dirty;
00619                                         
00620                                         <span class="keywordflow">return</span> _cache[kicked_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00621                                 }
00622                                 <span class="keywordflow">else</span>
00623                                 {
00624                                         <span class="keywordtype">int</span> free_page = _free_pages.front();
00625                                         _free_pages.pop();
00626                                         pager.hit(free_page);
00627                                         _last_page[page_no] = free_page;
00628                                         _page_no[free_page] = page_no;
00629                                         
00630                                         <span class="keywordflow">if</span>(_page_status[page_no] != uninitialized)
00631                                         {
00632                                                 read_page(page_no,free_page);
00633                                         }
00634                                         
00635                                         _page_status[page_no] = dirty;
00636                                         
00637                                         <span class="keywordflow">return</span> _cache[free_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00638                                 }
00639                         } 
00640                         <span class="keywordflow">else</span>
00641                         {
00642                                 _page_status[page_no] = dirty;
00643                                 pager.hit(last_page);
00644                                 <span class="keywordflow">return</span> _cache[last_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00645                         }
00646                 };
00647                 const_reference const_element(size_type offset)<span class="keyword"> const</span>
00648 <span class="keyword">                </span>{
00649                         <span class="keywordtype">int</span> page_no = offset/(block_type::size*page_size);
00650                         <span class="keywordtype">int</span> page_offset = offset % (block_type::size*page_size);
00651                         <span class="keywordtype">int</span> last_page = _last_page[page_no];
00652                         <span class="keywordflow">if</span>(last_page &lt; 0)  <span class="comment">// == on_disk</span>
00653                         { 
00654                                 <span class="keywordflow">if</span>(_free_pages.empty()) <span class="comment">// has to kick</span>
00655                                 {
00656                                         <span class="keywordtype">int</span> kicked_page = pager.kick();
00657                                         pager.hit(kicked_page);
00658                                         <span class="keywordtype">int</span> old_page_no = _page_no[kicked_page];
00659                                         _last_page[page_no] = kicked_page;
00660                                         _last_page[old_page_no] = on_disk;
00661                                         _page_no[kicked_page] = page_no;
00662                                                                 
00663                                         <span class="comment">// what to do with the old page ?</span>
00664                                         <span class="keywordflow">if</span>(_page_status[old_page_no] &amp; dirty)
00665                                         {
00666                                                 <span class="comment">// has to store changes</span>
00667                                                 write_page(old_page_no,kicked_page);
00668                                         }
00669                                         
00670                                         <span class="keywordflow">if</span>(_page_status[page_no] != uninitialized)
00671                                         {
00672                                                 read_page(page_no,kicked_page);
00673                                         }
00674                                         
00675                                         _page_status[page_no] = 0;
00676                                         
00677                                         <span class="keywordflow">return</span> _cache[kicked_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00678                                 }
00679                                 <span class="keywordflow">else</span>
00680                                 {
00681                                         <span class="keywordtype">int</span> free_page = _free_pages.front();
00682                                         _free_pages.pop();
00683                                         pager.hit(free_page);
00684                                         _last_page[page_no] = free_page;
00685                                         _page_no[free_page] = page_no;
00686                                         
00687                                         <span class="keywordflow">if</span>(_page_status[page_no] != uninitialized)
00688                                         {
00689                                                 read_page(page_no,free_page);
00690                                         }
00691                                         
00692                                         _page_status[page_no] = 0;
00693                                         
00694                                         <span class="keywordflow">return</span> _cache[free_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00695                                 }
00696                         } 
00697                         <span class="keywordflow">else</span>
00698                         {
00699                                 pager.hit(last_page);
00700                                 <span class="keywordflow">return</span> _cache[last_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00701                         }
00702                 };
00703         };
00704   
00706   
00709   
00711   
00734         <span class="keyword">template</span>
00735   &lt; 
00736     <span class="keyword">typename</span> Tp_,
00737     <span class="keywordtype">unsigned</span> PgSz_ = 4,
00738     <span class="keywordtype">unsigned</span> Pages_ = 8,
00739     <span class="keywordtype">unsigned</span> BlkSize_ = STXXL_DEFAULT_BLOCK_SIZE (Tp_),
00740                 <span class="keyword">typename</span> AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY,
00741     pager_type Pager_ = lru
00742         &gt;
<a name="l00743"></a><a class="code" href="structstxxl_1_1VECTOR__GENERATOR.html">00743</a>   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1VECTOR__GENERATOR.html">VECTOR_GENERATOR</a>
00744   {
00745       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1IF.html">IF</a>&lt;Pager_==lru,
00746         <a class="code" href="classstxxl_1_1lru__pager.html">lru_pager&lt;Pages_&gt;</a>,<a class="code" href="classstxxl_1_1random__pager.html">random_pager&lt;Pages_&gt;</a> &gt;<a class="code" href="classstxxl_1_1vector.html">::result</a> <a class="code" href="structstxxl_1_1IF.html">PagerType</a>;
00747     
00748       <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector.html">vector&lt;Tp_,PgSz_,PagerType,BlkSize_,AllocStr_&gt;</a> <a class="code" href="classstxxl_1_1vector.html">result</a>;
00749   };
00750     
00751     
00753 }
00754 
00755 
00756 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Nov 26 10:56:56 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
