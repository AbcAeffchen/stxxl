<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>vector.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>vector.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef STXXL_VECTOR_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define STXXL_VECTOR_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            vector.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Sat Aug 24 23:54:35 2002</span>
00008 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 
00013 <span class="preprocessor">#include "../mng/mng.h"</span>
00014 <span class="preprocessor">#include "../common/tmeta.h"</span>
00015 <span class="preprocessor">#include "pager.h"</span>
00016 <span class="preprocessor">#include &lt;vector&gt;</span>
00017 
00018 
00019 <span class="keyword">namespace </span>stxxl
00020 {
00023   
00024         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> BlkSize_ &gt;
00025                 <span class="keyword">class </span>bid_vector:<span class="keyword">public</span> std::vector &lt; BID &lt; BlkSize_ &gt; &gt;
00026         {
00027         <span class="keyword">public</span>:
00028                 <span class="keyword">enum</span>
00029                 { block_size = BlkSize_ };
00030                 <span class="keyword">typedef</span> bid_vector &lt; block_size &gt; _Self;
00031                 <span class="keyword">typedef</span> std::vector &lt; BID &lt; BlkSize_ &gt; &gt;_Derived;
00032                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> size_type;
00033 
00034                 bid_vector (size_type _sz):_Derived (_sz)
00035                 {
00036                 };
00037         };
00038 
00039         <span class="keyword">template</span> &lt; 
00040     <span class="keyword">typename</span> Tp_,
00041     <span class="keywordtype">unsigned</span> PgSz_,
00042     <span class="keyword">typename</span> PgTp_,
00043     <span class="keywordtype">unsigned</span> BlkSize_ ,
00044                 <span class="keyword">typename</span> AllocStr_ ,
00045     <span class="keyword">typename</span> SzTp_ &gt;
00046         <span class="keyword">class </span>vector;
00047         
00048         
00049         <span class="keyword">template</span> &lt; <span class="keyword">typename</span> Tp_, <span class="keyword">typename</span> AllocStr_, <span class="keyword">typename</span> SzTp_, <span class="keyword">typename</span> DiffTp_,
00050                         <span class="keywordtype">unsigned</span> BlkSize_,<span class="keyword">typename</span> PgTp_,<span class="keywordtype">unsigned</span> PgSz_ &gt; <span class="keyword">class </span>const_vector_iterator;
00051 
00052         
00054         <span class="keyword">template</span> &lt; <span class="keyword">typename</span> Tp_, <span class="keyword">typename</span> AllocStr_, <span class="keyword">typename</span> SzTp_,<span class="keyword">typename</span> DiffTp_,
<a name="l00055"></a><a class="code" href="classstxxl_1_1vector__iterator.html">00055</a>                 <span class="keywordtype">unsigned</span> BlkSize_, <span class="keyword">typename</span> PgTp_, <span class="keywordtype">unsigned</span> PgSz_ &gt; 
00056   <span class="keyword">class </span><a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a>
00057         {
00058                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> &lt; Tp_, AllocStr_, SzTp_,DiffTp_,
00059                         BlkSize_,PgTp_,PgSz_ &gt; _Self;
00060                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> &lt; Tp_, AllocStr_, SzTp_,DiffTp_,
00061                         BlkSize_,PgTp_,PgSz_ &gt; _CIterator;
00062                 <span class="keyword">friend</span> <span class="keyword">class </span>_CIterator;
00063 <span class="keyword">public</span>:
00064                 <span class="keyword">typedef</span> SzTp_ size_type;
00065                 <span class="keyword">typedef</span> DiffTp_ difference_type;
00066                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> block_offset_type;
00067                 <span class="keyword">typedef</span> vector &lt; Tp_, PgSz_, PgTp_, BlkSize_, AllocStr_,SzTp_&gt; vector_type;
00068                 <span class="keyword">friend</span> <span class="keyword">class </span>vector_type;
00069                 <span class="keyword">typedef</span> bid_vector &lt; BlkSize_ &gt; bids_container_type;
00070                 <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::iterator bids_container_iterator;
00071                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;BlkSize_, Tp_&gt;</a> block_type;
00072                 <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt; BlkSize_ &gt;</a> bid_type;
00073         
00074                 <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
00075                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::value_type value_type;
00076                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::reference reference;
00077                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::const_reference const_reference;
00078                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::pointer pointer;
00079                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::const_pointer const_pointer;
00080                 
00081                 <span class="keyword">enum</span>{ block_size = BlkSize_ };
00082 
00083         <span class="keyword">protected</span>:
00084                 size_type offset;
00085                 vector_type *p_vector;
00086         <span class="keyword">private</span>:
00087                   <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> (vector_type * v, size_type o):offset (o),
00088                         p_vector (v)
00089                 {
00090                 };
00091 <span class="keyword">public</span>:
00092           <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> ():offset (0), p_vector (NULL)
00093                 {
00094                 };
00095                 <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> (<span class="keyword">const</span> _Self &amp; a):
00096                         offset (a.offset),
00097                         p_vector (a.p_vector)
00098                 {
00099                 };
00100                 block_offset_type block_offset ()<span class="keyword"> const</span>
00101 <span class="keyword">                </span>{
00102                         <span class="keywordflow">return</span> static_cast &lt; block_offset_type &gt;
00103                                 (offset % block_type::size);
00104                 };
00105                 bids_container_iterator bid ()<span class="keyword"> const</span>
00106 <span class="keyword">                </span>{
00107                         <span class="keywordflow">return</span> p_vector-&gt;bid (offset);
00108                 };
00109                 
00110                 difference_type operator - (<span class="keyword">const</span> _Self &amp; a)
00111                 {
00112                         <span class="keywordflow">return</span> offset - a.offset;
00113                 };
00114                 
00115                 _Self operator - (size_type op)
00116                 {
00117                         <span class="keywordflow">return</span> _Self(p_vector,offset - op);
00118                 };
00119                 
00120                 _Self operator + (size_type op)
00121                 {
00122                         <span class="keywordflow">return</span> _Self(p_vector,offset + op);
00123                 };
00124                 
00125                 reference operator *()
00126                 {
00127                         <span class="keywordflow">return</span> p_vector-&gt;element(offset);
00128                 }
00129                 
00130                 _Self &amp; operator ++()
00131                 {
00132                         offset++;
00133                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00134                 }
00135                 _Self operator ++(<span class="keywordtype">int</span>)
00136                 {
00137                         _Self __tmp = *<span class="keyword">this</span>;
00138                         offset++;
00139                         <span class="keywordflow">return</span> __tmp;
00140                 }
00141                 _Self &amp; operator --()
00142                 {
00143                         offset--;
00144                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00145                 }
00146                 _Self operator --(<span class="keywordtype">int</span>)
00147                 {
00148                         _Self __tmp = *<span class="keyword">this</span>;
00149                         offset--;
00150                         <span class="keywordflow">return</span> __tmp;
00151                 }
00152                 <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> _Self &amp;a)<span class="keyword"> const</span>
00153 <span class="keyword">                </span>{
00154                         <span class="keywordflow">return</span> ((offset) == (a.offset));
00155                 }
00156                 <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> _Self &amp;a)<span class="keyword"> const</span>
00157 <span class="keyword">                </span>{
00158                         <span class="keywordflow">return</span> ((offset) != (a.offset));
00159                 }
00160                 <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> _Self &amp;a)<span class="keyword"> const</span>
00161 <span class="keyword">                </span>{
00162                         <span class="keywordflow">return</span> ((offset) &lt; (a.offset));
00163                 }       
00164                 
00165                 <span class="keywordtype">void</span> flush()
00166                 {
00167                         p_vector-&gt;flush();
00168                 }
00169         };
00170 
00172         <span class="keyword">template</span> &lt; <span class="keyword">typename</span> Tp_, <span class="keyword">typename</span> AllocStr_, <span class="keyword">typename</span> SzTp_,<span class="keyword">typename</span> DiffTp_,
<a name="l00173"></a><a class="code" href="classstxxl_1_1const__vector__iterator.html">00173</a>                 <span class="keywordtype">unsigned</span> BlkSize_, <span class="keyword">typename</span> PgTp_, <span class="keywordtype">unsigned</span> PgSz_ &gt;
00174         <span class="keyword">class </span><a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a>
00175         {
00176                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> &lt; Tp_, AllocStr_, SzTp_,DiffTp_,
00177                         BlkSize_,PgTp_,PgSz_ &gt; _Self;
00178                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> &lt; Tp_, AllocStr_, SzTp_,DiffTp_,
00179                         BlkSize_,PgTp_,PgSz_ &gt; _NonConstIterator;
00180 <span class="keyword">public</span>:
00181                 <span class="keyword">typedef</span> SzTp_ size_type;
00182                 <span class="keyword">typedef</span> DiffTp_ difference_type;
00183                 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> block_offset_type;
00184                 <span class="keyword">typedef</span> vector &lt; Tp_, PgSz_, PgTp_, BlkSize_, AllocStr_,SzTp_&gt; vector_type;
00185                 <span class="keyword">friend</span> <span class="keyword">class </span>vector_type;
00186                 <span class="keyword">typedef</span> bid_vector &lt; BlkSize_ &gt; bids_container_type;
00187                 <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::iterator bids_container_iterator;
00188                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;BlkSize_, Tp_&gt;</a> block_type;
00189                 <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt; BlkSize_ &gt;</a> bid_type;
00190 
00191     <span class="keyword">typedef</span> std::random_access_iterator_tag iterator_category;
00192                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::value_type value_type;
00193                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::reference reference;
00194                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::const_reference const_reference;
00195                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::pointer pointer;
00196                 <span class="keyword">typedef</span> <span class="keyword">typename</span> vector_type::const_pointer const_pointer;
00197                 
00198                 <span class="keyword">enum</span> { block_size = BlkSize_ };
00199 
00200 <span class="keyword">protected</span>:
00201                   size_type offset;
00202                 vector_type *p_vector;
00203               <span class="keyword">private</span>:
00204                   <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> (vector_type * v, size_type o):offset (o),
00205                         p_vector (v)
00206                 {
00207                 };
00208 <span class="keyword">public</span>:
00209           <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> ():offset (0), p_vector (NULL)
00210                 {
00211                 };
00212                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> (<span class="keyword">const</span> _Self &amp; a):
00213                         offset (a.offset),
00214                         p_vector (a.p_vector)
00215                 {
00216                 };
00217                 <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> (<span class="keyword">const</span> _NonConstIterator &amp; a):offset (a.offset),
00218                         p_vector (a.p_vector)
00219                 {
00220                 };
00221                 block_offset_type block_offset ()<span class="keyword"> const</span>
00222 <span class="keyword">                </span>{
00223                         <span class="keywordflow">return</span> static_cast &lt; block_offset_type &gt;
00224                                 (offset % block_type::size);
00225                 };
00226                 bids_container_iterator bid ()<span class="keyword"> const</span>
00227 <span class="keyword">                </span>{
00228                         <span class="keywordflow">return</span> p_vector-&gt;bid (offset);
00229                 };
00230                 
00231                 difference_type operator - (<span class="keyword">const</span> _Self &amp; a)
00232                 {
00233                         <span class="keywordflow">return</span> offset - a.offset;
00234                 };
00235                 
00236                 _Self operator - (size_type op)
00237                 {
00238                         <span class="keywordflow">return</span> _Self(p_vector,offset - op);
00239                 };
00240                 
00241                 _Self operator + (size_type op)
00242                 {
00243                         <span class="keywordflow">return</span> _Self(p_vector,offset + op);
00244                 };
00245                 
00246                 const_reference operator *()
00247                 {
00248                         <span class="keywordflow">return</span> p_vector-&gt;const_element(offset);
00249                 }
00250                 
00251                 _Self &amp; operator ++()
00252                 {
00253                         offset++;
00254                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00255                 }
00256                 _Self operator ++(<span class="keywordtype">int</span>)
00257                 {
00258                         _Self __tmp = *<span class="keyword">this</span>;
00259                         offset++;
00260                         <span class="keywordflow">return</span> _tmp;
00261                 }
00262                 _Self &amp; operator --()
00263                 {
00264                         offset--;
00265                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00266                 }
00267                 _Self operator --(<span class="keywordtype">int</span>)
00268                 {
00269                         _Self __tmp = *<span class="keyword">this</span>;
00270                         offset--;
00271                         <span class="keywordflow">return</span> __tmp;
00272                 }
00273                 <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> _Self &amp;a)<span class="keyword"> const</span>
00274 <span class="keyword">                </span>{
00275                         <span class="keywordflow">return</span> ((p_vector + offset) == (a.p_vector + a.offset));
00276                 }
00277                 <span class="keywordtype">bool</span> operator != (<span class="keyword">const</span> _Self &amp;a)<span class="keyword"> const</span>
00278 <span class="keyword">                </span>{
00279                         <span class="keywordflow">return</span> ((p_vector + offset) != (a.p_vector + a.offset));
00280                 }       
00281                 <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> _Self &amp;a)<span class="keyword"> const</span>
00282 <span class="keyword">                </span>{
00283                         <span class="keywordflow">return</span> ((p_vector + offset) &lt; (a.p_vector + a.offset));
00284                 }       
00285                 <span class="keywordtype">void</span> flush()
00286                 {
00287                         p_vector-&gt;flush();
00288                 }
00289         };      
00290         
00292   
00303         <span class="keyword">template</span> &lt; 
00304     <span class="keyword">typename</span> Tp_,
00305     <span class="keywordtype">unsigned</span> PgSz_ = 4,
00306     <span class="keyword">typename</span> PgTp_ = lru_pager&lt;8&gt;,
00307                 <span class="keywordtype">unsigned</span> BlkSize_ = STXXL_DEFAULT_BLOCK_SIZE (Tp_),
00308     <span class="keyword">typename</span> AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY,
00309     <span class="keyword">typename</span> SzTp_ = off_t
<a name="l00310"></a><a class="code" href="classstxxl_1_1vector.html">00310</a>                 &gt;
00311         <span class="keyword">class </span><a class="code" href="classstxxl_1_1vector.html">vector</a> 
00312   {
00313   <span class="keyword">public</span>:
00314                 <span class="keyword">typedef</span> Tp_ value_type;
00315                 <span class="keyword">typedef</span> value_type &amp; reference;
00316                 <span class="keyword">typedef</span> <span class="keyword">const</span> value_type &amp; const_reference;
00317                 <span class="keyword">typedef</span> value_type *pointer;
00318                 <span class="keyword">typedef</span> SzTp_ size_type;
00319                 <span class="keyword">typedef</span> SzTp_ difference_type;
00320                 <span class="keyword">typedef</span> <span class="keyword">const</span> value_type *const_pointer;
00321                 
00322                 <span class="keyword">typedef</span> PgTp_ pager_type;
00323                 <span class="keyword">typedef</span> AllocStr_ alloc_strategy;
00324 
00325                 <span class="keyword">enum</span>{ 
00326                         block_size = BlkSize_, 
00327                         page_size = PgSz_,
00328                         n_pages = pager_type::n_pages,
00329                         on_disk = -1 };
00330 
00331                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector__iterator.html">vector_iterator</a> &lt; value_type, alloc_strategy, size_type,
00332                         difference_type,block_size,pager_type,page_size &gt; iterator;
00333                 <span class="keyword">friend</span> <span class="keyword">class </span>iterator;
00334                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1const__vector__iterator.html">const_vector_iterator</a> &lt; value_type, alloc_strategy,
00335                         size_type,difference_type, block_size,pager_type,page_size &gt; const_iterator;
00336                 <span class="keyword">friend</span> <span class="keyword">class </span>const_iterator;
00337 
00338                 <span class="keyword">typedef</span> bid_vector &lt; block_size &gt; bids_container_type;
00339                 <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::
00340                         iterator bids_container_iterator;
00341                 <span class="keyword">typedef</span> <span class="keyword">typename</span> bids_container_type::
00342                         const_iterator const_bids_container_iterator;
00343                 
00344                 <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;BlkSize_, Tp_&gt;</a> block_type;
00345                 
00346 
00347 <span class="keyword">private</span>:
00348                 alloc_strategy _alloc_strategy;
00349                 size_type _size;
00350                 bids_container_type _bids;
00351                 <span class="comment">//bids_container_iterator _bids_finish;</span>
00352                 pager_type pager;
00353 
00354                 <span class="keyword">enum</span> { uninitialized = 1, dirty= 2 };
00355                 std::vector&lt;unsigned char&gt; _page_status;
00356                 std::vector&lt;int&gt; _last_page;
00357                 simple_vector&lt;int&gt; _page_no;
00358                 std::queue&lt;int&gt; _free_pages;
00359                 simple_vector&lt;block_type&gt; _cache;
00360                 <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *bm;
00361                 <a class="code" href="classstxxl_1_1config.html">config</a> *cfg;
00362                 
00363 <span class="keyword">public</span>:
00364                 <a class="code" href="classstxxl_1_1vector.html">vector</a> (size_type n = 0):
00365                         _size (n),
00366                         _bids (div_and_round_up (n, block_type::size)),
00367                         _page_status(div_and_round_up (_bids.size(), page_size)),
00368                         _last_page(div_and_round_up (_bids.size(), page_size)),
00369                         _page_no(n_pages),
00370                         _cache(n_pages * page_size)
00371                 {
00372                         bm = block_manager::get_instance ();
00373                         cfg = config::get_instance ();
00374                         
00375                         <span class="keywordtype">int</span> all_pages = div_and_round_up (_bids.size(), page_size);
00376                         <span class="keywordtype">int</span> i=0;
00377                         <span class="keywordflow">for</span>(;i&lt;all_pages;i++)
00378                         {
00379                                 _page_status[i] = uninitialized;
00380                                 _last_page[i] = on_disk;
00381                         }
00382                         
00383                         <span class="keywordflow">for</span>(i=0;i&lt;n_pages;i++)
00384                                 _free_pages.push(i);
00385                 
00386 
00387                         bm-&gt;<a class="code" href="group__mnglayer.html#a11">new_blocks</a> (_alloc_strategy, _bids.begin (),
00388                                         _bids.end ());
00389                 }
00390     size_type capacity()
00391     {
00392       <span class="keywordflow">return</span> size_type(_bids.size())*block_type::size;
00393     }
00394     <span class="keywordtype">void</span> reserve(size_type n)
00395     {
00396       <span class="keywordflow">if</span>(n&lt;=capacity())
00397         <span class="keywordflow">return</span>;
00398       
00399       <span class="keywordtype">unsigned</span> old_bids_size = _bids.size();
00400       <span class="keywordtype">unsigned</span> new_bids_size = div_and_round_up (n, block_type::size);
00401       <span class="keywordtype">unsigned</span> new_pages = div_and_round_up(new_bids_size, page_size); 
00402       _page_status.resize(new_pages,uninitialized);
00403       _last_page.resize(new_pages,on_disk);
00404       
00405       _bids.resize(new_bids_size);
00406       bm-&gt;<a class="code" href="group__mnglayer.html#a11">new_blocks</a>(<a class="code" href="structstxxl_1_1offset__allocator.html">offset_allocator&lt;alloc_strategy&gt;</a>(old_bids_size,_alloc_strategy),
00407           _bids.begin() + old_bids_size,_bids.end());
00408     }
00409     <span class="keywordtype">void</span> resize(size_type n)
00410     {
00411       <span class="keywordtype">unsigned</span> old_bids_size = _bids.size();
00412       <span class="keywordtype">unsigned</span> new_bids_size = div_and_round_up (n, block_type::size);
00413       
00414       <span class="keywordflow">if</span>(new_bids_size &gt; old_bids_size)
00415       {
00416         reserve(n);
00417       }
00418       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(new_bids_size &lt; old_bids_size)
00419       {
00420         bm-&gt;<a class="code" href="group__mnglayer.html#a13">delete_blocks</a>(_bids.begin() + new_bids_size,_bids.end());
00421         _bids.resize(new_bids_size);
00422         
00423         <span class="keywordtype">unsigned</span> first_page_to_evict = div_and_round_up(new_bids_size, page_size);
00424         std::fill(_page_status.begin() + first_page_to_evict,
00425                   _page_status.end(), 0); <span class="comment">// clear dirty flag, so this pages </span>
00426                                           <span class="comment">// will be never written</span>
00427       }
00428       _size = n;
00429     }
00430     <span class="keywordtype">void</span> push_back(const_reference obj)
00431     {
00432       size_type old_size = _size;
00433       resize(old_size + 1);
00434       element(old_size) = obj;
00435     }
00436     <span class="keywordtype">void</span> pop_back()
00437     {
00438       resize(_size - 1);
00439     }
00440     reference back()
00441     {
00442       <span class="keywordflow">return</span> element(_size - 1);
00443     }
00444     reference front()
00445     {
00446       <span class="keywordflow">return</span> element(0);
00447     }
00448     <a class="code" href="classstxxl_1_1vector.html">vector</a> (<a class="code" href="classstxxl_1_1file.html">file</a> * from):
00449                         _size(from-&gt;size()/<span class="keyword">sizeof</span>(value_type)),
00450                         _bids(div_and_round_up(_size,block_type::size)),
00451                         _page_status(div_and_round_up (_bids.size(), page_size)),
00452                         _last_page(div_and_round_up (_bids.size(), page_size)),
00453                         _page_no(n_pages),
00454                         _cache(n_pages * page_size)
00455                 {
00456                         <span class="comment">// initialize from file</span>
00457                         assert(from-&gt;get_disk_number() == -1);
00458                         
00459                         <span class="keywordtype">int</span> all_pages = div_and_round_up (_bids.size(), page_size);
00460                         <span class="keywordtype">int</span> i=0;
00461                         <span class="keywordflow">for</span>(;i&lt;all_pages;i++)
00462                         {
00463                                 _page_status[i] = 0;
00464                                 _last_page[i] = on_disk;
00465                         }
00466                         
00467                         <span class="keywordflow">for</span>(i=0;i&lt;n_pages;i++)
00468                                 _free_pages.push(i);
00469                 
00470                         
00471                         size_type offset = 0; 
00472                         bids_container_iterator it = _bids.begin();
00473                         <span class="keywordflow">for</span>(;it!=_bids.end();it++,offset+=(block_type::size*<span class="keyword">sizeof</span>(value_type)) )
00474                         {
00475                                 (*it).storage = from;
00476                                 (*it).offset = offset;
00477                         }
00478                         
00479                 }
00480     <a class="code" href="classstxxl_1_1vector.html">vector</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1vector.html">vector</a> &amp; obj)
00481     {
00482       STXXL_MSG(<span class="stringliteral">"stxxl::vector copy constructor is not implemented yet"</span>);
00483       abort();
00484     }
00485                 size_type size ()<span class="keyword"> const</span>
00486 <span class="keyword">                </span>{
00487                         <span class="keywordflow">return</span> _size;
00488                 }
00489                 iterator begin ()
00490                 {
00491                         <span class="keywordflow">return</span> iterator (<span class="keyword">this</span>, 0);
00492                 }
00493                 const_iterator begin ()<span class="keyword"> const</span>
00494 <span class="keyword">                </span>{
00495                         <span class="keywordflow">return</span> const_iterator (<span class="keyword">this</span>, 0);
00496                 }
00497                 iterator end ()
00498                 {
00499                         <span class="keywordflow">return</span> iterator (<span class="keyword">this</span>, _size);
00500                 }
00501                 const_iterator end ()<span class="keyword"> const</span>
00502 <span class="keyword">                </span>{
00503                         <span class="keywordflow">return</span> const_iterator (<span class="keyword">this</span>, _size);
00504                 }
00505                 reference operator [] (size_type offset)
00506                 {
00507                         <span class="keywordflow">return</span> element(offset);
00508                 }
00509                 const_reference operator [] (size_type offset)<span class="keyword"> const</span>
00510 <span class="keyword">                </span>{
00511                         <span class="keywordflow">return</span> const_element(offset);
00512                 }
00513                 
00514                 <span class="keywordtype">void</span> flush()
00515                 {
00516                         simple_vector&lt;bool&gt; non_free_pages(n_pages);
00517                         <span class="keywordtype">int</span> i=0;
00518                         <span class="keywordflow">for</span>(;i&lt;n_pages;i++)
00519                                 non_free_pages[i] = <span class="keyword">true</span>;
00520                         
00521                         <span class="keywordflow">while</span>(!_free_pages.empty())
00522                         {
00523                                 non_free_pages[_free_pages.front()] = <span class="keyword">false</span>;
00524                                 _free_pages.pop();
00525                         }
00526                                 
00527                         <span class="keywordflow">for</span>(i=0;i&lt;n_pages;i++)
00528                         {
00529                                 _free_pages.push(i);
00530                                 <span class="keywordtype">int</span> page_no = _page_no[i];
00531                                 <span class="keywordflow">if</span>(non_free_pages[i])
00532                                 {
00533                                         <span class="comment">// STXXL_MSG("Flushing page "&lt;&lt;i&lt;&lt; " address: "&lt;&lt;(page_no*block_type::size*page_size));</span>
00534                                         <span class="keywordflow">if</span>(_page_status[page_no] &amp; dirty)
00535                                                 write_page(page_no,i);
00536                                 
00537                                         _last_page[page_no] = on_disk;
00538                                         _page_status[page_no] = 0;
00539                                 }
00540                         };
00541                 }
00542 <span class="keyword">private</span>:
00543                 bids_container_iterator bid (<span class="keyword">const</span> size_type &amp; offset)
00544                 {
00545                         <span class="keywordflow">return</span> (_bids.begin () +
00546                                 static_cast &lt; typename bids_container_type::size_type &gt;
00547                                 (offset / block_type::size));
00548                 }
00549                 const_bids_container_iterator bid (<span class="keyword">const</span> size_type &amp; offset)<span class="keyword"> const</span>
00550 <span class="keyword">                </span>{
00551                         <span class="keywordflow">return</span> (_bids.begin () +
00552                                 static_cast &lt; typename bids_container_type::size_type &gt;
00553                                 (offset / block_type::size));
00554                 }
00555                 <span class="keywordtype">void</span> read_page(<span class="keywordtype">int</span> page_no, <span class="keywordtype">int</span> cache_page)
00556                 {
00557                         <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> * reqs = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> [page_size];
00558                         <span class="keywordtype">int</span> block_no = page_no*page_size;
00559                         <span class="keywordtype">int</span> last_block =        std::min(block_no + page_size,<span class="keywordtype">int</span>(_bids.size()));
00560                         <span class="keywordtype">int</span> i=cache_page*page_size,j=0;
00561                         <span class="keywordflow">for</span>(;block_no &lt; last_block; block_no++,i++,j++)
00562                                 reqs[j] = _cache[i].read(_bids[block_no]);
00563                         <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,last_block - page_no*page_size);
00564                         <span class="keyword">delete</span> [] reqs;
00565                 }
00566                 <span class="keywordtype">void</span> write_page(<span class="keywordtype">int</span> page_no, <span class="keywordtype">int</span> cache_page)
00567                 {
00568                         <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> * reqs = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> [page_size];
00569                         <span class="keywordtype">int</span> block_no = page_no*page_size;
00570                         <span class="keywordtype">int</span> last_block = std::min(block_no + page_size,<span class="keywordtype">int</span>(_bids.size()));
00571                         <span class="keywordtype">int</span> i=cache_page*page_size,j=0;
00572                         <span class="keywordflow">for</span>(;block_no &lt; last_block; block_no++,i++,j++)
00573                         {
00574                                 reqs[j] = _cache[i].write(_bids[block_no]);
00575                         }
00576                         <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,last_block - page_no*page_size);
00577                         <span class="keyword">delete</span> [] reqs;
00578                 }
00579                 reference element(size_type offset)
00580                 {
00581                         <span class="keywordtype">int</span> page_no = offset/(block_type::size*page_size);
00582                         <span class="keywordtype">int</span> page_offset = offset % (block_type::size*page_size);
00583                         <span class="keywordtype">int</span> last_page = _last_page[page_no];
00584                         <span class="keywordflow">if</span>(last_page &lt; 0)  <span class="comment">// == on_disk</span>
00585                         { 
00586                                 <span class="keywordflow">if</span>(_free_pages.empty()) <span class="comment">// has to kick</span>
00587                                 {
00588                                         <span class="keywordtype">int</span> kicked_page = pager.kick();
00589                                         pager.hit(kicked_page);
00590                                         <span class="keywordtype">int</span> old_page_no = _page_no[kicked_page];
00591                                         _last_page[page_no] = kicked_page;
00592                                         _last_page[old_page_no] = on_disk;
00593                                         _page_no[kicked_page] = page_no;
00594                                                                 
00595                                         <span class="comment">// what to do with the old page ?</span>
00596                                         <span class="keywordflow">if</span>(_page_status[old_page_no] &amp; dirty)
00597                                         {
00598                                                 <span class="comment">// has to store changes</span>
00599                                                 write_page(old_page_no,kicked_page);
00600                                         }
00601                                         
00602                                         <span class="keywordflow">if</span>(_page_status[page_no] != uninitialized)
00603                                         {
00604                                                 read_page(page_no,kicked_page);
00605                                         }
00606                                         
00607                                         _page_status[page_no] = dirty;
00608                                         
00609                                         <span class="keywordflow">return</span> _cache[kicked_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00610                                 }
00611                                 <span class="keywordflow">else</span>
00612                                 {
00613                                         <span class="keywordtype">int</span> free_page = _free_pages.front();
00614                                         _free_pages.pop();
00615                                         pager.hit(free_page);
00616                                         _last_page[page_no] = free_page;
00617                                         _page_no[free_page] = page_no;
00618                                         
00619                                         <span class="keywordflow">if</span>(_page_status[page_no] != uninitialized)
00620                                         {
00621                                                 read_page(page_no,free_page);
00622                                         }
00623                                         
00624                                         _page_status[page_no] = dirty;
00625                                         
00626                                         <span class="keywordflow">return</span> _cache[free_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00627                                 }
00628                         } 
00629                         <span class="keywordflow">else</span>
00630                         {
00631                                 _page_status[page_no] = dirty;
00632                                 pager.hit(last_page);
00633                                 <span class="keywordflow">return</span> _cache[last_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00634                         }
00635                 };
00636                 const_reference const_element(size_type offset)<span class="keyword"> const</span>
00637 <span class="keyword">                </span>{
00638                         <span class="keywordtype">int</span> page_no = offset/(block_type::size*page_size);
00639                         <span class="keywordtype">int</span> page_offset = offset % (block_type::size*page_size);
00640                         <span class="keywordtype">int</span> last_page = _last_page[page_no];
00641                         <span class="keywordflow">if</span>(last_page &lt; 0)  <span class="comment">// == on_disk</span>
00642                         { 
00643                                 <span class="keywordflow">if</span>(_free_pages.empty()) <span class="comment">// has to kick</span>
00644                                 {
00645                                         <span class="keywordtype">int</span> kicked_page = pager.kick();
00646                                         pager.hit(kicked_page);
00647                                         <span class="keywordtype">int</span> old_page_no = _page_no[kicked_page];
00648                                         _last_page[page_no] = kicked_page;
00649                                         _last_page[old_page_no] = on_disk;
00650                                         _page_no[kicked_page] = page_no;
00651                                                                 
00652                                         <span class="comment">// what to do with the old page ?</span>
00653                                         <span class="keywordflow">if</span>(_page_status[old_page_no] &amp; dirty)
00654                                         {
00655                                                 <span class="comment">// has to store changes</span>
00656                                                 write_page(old_page_no,kicked_page);
00657                                         }
00658                                         
00659                                         <span class="keywordflow">if</span>(_page_status[page_no] != uninitialized)
00660                                         {
00661                                                 read_page(page_no,kicked_page);
00662                                         }
00663                                         
00664                                         _page_status[page_no] = 0;
00665                                         
00666                                         <span class="keywordflow">return</span> _cache[kicked_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00667                                 }
00668                                 <span class="keywordflow">else</span>
00669                                 {
00670                                         <span class="keywordtype">int</span> free_page = _free_pages.front();
00671                                         _free_pages.pop();
00672                                         pager.hit(free_page);
00673                                         _last_page[page_no] = free_page;
00674                                         _page_no[free_page] = page_no;
00675                                         
00676                                         <span class="keywordflow">if</span>(_page_status[page_no] != uninitialized)
00677                                         {
00678                                                 read_page(page_no,free_page);
00679                                         }
00680                                         
00681                                         _page_status[page_no] = 0;
00682                                         
00683                                         <span class="keywordflow">return</span> _cache[free_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00684                                 }
00685                         } 
00686                         <span class="keywordflow">else</span>
00687                         {
00688                                 pager.hit(last_page);
00689                                 <span class="keywordflow">return</span> _cache[last_page*page_size + page_offset/block_type::size][page_offset % block_type::size];
00690                         }
00691                 };
00692         };
00693   
00695   
00698   
00700   
00721         <span class="keyword">template</span>
00722   &lt; 
00723     <span class="keyword">typename</span> Tp_,
00724     <span class="keywordtype">unsigned</span> PgSz_ = 4,
00725     <span class="keywordtype">unsigned</span> Pages_ = 8,
00726     <span class="keywordtype">unsigned</span> BlkSize_ = STXXL_DEFAULT_BLOCK_SIZE (Tp_),
00727                 <span class="keyword">typename</span> AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY,
00728     pager_type Pager_ = lru
<a name="l00729"></a><a class="code" href="structstxxl_1_1VECTOR__GENERATOR.html">00729</a>         &gt;
00730   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1VECTOR__GENERATOR.html">VECTOR_GENERATOR</a>
00731   {
00732       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structstxxl_1_1IF.html">IF</a>&lt;Pager_==lru,
00733         <a class="code" href="classstxxl_1_1lru__pager.html">lru_pager&lt;Pages_&gt;</a>,<a class="code" href="classstxxl_1_1random__pager.html">random_pager&lt;Pages_&gt;</a> &gt;::result PagerType;
00734     
00735       <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1vector.html">vector&lt;Tp_,PgSz_,PagerType,BlkSize_,AllocStr_&gt;</a> result;
00736   };
00737     
00738     
00740 }
00741 
00742 
00743 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Jul 1 11:08:36 2003 for &lt;stxxl&gt; by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
