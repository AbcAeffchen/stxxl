<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>syscall_file.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>syscall_file.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef SYSCALL_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define SYSCALL_HEADER</span>
00003 <span class="preprocessor"></span><span class="comment">/***************************************************************************</span>
00004 <span class="comment"> *            syscall_file.h</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Sat Aug 24 23:55:08 2002</span>
00007 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00008 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00009 <span class="comment"> ****************************************************************************/</span>
00010 
00011 
00012 <span class="preprocessor">#include "ufs_file.h"</span>
00013 
00014 __STXXL_BEGIN_NAMESPACE
00015 
00018 
00020         <span class="keyword">class </span>syscall_file:<span class="keyword">public</span> ufs_file_base
00021         {
00022          <span class="keyword">protected</span>:
00023          <span class="keyword">public</span>:
00029                 syscall_file(
00030                                 <span class="keyword">const</span> std::string &amp; filename, 
00031                                 <span class="keywordtype">int</span> mode,
00032                           <span class="keywordtype">int</span> disk = -1): ufs_file_base (filename, mode, disk)
00033                 {
00034                 };
00035                 request_ptr aread(
00036                                 <span class="keywordtype">void</span> *buffer, 
00037                                 off_t pos, 
00038                                 size_t bytes,
00039                                 completion_handler on_cmpl);
00040                 request_ptr awrite(
00041                                 <span class="keywordtype">void</span> *buffer, 
00042                                 off_t pos,
00043                                 size_t bytes,
00044                                 completion_handler on_cmpl);
00045         };
00046         
00048         <span class="keyword">class </span>syscall_request: <span class="keyword">public</span> ufs_request_base
00049         {
00050                 <span class="keyword">friend</span> <span class="keyword">class </span>syscall_file;
00051          <span class="keyword">protected</span>:
00052                 syscall_request(
00053                                 syscall_file * f, 
00054                                 <span class="keywordtype">void</span> *buf, 
00055                                 off_t off,      
00056                                 size_t b, 
00057                                 request_type t,
00058                                 completion_handler on_cmpl):
00059                                                 ufs_request_base(f,buf,off,b,t,on_cmpl)
00060                 {
00061                 };
00062                 <span class="keywordtype">void</span> serve ();
<a name="l00063"></a><a class="code" href="classstxxl_1_1syscall__request.html#a0">00063</a>          <span class="keyword">public</span>:
00064                 <span class="keyword">const</span> <span class="keywordtype">char</span> *io_type ()
00065                 {
00066                         <span class="keywordflow">return</span> <span class="stringliteral">"syscall"</span>;
00067                 };
00068    <span class="keyword">private</span>:
00069     <span class="comment">// Following methods are declared but not implemented </span>
00070     <span class="comment">// intentionnaly to forbid their usage</span>
00071                 syscall_request(<span class="keyword">const</span> syscall_request &amp;);
00072     syscall_request &amp; operator=(<span class="keyword">const</span> syscall_request &amp;);
00073                 syscall_request();
00074         };
00075 
00076         <span class="keywordtype">void</span> syscall_request::serve ()
00077         {
00078                 stxxl_ifcheck (::lseek (file-&gt;get_file_des (), offset, SEEK_SET))
00079                 <span class="keywordflow">else</span>
00080                 {
00081                         <span class="keywordflow">if</span> (type == READ)
00082                         {
00083                                 stxxl_ifcheck (::read (file-&gt;get_file_des(),
00084                                                              buffer, bytes))
00085                         }
00086                         <span class="keywordflow">else</span>
00087                         {
00088                                 stxxl_ifcheck (::write (file-&gt;get_file_des (),
00089                                                       buffer, bytes));
00090                         }
00091                 }
00092 
00093                 _state.set_to (DONE);
00094 
00095                 waiters_mutex.lock ();
00096                 <span class="comment">// &lt;&lt; notification &gt;&gt;</span>
00097                 <a class="code" href="group__stlalgo.html#a10">std::for_each</a>(
00098                         waiters.begin(),
00099                         waiters.end(),
00100                         std::mem_fun(&amp;onoff_switch::on) );
00101                 
00102                 
00103                 waiters_mutex.unlock ();
00104 
00105                 completed ();
00106                 _state.set_to (READY2DIE);
00107         }
<a name="l00108"></a><a class="code" href="classstxxl_1_1syscall__file.html#a9">00108</a> 
00109         <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> syscall_file::aread (
00110                         <span class="keywordtype">void</span> *buffer, 
00111                         off_t pos, 
00112                         size_t bytes,
00113                         <a class="code" href="classstxxl_1_1completion__handler.html">completion_handler</a> on_cmpl)
00114         {
00115                 <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> req = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1syscall__request.html">syscall_request</a>(<span class="keyword">this</span>, 
00116                                         buffer, pos, bytes,
00117                                         request::READ, on_cmpl);
00118                 
00119                 <span class="keywordflow">if</span>(!req.<a class="code" href="classstxxl_1_1request__ptr.html#a7">get</a>())
00120                         stxxl_function_error;
00121                 
00122 <span class="preprocessor">                #ifndef NO_OVERLAPPING</span>
00123 <span class="preprocessor"></span>                disk_queues::get_instance ()-&gt;add_readreq(req,<a class="code" href="classstxxl_1_1file.html#a5">get_id</a>());
00124 <span class="preprocessor">                #endif</span>
00125 <span class="preprocessor"></span>    <span class="keywordflow">return</span> req;
<a name="l00126"></a><a class="code" href="classstxxl_1_1syscall__file.html#a10">00126</a>         };
00127         request_ptr syscall_file::awrite (
00128                         <span class="keywordtype">void</span> *buffer, 
00129                         off_t pos, 
00130                         size_t bytes,
00131                         completion_handler on_cmpl)
00132         {
00133                 request_ptr req = <span class="keyword">new</span> syscall_request(<span class="keyword">this</span>, buffer, pos, bytes,
00134                                            request::WRITE, on_cmpl);
00135     
00136                 <span class="keywordflow">if</span>(!req.get())
00137                         stxxl_function_error;
00138                 
00139 <span class="preprocessor">                #ifndef NO_OVERLAPPING</span>
00140 <span class="preprocessor"></span>                disk_queues::get_instance ()-&gt;add_writereq(req,<a class="code" href="classstxxl_1_1file.html#a5">get_id</a>());
00141 <span class="preprocessor">                #endif</span>
00142 <span class="preprocessor"></span>                <span class="keywordflow">return</span> req;
00143         };
00144 
00145   
00147   
00148 __STXXL_END_NAMESPACE
00149 
00150 
00151 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Jul 1 11:08:36 2003 for &lt;stxxl&gt; by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc1 </small></address>
</body>
</html>
