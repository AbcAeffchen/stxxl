<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: loosertree.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>loosertree.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef LOOSERTREE_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define LOOSERTREE_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            loosertree.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Sat Aug 24 23:52:58 2002</span>
00008 <span class="comment"> *  Copyright  2002  Roman Dementiev, Peter Sanders</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 <span class="preprocessor">#include "../common/utils.h"</span>
00012 
00013 __STXXL_BEGIN_NAMESPACE
00014 
00015 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> run_cursor_type, 
00016                                         <span class="keyword">typename</span> run_cursor_cmp_type,
00017                                         <span class="keywordtype">unsigned</span> buffer_size&gt;
00018 <span class="keyword">class </span>looser_tree
00019 {
00020         looser_tree ()
00021         {
00022         };
00023         <span class="keywordtype">int</span> logK;
00024         <span class="keywordtype">int</span> k;
00025 
00026         <span class="keywordtype">int</span> *entry;
00027         run_cursor_type *current;
00028         run_cursor_cmp_type cmp;
00029   
00030         <span class="keywordtype">int</span> init_winner (<span class="keywordtype">int</span> root)
00031         {
00032                 <span class="keywordflow">if</span> (root &gt;= k)
00033                 {
00034                         <span class="keywordflow">return</span> root - k;
00035                 }
00036                 <span class="keywordflow">else</span>
00037                 {
00038                         <span class="keywordtype">int</span> left = init_winner (2 * root);
00039                         <span class="keywordtype">int</span> right = init_winner (2 * root + 1);
00040                         <span class="keywordflow">if</span> (cmp (current[left], current[right]))
00041                         {
00042                                 entry[root] = right;
00043                                 <span class="keywordflow">return</span> left;
00044                         }
00045                         <span class="keywordflow">else</span>
00046                         {
00047                                 entry[root] = left;
00048                                 <span class="keywordflow">return</span> right;
00049                         }
00050                 }
00051         };
00052 <span class="keyword">public</span>:
00053         <span class="keyword">typedef</span> <span class="keyword">typename</span> run_cursor_type::prefetcher_type prefetcher_type;
00054         <span class="keyword">typedef</span> <span class="keyword">typename</span> run_cursor_type::value_type value_type;
00055         
00056         looser_tree (
00057                 prefetcher_type * p, 
00058                 <span class="keywordtype">int</span> nruns, 
00059                 run_cursor_cmp_type c): cmp(c)
00060         {
00061                 <span class="keywordtype">int</span> i;
00062                 logK = static_cast &lt; int &gt;(ceil (log (nruns) / log (2.)));      <span class="comment">// replace with something smart</span>
00063                 <span class="keywordtype">int</span> kReg = k = (1 &lt;&lt; logK);
00064     
00065 <span class="preprocessor">    #ifdef STXXL_SORT_SINGLE_PREFETCHER</span>
00066 <span class="preprocessor"></span>                current = <span class="keyword">new</span> run_cursor_type[kReg];
00067     run_cursor_type::prefetcher() = p;
00068 <span class="preprocessor">    #else</span>
00069 <span class="preprocessor"></span>    current = <span class="keyword">new</span> run_cursor_type[kReg](p);
00070 <span class="preprocessor">    #endif</span>
00071 <span class="preprocessor"></span>                entry = <span class="keyword">new</span> <span class="keywordtype">int</span>[(kReg &lt;&lt; 1)];
00072                 <span class="comment">// init cursors</span>
00073                 <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00074                 {
00075                         current[i].buffer = p-&gt;pull_block();
00076                         current[i].pos = 0;
00077                         entry[kReg + i] = i;
00078                 }
00079 
00080                 <span class="keywordflow">for</span> (i = nruns; i &lt; kReg; i++)
00081                 {
00082                         current[i].make_inf ();
00083                         entry[kReg + i] = i;
00084                 }
00085 
00086                 entry[0] = init_winner (1);
00087 
00088         }
00089         ~looser_tree()
00090         {
00091                 <span class="keyword">delete</span> [] current;
00092                 <span class="keyword">delete</span> [] entry;
00093         }
00094 
00095 <span class="keyword">private</span>:
00096         <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> LogK &gt; <span class="keywordtype">void</span> multi_merge_unrolled (value_type * to)
00097         {
00098                 run_cursor_type *currentE, *winnerE;
00099                 <span class="keywordtype">int</span> *regEntry = entry;
00100                 value_type *done = to + buffer_size;
00101                 <span class="keywordtype">int</span> winnerIndex = entry[0];
00102 
00103                 <span class="keywordflow">while</span> (LIKELY (to &lt; done))
00104                 {
00105                         winnerE = current + winnerIndex;
00106                         *(to++) = winnerE-&gt;current ();
00107 
00108                         (*winnerE)++;
00109 
00110 
00111 <span class="preprocessor">#define TreeStep(L)                                                                                                                                                                                                                                                                         \</span>
00112 <span class="preprocessor">      if (LogK &gt;= L )                                                                                                                                                                                                                                                               \</span>
00113 <span class="preprocessor">      {                                                                                                                                                                                                                                                                                                                     \</span>
00114 <span class="preprocessor">                                currentE = current +                                                            \</span>
00115 <span class="preprocessor">          regEntry[ (winnerIndex+(1&lt;&lt;LogK)) &gt;&gt; (((int(LogK-L)+1)&gt;=0)?((LogK-L)+1):0) ];\</span>
00116 <span class="preprocessor">                                if( cmp(*currentE,*winnerE) )                                                                                                                                                                                               \</span>
00117 <span class="preprocessor">                                {                                                                                                                                                                                                                                                                                                                   \</span>
00118 <span class="preprocessor">                                        swap(regEntry[(winnerIndex+(1&lt;&lt;LogK))                                         \</span>
00119 <span class="preprocessor">            &gt;&gt; (((int(LogK-L)+1)&gt;=0)?((LogK-L)+1):0) ],winnerIndex);                      \</span>
00120 <span class="preprocessor">                                        winnerE = currentE;                                                                                                                                                                                                                                 \</span>
00121 <span class="preprocessor">                                }                                                                                                                                                                                                                                                                                                                   \</span>
00122 <span class="preprocessor">      }</span>
00123 <span class="preprocessor"></span>
00124                         TreeStep (10);
00125                         TreeStep (9);
00126                         TreeStep (8);
00127                         TreeStep (7);
00128                         TreeStep (6);
00129                         TreeStep (5);
00130                         TreeStep (4);
00131                         TreeStep (3);
00132                         TreeStep (2);
00133                         TreeStep (1);
00134 
00135 <span class="preprocessor">#undef TreeStep</span>
00136 <span class="preprocessor"></span>
00137                 }
00138 
00139                 regEntry[0] = winnerIndex;
00140                 
00141         };
00142 
00143         <span class="keywordtype">void</span> multi_merge_k (value_type * to)
00144         {
00145                 run_cursor_type *currentE, *winnerE;
00146                 <span class="keywordtype">int</span> kReg = k;
00147                 value_type *done = to + buffer_size;
00148                 <span class="keywordtype">int</span> winnerIndex = entry[0];
00149 
00150                 <span class="keywordflow">while</span> (LIKELY (to &lt; done))
00151                 {
00152                         winnerE = current + winnerIndex;
00153                         *(to++) = winnerE-&gt;current ();
00154 
00155                         (*winnerE)++;
00156 
00157                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = (winnerIndex + kReg) &gt;&gt; 1; i &gt; 0;i &gt;&gt;= 1)
00158                         {
00159                                 currentE = current + entry[i];
00160 
00161                                 <span class="keywordflow">if</span> (cmp (*currentE, *winnerE))
00162                                 {
00163                                         swap (entry[i], winnerIndex);
00164                                         winnerE = currentE;
00165                                 }
00166                         }
00167                 }
00168 
00169                 entry[0] = winnerIndex;
00170         };
00171 
00172 <span class="keyword">public</span>:
00173         <span class="keywordtype">void</span> multi_merge (value_type * to)
00174         {
00175                 <span class="keywordflow">switch</span> (logK)
00176                 {
00177                 <span class="keywordflow">case</span> 2:
00178                         multi_merge_unrolled &lt; 2 &gt; (to);
00179                         <span class="keywordflow">break</span>;
00180                 <span class="keywordflow">case</span> 3:
00181                         multi_merge_unrolled &lt; 3 &gt; (to);
00182                         <span class="keywordflow">break</span>;
00183                 <span class="keywordflow">case</span> 4:
00184                         multi_merge_unrolled &lt; 4 &gt; (to);
00185                         <span class="keywordflow">break</span>;
00186                 <span class="keywordflow">case</span> 5:
00187                         multi_merge_unrolled &lt; 5 &gt; (to);
00188                         <span class="keywordflow">break</span>;
00189                 <span class="keywordflow">case</span> 6:
00190                         multi_merge_unrolled &lt; 6 &gt; (to);
00191                         <span class="keywordflow">break</span>;
00192                 <span class="keywordflow">case</span> 7:
00193                         multi_merge_unrolled &lt; 7 &gt; (to);
00194                         <span class="keywordflow">break</span>;
00195                 <span class="keywordflow">case</span> 8:
00196                         multi_merge_unrolled &lt; 8 &gt; (to);
00197                         <span class="keywordflow">break</span>;
00198                 <span class="keywordflow">case</span> 9:
00199                         multi_merge_unrolled &lt; 9 &gt; (to);
00200                         <span class="keywordflow">break</span>;
00201                 <span class="keywordflow">case</span> 10:
00202                         multi_merge_unrolled &lt; 10 &gt; (to);
00203                         <span class="keywordflow">break</span>;
00204                 <span class="keywordflow">default</span>:
00205                         multi_merge_k (to);
00206                         <span class="keywordflow">break</span>;
00207                 }
00208                 
00209         }
00210 
00211 };
00212 
00213 __STXXL_END_NAMESPACE
00214 
00215 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Nov 21 15:28:11 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
