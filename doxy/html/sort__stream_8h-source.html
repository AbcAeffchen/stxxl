<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: sort_stream.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>sort_stream.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef SORT_STREAM_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define SORT_STREAM_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            sort_stream.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Thu Oct  2 12:09:50 2003</span>
00008 <span class="comment"> *  Copyright  2003  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 
00013 <span class="preprocessor">#include "../common/utils.h"</span>
00014 <span class="preprocessor">#include "../algo/sort.h"</span>
00015 <span class="preprocessor">#include "../mng/buf_istream.h"</span>
00016 <span class="preprocessor">#include "../mng/buf_ostream.h"</span>
00017 
00018 __STXXL_BEGIN_NAMESPACE
00019 
00020 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz,<span class="keyword">class</span> Y,<span class="keyword">class</span> X &gt; 
00021   <span class="keyword">struct </span>bid_iterator_traits&lt; 
00022     __gnu_cxx::__normal_iterator&lt;  sort_local::trigger_entry&lt;BID&lt;blk_sz&gt;,Y&gt; * ,  X&gt; &gt;
00023         {
00024                 <span class="keyword">enum</span>
00025                 {
00026                         block_size = blk_sz
00027                 };      
00028         };
00029 
00030 
<a name="l00031"></a><a class="code" href="namespacestxxl_1_1stream.html">00031</a> <span class="keyword">namespace </span>stream
00032 {
00035  
00036   <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValueType,<span class="keyword">class</span> TriggerEntryType&gt;
00037   <span class="keyword">struct </span>sorted_runs
00038   {
00039     <span class="keyword">typedef</span> TriggerEntryType trigger_entry_type;
00040     <span class="keyword">typedef</span> ValueType value_type;
00041     <span class="keyword">typedef</span> <span class="keyword">typename</span> trigger_entry_type::bid_type bid_type;
00042     <span class="keyword">typedef</span> off_t size_type;
00043     <span class="keyword">typedef</span> std::vector&lt;trigger_entry_type&gt; run_type;
00044     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;bid_type::size,value_type&gt;</a> block_type;
00045     size_type elements;
00046     std::vector&lt;run_type&gt; runs;
00047         std::vector&lt;unsigned&gt; runs_sizes;
00048     
00049     sorted_runs():elements(0) {}
00050   };
00051   
00059   <span class="keyword">template</span> &lt;  
00060                           <span class="keyword">class </span>Input_,
00061               <span class="keyword">class </span>Cmp_,
00062               <span class="keywordtype">unsigned</span> BlockSize_ = STXXL_DEFAULT_BLOCK_SIZE(<span class="keyword">typename</span> Input_::value_type),
00063               <span class="keyword">class </span>AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY&gt;
<a name="l00064"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">00064</a>   <span class="keyword">class </span><a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a>
00065   {
00066     <span class="keyword">typedef</span> <span class="keyword">typename</span> Input_::value_type value_type;
00067     <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;BlockSize_&gt;</a> <a class="code" href="structstxxl_1_1BID.html">bid_type</a>;
00068     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;BlockSize_,value_type&gt;</a> <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>;
00069     <span class="keyword">typedef</span> sort_local::trigger_entry&lt;bid_type,value_type&gt; trigger_entry_type;
00070     Input_ &amp; input;
00071     Cmp_ cmp;
00072   <span class="keyword">public</span>:
00073     <span class="keyword">typedef</span> sorted_runs&lt;value_type,trigger_entry_type&gt; sorted_runs_type;
00074   <span class="keyword">private</span>:
00075     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::run_type run_type;
00076     sorted_runs_type result_; <span class="comment">// stores the result (sorted runs)</span>
00077     <span class="keywordtype">unsigned</span> m_; <span class="comment">// memory for internal use in blocks</span>
00078     <span class="keywordtype">bool</span> result_computed; <span class="comment">// true result is already computed (used in 'result' method)</span>
00079     
00080     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a>();<span class="comment">// default construction is forbidden</span>
00081     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a> &amp; );<span class="comment">// copy construction is forbidden</span>
00082     
00083     
00084     <span class="keywordtype">void</span> compute_result();
00085     <span class="keywordtype">void</span> sort_run(<a class="code" href="classstxxl_1_1typed__block.html">block_type</a> * run,<span class="keywordtype">unsigned</span> elements)
00086     {
00087       <span class="keywordflow">if</span>(block_type::has_filler)
00088         <a class="code" href="group__stlalgo.html#a12">std::sort</a>(
00089                   TwoToOneDimArrayRowAdaptor&lt; 
00090                     <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>,
00091                     value_type,
00092                     block_type::size &gt; (run,0 ),
00093                   TwoToOneDimArrayRowAdaptor&lt; 
00094                     block_type,
00095                     value_type,
00096                     block_type::size &gt; (run, 
00097                       elements )
00098                   ,cmp);
00099       <span class="keywordflow">else</span> 
00100         <a class="code" href="group__stlalgo.html#a12">std::sort</a>(run[0].elem, run[0].elem + elements, cmp);
00101     }
00102   <span class="keyword">public</span>:
<a name="l00107"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator.html#a0">00107</a>     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a>(Input_ &amp; i,Cmp_ c,<span class="keywordtype">unsigned</span> memory_to_use):
00108       input(i),cmp(c),m_(memory_to_use/BlockSize_),result_computed(false)
00109     {
00110     }
00111     
<a name="l00115"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator.html#a1">00115</a>     <span class="keyword">const</span> sorted_runs_type &amp; result()
00116     {
00117       <span class="keywordflow">if</span>(!result_computed)
00118       {
00119         compute_result();
00120         result_computed = <span class="keyword">true</span>;
00121       }
00122       <span class="keywordflow">return</span> result_;
00123     }
00124   };
00125   
00126  
00127   <span class="keyword">template</span> &lt;<span class="keyword">class</span> Input_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> BlockSize_,<span class="keyword">class</span> AllocStr_&gt;
00128   <span class="keywordtype">void</span> runs_creator&lt;Input_,Cmp_,BlockSize_,AllocStr_&gt;::compute_result()
00129   {
00130     <span class="keywordtype">unsigned</span> i = 0;
00131     <span class="keywordtype">unsigned</span> m2 = m_ / 2;
00132     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> el_in_run = m2* block_type::size; <span class="comment">// # el in a run</span>
00133     <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * bm = block_manager::get_instance();
00134     block_type *Blocks1 = <span class="keyword">new</span> block_type[m2*2];
00135     block_type *Blocks2 = Blocks1 + m2;
00136     <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> * write_reqs = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a>[m2];
00137     run_type run;
00138     
00139     <span class="keywordtype">unsigned</span> pos = 0;
00140     <span class="keywordflow">while</span>(!input.empty() &amp;&amp; pos != el_in_run)
00141     {
00142       Blocks1[pos/block_type::size][pos%block_type::size] = *input;
00143       ++input;
00144       ++pos;
00145     }
00146     
00147     <span class="comment">// sort first run</span>
00148     sort_run(Blocks1,pos);
00149     result_.elements = pos;
00150     <span class="keywordtype">unsigned</span> cur_run_size = div_and_round_up(pos,block_type::size); <span class="comment">// in blocks</span>
00151     run.resize(cur_run_size);
00152     bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(AllocStr_(),
00153       trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.begin()),
00154       trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.end())
00155     );
00156     
00157     disk_queues::get_instance ()-&gt;set_priority_op(disk_queue::WRITE);
00158     
00159         result_.runs_sizes.push_back(pos);
00160     
00161         <span class="comment">// fill the rest of the last block with max values</span>
00162     <span class="keywordflow">for</span>(;pos!=el_in_run;++pos)
00163         Blocks1[pos/block_type::size][pos%block_type::size] = cmp.max_value();
00164     
00165     <span class="keywordflow">for</span> (i = 0; i &lt; cur_run_size; ++i)
00166     {
00167         run[i].value = Blocks1[i][0];
00168         write_reqs[i] = Blocks1[i].write(run[i].bid);
00169         <span class="comment">//STXXL_MSG("BID: "&lt;&lt;run[i].bid&lt;&lt;" val: "&lt;&lt;run[i].value)</span>
00170     }
00171     result_.runs.push_back(run); <span class="comment">// #</span>
00172     
00173     <span class="keywordflow">if</span>(input.empty())
00174     {
00175       <span class="comment">// return</span>
00176       <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs,write_reqs + cur_run_size);
00177       <span class="keyword">delete</span> [] write_reqs;
00178       <span class="keyword">delete</span> [] Blocks1;
00179       <span class="keywordflow">return</span>;
00180     }
00181       
00182     pos = 0;
00183     <span class="keywordflow">while</span>(!input.empty() &amp;&amp; pos != el_in_run)
00184     {
00185       Blocks2[pos/block_type::size][pos%block_type::size] = *input;
00186       ++input;
00187       ++pos;
00188     }
00189     result_.elements += pos;
00190     
00191     <span class="keywordflow">if</span>(input.empty())
00192     {
00193       <span class="comment">// (re)sort internally and return</span>
00194       pos += el_in_run;
00195       sort_run(Blocks1,pos); <span class="comment">// sort first an second run together</span>
00196       <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs,write_reqs + cur_run_size);
00197       bm-&gt;<a class="code" href="group__mnglayer.html#a17">delete_blocks</a>(trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.begin()),
00198         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.end()) );
00199       
00200       cur_run_size = div_and_round_up(pos,block_type::size);
00201       run.resize(cur_run_size);
00202       bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(AllocStr_(),
00203         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.begin()),
00204         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.end())
00205       );
00206       
00207           result_.runs_sizes[0] = pos;
00208       <span class="comment">// fill the rest of the last block with max values</span>
00209       <span class="keywordflow">for</span>(;pos!=2*el_in_run;++pos)
00210         Blocks1[pos/block_type::size][pos%block_type::size] = cmp.max_value();
00211       
00212       <span class="keywordflow">for</span> (i = 0; i &lt; cur_run_size; ++i)
00213       {
00214         run[i].value = Blocks1[i][0];
00215         write_reqs[i]-&gt;wait();
00216         write_reqs[i] = Blocks1[i].write(run[i].bid);
00217       }
00218           
00219       result_.runs[0] = run;
00220       
00221       <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs,write_reqs+cur_run_size);
00222       <span class="keyword">delete</span> [] write_reqs;
00223       <span class="keyword">delete</span> [] Blocks1;
00224       
00225       <span class="keywordflow">return</span>;
00226     }
00227     
00228     sort_run(Blocks2,pos);
00229     
00230     cur_run_size = div_and_round_up(pos,block_type::size); <span class="comment">// in blocks</span>
00231     run.resize(cur_run_size);
00232     bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(AllocStr_(),
00233       trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.begin()),
00234       trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.end())
00235     );
00236     
00237     <span class="keywordflow">for</span>(i = 0; i &lt; cur_run_size; ++i)
00238     {
00239         run[i].value = Blocks2[i][0];
00240         write_reqs[i]-&gt;wait();
00241         write_reqs[i] = Blocks2[i].write(run[i].bid);
00242     }
00243         assert((pos % el_in_run) == 0);
00244         
00245     result_.runs.push_back(run);
00246         result_.runs_sizes.push_back(pos);
00247     
00248     <span class="keywordflow">while</span>(!input.empty())
00249     {
00250       pos = 0;
00251       <span class="keywordflow">while</span>(!input.empty() &amp;&amp; pos != el_in_run)
00252       {
00253         Blocks1[pos/block_type::size][pos%block_type::size] = *input;
00254         ++input;
00255         ++pos;
00256       }
00257       result_.elements += pos;
00258       sort_run(Blocks1,pos);
00259       cur_run_size = div_and_round_up(pos,block_type::size); <span class="comment">// in blocks</span>
00260       run.resize(cur_run_size);
00261       bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(AllocStr_(),
00262         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.begin()),
00263         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.end())
00264       );
00265       
00266       result_.runs_sizes.push_back(pos); 
00267           
00268           <span class="comment">// fill the rest of the last block with max values (occurs only on the last run)</span>
00269       <span class="keywordflow">for</span>(;pos!=el_in_run;++pos)
00270         Blocks1[pos/block_type::size][pos%block_type::size] = cmp.max_value();
00271       
00272       <span class="keywordflow">for</span>(i = 0; i &lt; cur_run_size; ++i)
00273       {
00274         run[i].value = Blocks1[i][0];
00275         write_reqs[i]-&gt;wait();
00276         write_reqs[i] = Blocks1[i].write(run[i].bid);
00277       }
00278       result_.runs.push_back(run); <span class="comment">// #</span>
00279           
00280       std::swap(Blocks1,Blocks2);
00281     }
00282     
00283     <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs,write_reqs+m2);
00284     <span class="keyword">delete</span> [] write_reqs;
00285     <span class="keyword">delete</span> [] ((Blocks1&lt;Blocks2)?Blocks1:Blocks2);
00286     
00287   }
00288   
00289   <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValueType_&gt;
00290   <span class="keyword">struct </span>use_push
00291   {
00292                 <span class="keyword">typedef</span> ValueType_ value_type;
00293   };
00294   
00301   <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValueType_&gt;
<a name="l00302"></a><a class="code" href="structstxxl_1_1stream_1_1from__sorted__sequences.html">00302</a>   <span class="keyword">struct </span><a class="code" href="structstxxl_1_1stream_1_1from__sorted__sequences.html">from_sorted_sequences</a>
00303   {
00304                 <span class="keyword">typedef</span> ValueType_ value_type;
00305   };
00306  
00318  <span class="keyword">template</span> &lt;  
00319                           <span class="keyword">class </span>ValueType_,
00320               <span class="keyword">class </span>Cmp_,
00321               <span class="keywordtype">unsigned</span> BlockSize_,
00322               <span class="keyword">class </span>AllocStr_&gt;
<a name="l00323"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator_3_01from__sorted__sequences_3_01ValueType___01_4_00_01Cmp___00_01BlockSize___00_01AllocStr___01_4.html">00323</a>   <span class="keyword">class </span><a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a>&lt;
00324                 from_sorted_sequences&lt;ValueType_&gt;,
00325                 Cmp_ ,
00326                 BlockSize_,
00327                 AllocStr_&gt;
00328   {
00329     <span class="keyword">typedef</span> ValueType_ value_type;
00330     <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;BlockSize_&gt;</a> <a class="code" href="structstxxl_1_1BID.html">bid_type</a>;
00331     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;BlockSize_,value_type&gt;</a> block_type;
00332     <span class="keyword">typedef</span> sort_local::trigger_entry&lt;bid_type,value_type&gt; trigger_entry_type;
00333         <span class="keyword">typedef</span> AllocStr_ alloc_strategy_type;
00334     Cmp_ cmp;
00335          
00336   <span class="keyword">public</span>:
00337     <span class="keyword">typedef</span> sorted_runs&lt;value_type,trigger_entry_type&gt; sorted_runs_type;
00338   <span class="keyword">private</span>:
00339     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::run_type run_type;
00340     sorted_runs_type result_; <span class="comment">// stores the result (sorted runs)</span>
00341     <span class="keywordtype">unsigned</span> m_; <span class="comment">// memory for internal use in blocks</span>
00342     <a class="code" href="classstxxl_1_1buffered__writer.html">buffered_writer&lt;block_type&gt;</a>  writer;
00343         block_type * cur_block;
00344         <span class="keywordtype">unsigned</span> offset;
00345         <span class="keywordtype">unsigned</span> iblock;
00346         <span class="keywordtype">unsigned</span> irun;
00347         alloc_strategy_type alloc_strategy;
00348  
00349     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html#a0">runs_creator</a>();<span class="comment">// default construction is forbidden</span>
00350     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html#a0">runs_creator</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a> &amp; );<span class="comment">// copy construction is forbidden</span>
00351     
00352   <span class="keyword">public</span>:
<a name="l00357"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator_3_01from__sorted__sequences_3_01ValueType___01_4_00_01Cmp___00_01BlockSize___00_01AllocStr___01_4.html#a0">00357</a>     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html#a0">runs_creator</a>(Cmp_ c,<span class="keywordtype">unsigned</span> memory_to_use):
00358         cmp(c),
00359                 m_(memory_to_use/BlockSize_),
00360                 writer(m_,m_/2),
00361                 cur_block(writer.get_free_block()),
00362                 offset(0),
00363                 iblock(0),
00364                 irun(0)
00365     {
00366     }
00367         
<a name="l00370"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator_3_01from__sorted__sequences_3_01ValueType___01_4_00_01Cmp___00_01BlockSize___00_01AllocStr___01_4.html#a1">00370</a>         <span class="keywordtype">void</span> push(<span class="keyword">const</span> value_type &amp; val)
00371         {
00372                 assert(offset &lt; block_type::size );
00373                         
00374                 (*cur_block)[offset] = val;
00375                 ++offset;
00376                 
00377                 <span class="keywordflow">if</span>(offset == block_type::size)
00378                 {
00379                         <span class="comment">// write current block</span>
00380                         
00381                         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * bm = block_manager::get_instance ();
00382                         <span class="comment">// allocate space for the block</span>
00383                         result_.runs.resize(irun + 1);
00384                         result_.runs[irun].resize( iblock + 1 );
00385                         bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(
00386                                 <a class="code" href="structstxxl_1_1offset__allocator.html">offset_allocator&lt;alloc_strategy_type&gt;</a>(iblock,alloc_strategy),
00387                         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(result_.runs[irun].begin() 
00388                                         + iblock),
00389                         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(result_.runs[irun].end())
00390                         );
00391                         
00392                         result_.runs[irun][iblock].value = (*cur_block)[0]; <span class="comment">// init trigger</span>
00393                         cur_block = writer.write(cur_block, result_.runs[irun][iblock].bid);
00394                         ++iblock;
00395                         
00396                         offset = 0 ;
00397                 }
00398                 
00399                 ++result_.elements;
00400         }
00401     
<a name="l00403"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator_3_01from__sorted__sequences_3_01ValueType___01_4_00_01Cmp___00_01BlockSize___00_01AllocStr___01_4.html#a2">00403</a>         <span class="keywordtype">void</span> finish()
00404         {
00405                 <span class="keywordflow">if</span>(offset == 0 &amp;&amp; iblock == 0) <span class="comment">// current run is empty</span>
00406                         <span class="keywordflow">return</span>;
00407                         
00408                 result_.runs_sizes.resize(irun + 1);
00409                 result_.runs_sizes.back() = iblock* block_type::size + offset;
00410                 
00411                 <span class="keywordflow">if</span>(offset) <span class="comment">// if current block is parially filled</span>
00412                 {
00413                         <span class="keywordflow">while</span>(offset != block_type::size)
00414                         {
00415                                 (*cur_block)[offset] = cmp.max_value();
00416                                 ++offset;
00417                         }
00418                         offset = 0;
00419                         
00420                         <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> *  bm = block_manager::get_instance ();
00421                         <span class="comment">// allocate space for the block</span>
00422                         result_.runs.resize(irun + 1);
00423                         result_.runs[irun].resize( iblock + 1 );
00424                         bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(
00425                                 <a class="code" href="structstxxl_1_1offset__allocator.html">offset_allocator&lt;alloc_strategy_type&gt;</a>(iblock,alloc_strategy),
00426                         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(result_.runs[irun].begin() 
00427                                         + iblock),
00428                         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(result_.runs[irun].end())
00429                         );
00430                         
00431                         result_.runs[irun][iblock].value = (*cur_block)[0]; <span class="comment">// init trigger</span>
00432                         cur_block = writer.write(cur_block, result_.runs[irun][iblock].bid);
00433 
00434                 }
00435                 <span class="keywordflow">else</span>
00436                 {
00437                 }
00438                 
00439                 iblock = 0 ;
00440                 ++irun;
00441         }
00442         
<a name="l00446"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator_3_01from__sorted__sequences_3_01ValueType___01_4_00_01Cmp___00_01BlockSize___00_01AllocStr___01_4.html#a3">00446</a>     <span class="keyword">const</span> sorted_runs_type &amp; <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html#a1">result</a>()
00447     {
00448                         finish();
00449                         writer.flush();
00450                 
00451                         <span class="keywordflow">return</span> result_;
00452     }
00453   };
00454   
00455   
00456   
00461   <span class="keyword">template</span> &lt;<span class="keyword">class</span> RunsType_, <span class="keyword">class</span> Cmp_&gt;
<a name="l00462"></a><a class="code" href="group__streampack.html#a0">00462</a>   <span class="keywordtype">bool</span> <a class="code" href="group__streampack.html#a0">check_sorted_runs</a>(RunsType_ &amp; sruns, Cmp_ cmp)
00463   {
00464     <span class="keyword">typedef</span> <span class="keyword">typename</span> RunsType_::block_type block_type;
00465     <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type value_type;
00466     STXXL_VERBOSE2(<span class="stringliteral">"Elements: "</span>&lt;&lt;sruns.elements)
00467     <span class="keywordtype">unsigned</span> nruns = sruns.runs.size();
00468     STXXL_VERBOSE2(<span class="stringliteral">"Runs: "</span>&lt;&lt;nruns)
00469     <span class="keywordtype">unsigned</span> irun=0;
00470     <span class="keywordflow">for</span>(irun = 0;irun&lt;nruns;++irun)
00471     {
00472        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nblocks = sruns.runs[irun].size();
00473        block_type * blocks = <span class="keyword">new</span> block_type[nblocks];
00474        request_ptr * reqs = <span class="keyword">new</span> request_ptr[nblocks];
00475        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;nblocks;++j)
00476        {
00477          reqs[j] = blocks[j].read(sruns.runs[irun][j].bid);
00478        }
00479        <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,reqs + nblocks);
00480        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;nblocks;++j)
00481        {
00482          <span class="keywordflow">if</span>(blocks[j][0] != sruns.runs[irun][j].value)
00483            <span class="keywordflow">return</span> <span class="keyword">false</span>;
00484        }
00485        <span class="keywordflow">if</span>(!is_sorted(
00486                   TwoToOneDimArrayRowAdaptor&lt; 
00487                     block_type,
00488                     value_type,
00489                     block_type::size &gt; (blocks,0 ),
00490                   TwoToOneDimArrayRowAdaptor&lt; 
00491                     block_type,
00492                     value_type,
00493                     block_type::size &gt; (blocks, 
00494                        <span class="comment">//nblocks*block_type::size</span>
00495                       <span class="comment">//(irun&lt;nruns-1)?(nblocks*block_type::size): (sruns.elements%(nblocks*block_type::size))</span>
00496                                         sruns.runs_sizes[irun]
00497                   ),cmp) )
00498            <span class="keywordflow">return</span> <span class="keyword">false</span>;
00499        
00500        <span class="keyword">delete</span> [] reqs;
00501        <span class="keyword">delete</span> [] blocks;
00502     }
00503 
00504     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00505   }
00506   
00514   <span class="keyword">template</span> &lt;  <span class="keyword">class </span>RunsType_,
00515               <span class="keyword">class </span>Cmp_,
00516               <span class="keyword">class </span>AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY &gt;
<a name="l00517"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">00517</a>   <span class="keyword">class </span><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger</a>
00518   {
00519     <span class="keyword">typedef</span> RunsType_ sorted_runs_type;
00520     <span class="keyword">typedef</span> AllocStr_ alloc_strategy;
00521     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::size_type size_type;
00522     <span class="keyword">typedef</span> Cmp_ value_cmp;
00523     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::run_type run_type;
00524     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::block_type block_type;
00525     <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00526     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__prefetcher.html">block_prefetcher&lt;block_type,typename run_type::iterator&gt;</a> <a class="code" href="classstxxl_1_1block__prefetcher.html">prefetcher_type</a>;
00527     <span class="keyword">typedef</span> run_cursor2&lt;block_type,prefetcher_type&gt; run_cursor_type;
00528     <span class="keyword">typedef</span> sort_local::run_cursor2_cmp&lt;block_type,prefetcher_type,value_cmp&gt; run_cursor2_cmp_type;
00529     <span class="keyword">typedef</span> looser_tree&lt;run_cursor_type,run_cursor2_cmp_type,block_type::size&gt; looser_tree_type;
00530     
00531     sorted_runs_type sruns;
00532     <span class="keywordtype">unsigned</span> m_; <span class="comment">//  blocks to use - 1</span>
00533     value_cmp cmp;
00534     size_type elements_remaining;
00535     <span class="keywordtype">unsigned</span> buffer_pos;
00536     block_type current_block;
00537     run_type consume_seq;
00538     <a class="code" href="classstxxl_1_1block__prefetcher.html">prefetcher_type</a> * prefetcher;
00539     looser_tree_type * loosers;
00540     <span class="keywordtype">int</span> * prefetch_seq;
00541     
00542     <span class="keywordtype">void</span> merge_recursively();
00543     
00544     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a0">runs_merger</a>(); <span class="comment">// forbidden</span>
00545     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a0">runs_merger</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger</a> &amp;); <span class="comment">// forbidden</span>
00546   <span class="keyword">public</span>:
<a name="l00548"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#w0">00548</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::value_type <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#w0">value_type</a>;
00549     
<a name="l00554"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a0">00554</a>     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a0">runs_merger</a>(<span class="keyword">const</span> sorted_runs_type &amp; r,value_cmp c,<span class="keywordtype">unsigned</span> memory_to_use):
00555       sruns(r),m_(memory_to_use/block_type::raw_size <span class="comment">/* - 1 */</span>),cmp(c),
00556       elements_remaining(r.elements)
00557     {
00558       disk_queues::get_instance ()-&gt;set_priority_op (disk_queue::WRITE);
00559       
00560       <span class="keywordtype">unsigned</span> nruns = sruns.runs.size();
00561       
00562       <span class="keywordflow">if</span>(m_ &lt; nruns)
00563       {
00564         <span class="comment">// can not merge runs in one pass</span>
00565         <span class="comment">// merge recursively:</span>
00566         STXXL_ERRMSG(<span class="stringliteral">"An implementation requires more than one merge pass, therefore for a better"</span>)
00567         STXXL_ERRMSG(<span class="stringliteral">"efficiency decrease block size of run storage (a parameter of the run_creator)"</span>)
00568         STXXL_ERRMSG(<span class="stringliteral">"or increase the ammount memory dedicated to the merger."</span>)
00569         STXXL_ERRMSG(<span class="stringliteral">"m = "</span>&lt;&lt; m_&lt;&lt;<span class="stringliteral">" nruns="</span>&lt;&lt;nruns)
00570         
00571         merge_recursively();
00572         
00573         nruns = sruns.runs.size();
00574       }
00575       
00576       assert(nruns &lt;= m_);
00577       
00578       <span class="keywordtype">unsigned</span> i;
00579           <span class="comment">/*</span>
00580 <span class="comment">      const unsigned out_run_size =  </span>
00581 <span class="comment">                div_and_round_up(elements_remaining,size_type(block_type::size));</span>
00582 <span class="comment">          */</span>
00583           <span class="keywordtype">unsigned</span> prefetch_seq_size = 0;
00584           <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00585       {
00586                   prefetch_seq_size += sruns.runs[i].size() ;
00587       }
00588           
00589       consume_seq.resize(prefetch_seq_size);
00590     
00591       prefetch_seq = <span class="keyword">new</span> <span class="keywordtype">int</span>[prefetch_seq_size];
00592       
00593       <span class="keyword">typename</span> run_type::iterator copy_start = consume_seq.begin ();
00594       <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00595       {
00596         copy_start = std::copy(
00597                 sruns.runs[i].begin (),
00598                 sruns.runs[i].end (),
00599                 copy_start      );
00600       }
00601       
00602       <a class="code" href="group__stlalgo.html#a12">std::sort</a>(consume_seq.begin (), consume_seq.end (),
00603               sort_local::trigger_entry_cmp&lt;bid_type,value_type,value_cmp&gt;(cmp));
00604     
00605       <span class="keywordtype">int</span> disks_number = config::get_instance ()-&gt;disks_number ();
00606       
00607       <span class="keyword">const</span> <span class="keywordtype">int</span> n_prefetch_buffers = std::max( 2 * disks_number , (<span class="keywordtype">int</span>(m_) - <span class="keywordtype">int</span>(nruns)) );
00608     
00609 <span class="preprocessor">      #ifdef SORT_OPT_PREFETCHING</span>
00610 <span class="preprocessor"></span>      <span class="comment">// heuristic</span>
00611       <span class="keyword">const</span> <span class="keywordtype">int</span> n_opt_prefetch_buffers = 2 * disks_number + (3*(n_prefetch_buffers - 2 * disks_number))/10;
00612       
00613       compute_prefetch_schedule(
00614           consume_seq,
00615           prefetch_seq,
00616           n_opt_prefetch_buffers,
00617           disks_number );
00618 <span class="preprocessor">      #else</span>
00619 <span class="preprocessor"></span>      <span class="keywordflow">for</span>(i=0;i&lt;prefetch_seq_size;++i)
00620         prefetch_seq[i] = i;
00621 <span class="preprocessor">      #endif</span>
00622 <span class="preprocessor"></span>      
00623      
00624       prefetcher = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1block__prefetcher.html">prefetcher_type</a>( 
00625                                                                                 consume_seq.begin(),
00626                                         consume_seq.end(),
00627                                         prefetch_seq,
00628                                         nruns + n_prefetch_buffers);
00629       
00630     
00631       loosers  =  <span class="keyword">new</span> looser_tree_type(prefetcher, nruns,run_cursor2_cmp_type(cmp));
00632       
00633       loosers-&gt;multi_merge(current_block.elem);
00634       current_value = current_block.elem[0];
00635       buffer_pos = 1;
00636     }
00637     
<a name="l00639"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">00639</a>     <span class="keywordtype">bool</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">empty</a>()<span class="keyword"> const</span>
00640 <span class="keyword">    </span>{
00641       <span class="keywordflow">return</span> elements_remaining==0;
00642     }
<a name="l00644"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a2">00644</a>     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger</a> &amp; <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a2">operator ++</a>() <span class="comment">// preincrement operator</span>
00645     {
00646       assert(!<a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">empty</a>());
00647       
00648       --elements_remaining;
00649       
00650       <span class="keywordflow">if</span>(buffer_pos != block_type::size)
00651       {
00652         current_value = current_block.elem[buffer_pos];
00653         ++buffer_pos;
00654       }
00655       <span class="keywordflow">else</span>
00656       {
00657         <span class="keywordflow">if</span>(!<a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">empty</a>())
00658         {
00659           loosers-&gt;multi_merge(current_block.elem);
00660           current_value = current_block.elem[0];  
00661           buffer_pos = 1;
00662         }
00663       }
00664       
00665       
00666       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00667     }
<a name="l00669"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a3">00669</a>     <span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#w0">value_type</a> &amp; <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a3">operator * </a>()<span class="keyword"> const</span>
00670 <span class="keyword">    </span>{
00671       assert(!<a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">empty</a>());
00672       <span class="keywordflow">return</span> current_value;
00673     }
<a name="l00676"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a4">00676</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a4">~runs_merger</a>()
00677     {
00678       <span class="keyword">delete</span> loosers;
00679       <span class="keyword">delete</span> prefetcher;
00680       <span class="keyword">delete</span> [] prefetch_seq;
00681       
00682       <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * bm = block_manager::get_instance();
00683       <span class="comment">// free blocks in runs</span>
00684       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;sruns.runs.size();++i)
00685         bm-&gt;<a class="code" href="group__mnglayer.html#a17">delete_blocks</a>(
00686           trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(sruns.runs[i].begin()),
00687           trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(sruns.runs[i].end()) );
00688     }
00689   <span class="keyword">private</span>:
00690     <span class="comment">// cache for the current value</span>
00691     value_type current_value;
00692   };
00693   
00694   
00695   <span class="keyword">template</span> &lt;<span class="keyword">class</span> RunsType_,<span class="keyword">class</span> Cmp_,<span class="keyword">class</span> AllocStr_&gt;
00696   <span class="keywordtype">void</span> runs_merger&lt;RunsType_,Cmp_,AllocStr_&gt;::merge_recursively()
00697   {
00698     <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * bm = block_manager::get_instance();
00699     <span class="keywordtype">unsigned</span> ndisks = config::get_instance ()-&gt;disks_number ();
00700     <span class="keywordtype">unsigned</span> nwrite_buffers = 2*ndisks;
00701     
00702     <span class="keywordtype">unsigned</span> nruns = sruns.runs.size();
00703     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> merge_factor = static_cast&lt;unsigned&gt;(ceil(pow(nruns,1./ceil(log(nruns)/log(m_)))));
00704     assert(merge_factor &lt;= m_);
00705     <span class="keywordflow">while</span>(nruns &gt; m_)
00706     {
00707       <span class="keywordtype">unsigned</span> new_nruns = div_and_round_up(nruns,merge_factor);
00708       STXXL_VERBOSE(<span class="stringliteral">"Starting new merge phase: nruns: "</span>&lt;&lt;nruns&lt;&lt;
00709         <span class="stringliteral">" opt_merge_factor: "</span>&lt;&lt;merge_factor&lt;&lt;<span class="stringliteral">" m:"</span>&lt;&lt;m_&lt;&lt;<span class="stringliteral">" new_nruns: "</span>&lt;&lt;new_nruns)
00710       
00711       sorted_runs_type new_runs;
00712       new_runs.runs.resize(new_nruns);
00713           new_runs.runs_sizes.resize(new_nruns);
00714       new_runs.elements = sruns.elements;
00715       
00716       <span class="keywordtype">unsigned</span> runs_left = nruns;
00717       <span class="keywordtype">unsigned</span> cur_out_run = 0;
00718           <span class="keywordtype">unsigned</span> elements_in_new_run = 0 ;
00719       <span class="comment">//unsigned blocks_in_new_run = 0;</span>
00720       
00721       
00722       <span class="keywordflow">while</span>(runs_left &gt; 0)
00723       {
00724         <span class="keywordtype">int</span> runs2merge = STXXL_MIN(runs_left,merge_factor);
00725         <span class="comment">//blocks_in_new_run = 0 ;</span>
00726                 elements_in_new_run = 0 ;
00727         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = nruns - runs_left; i &lt; (nruns - runs_left + runs2merge);++i)
00728                 {
00729                   elements_in_new_run += sruns.runs_sizes[i];
00730           <span class="comment">//blocks_in_new_run += sruns.runs[i].size();</span>
00731                 }
00732                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> blocks_in_new_run1 = div_and_round_up(elements_in_new_run,block_type::size);
00733                 <span class="comment">//assert(blocks_in_new_run1 == blocks_in_new_run);</span>
00734         
00735                 new_runs.runs_sizes[cur_out_run] = elements_in_new_run;
00736                 <span class="comment">// allocate run</span>
00737         new_runs.runs[cur_out_run++].resize(blocks_in_new_run1);
00738         runs_left -= runs2merge;
00739         
00740       }
00741       
00742       <span class="comment">// allocate blocks for the new runs</span>
00743       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;new_runs.runs.size();++i)
00744         bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>( alloc_strategy(),
00745           trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(new_runs.runs[i].begin()),
00746           trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(new_runs.runs[i].end()) );
00747       
00748       <span class="comment">// merge all</span>
00749       runs_left = nruns;
00750       cur_out_run = 0;
00751       size_type elements_left = sruns.elements;
00752       
00753       <span class="keywordflow">while</span>(runs_left &gt; 0)
00754       {
00755           <span class="keywordtype">unsigned</span> runs2merge = STXXL_MIN(runs_left,merge_factor);
00756           STXXL_VERBOSE(<span class="stringliteral">"Merging "</span>&lt;&lt;runs2merge&lt;&lt;<span class="stringliteral">" runs"</span>)
00757           
00758           sorted_runs_type cur_runs;
00759           cur_runs.runs.resize(runs2merge);
00760                   cur_runs.runs_sizes.resize(runs2merge);
00761         
00762           std::copy(sruns.runs.begin() + nruns - runs_left,
00763                     sruns.runs.begin() + nruns - runs_left + runs2merge,
00764                     cur_runs.runs.begin() );
00765                   std::copy(sruns.runs_sizes.begin() + nruns - runs_left,
00766                     sruns.runs_sizes.begin() + nruns - runs_left + runs2merge,
00767                     cur_runs.runs_sizes.begin() );
00768         
00769           runs_left -= runs2merge;
00770                   <span class="comment">/*</span>
00771 <span class="comment">          cur_runs.elements = (runs_left)? </span>
00772 <span class="comment">            (new_runs.runs[cur_out_run].size()*block_type::size):</span>
00773 <span class="comment">            (elements_left);</span>
00774 <span class="comment">                  */</span>
00775                   cur_runs.elements = new_runs.runs_sizes[cur_out_run];
00776           elements_left -= cur_runs.elements;
00777           
00778           <span class="keywordflow">if</span>(runs2merge &gt; 1)
00779           { 
00780             
00781             runs_merger&lt;RunsType_,Cmp_,AllocStr_&gt; merger(cur_runs,cmp,m_*block_type::raw_size);  
00782             
00783             { <span class="comment">// make sure everything is being destroyed in right time</span>
00784               
00785               buf_ostream&lt;block_type,typename run_type::iterator&gt; out(
00786                   new_runs.runs[cur_out_run].begin(),
00787                   nwrite_buffers );
00788               
00789               size_type cnt = 0;
00790               <span class="keyword">const</span> size_type cnt_max = cur_runs.elements;
00791               
00792               <span class="keywordflow">while</span>(cnt != cnt_max)
00793               {
00794                 *out = *merger;
00795                 <span class="keywordflow">if</span>( (cnt % block_type::size) == 0) <span class="comment">// have to write the trigger value</span>
00796                   new_runs.runs[cur_out_run][cnt/size_type(block_type::size)].value = *merger;
00797                 
00798                 ++cnt;
00799                 ++out;
00800                 ++merger;
00801               }
00802               assert(merger.empty());
00803               
00804               <span class="keywordflow">while</span>(cnt % block_type::size)
00805               {
00806                 *out = cmp.max_value();
00807                 ++out;
00808                 ++cnt;
00809               }
00810             } 
00811           }
00812           <span class="keywordflow">else</span>
00813           {
00814             bm-&gt;<a class="code" href="group__mnglayer.html#a17">delete_blocks</a>( 
00815               trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(
00816                   new_runs.runs.back().begin()),
00817               trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(
00818                   new_runs.runs.back().end()) );
00819       
00820             assert(cur_runs.runs.size() == 1);
00821             
00822             std::copy(cur_runs.runs.front().begin(),
00823                       cur_runs.runs.front().end(),
00824                       new_runs.runs.back().begin());
00825                         new_runs.runs_sizes.back() = cur_runs.runs_sizes.back();
00826           }
00827           
00828           ++cur_out_run;
00829       }
00830       assert(elements_left == 0);
00831       
00832       nruns = new_nruns;
00833       sruns = new_runs;
00834       
00835     }
00836   }
00837   
00838   
00847   <span class="keyword">template</span> &lt;  <span class="keyword">class </span>Input_,
00848               <span class="keyword">class </span>Cmp_,
00849               <span class="keywordtype">unsigned</span> BlockSize_ = STXXL_DEFAULT_BLOCK_SIZE(<span class="keyword">typename</span> Input_::value_type),
00850               <span class="keyword">class </span>AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY&gt;
<a name="l00851"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html">00851</a>   <span class="keyword">class </span><a class="code" href="classstxxl_1_1stream_1_1sort.html">sort</a>
00852   {
00853     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator&lt;Input_,Cmp_,BlockSize_,AllocStr_&gt;</a> <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator_type</a>;
00854     <span class="keyword">typedef</span> <span class="keyword">typename</span> runs_creator_type::sorted_runs_type sorted_runs_type;
00855     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger&lt;sorted_runs_type,Cmp_,AllocStr_&gt;</a> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger_type</a>;
00856     
00857     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator_type</a> creator;
00858     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger_type</a> merger;
00859     
00860     <a class="code" href="classstxxl_1_1stream_1_1sort.html#a0">sort</a>(); <span class="comment">// forbidden</span>
00861     <a class="code" href="classstxxl_1_1stream_1_1sort.html#a0">sort</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1sort.html">sort</a> &amp;); <span class="comment">// forbidden</span>
00862   <span class="keyword">public</span>:
<a name="l00864"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html#w0">00864</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Input_::value_type <a class="code" href="classstxxl_1_1stream_1_1sort.html#w0">value_type</a>;
00865    
<a name="l00870"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html#a0">00870</a>     <a class="code" href="classstxxl_1_1stream_1_1sort.html#a0">sort</a>(Input_ &amp; in,Cmp_ c,<span class="keywordtype">unsigned</span> memory_to_use):
00871       creator(in,c,memory_to_use),
00872       merger(creator.result(),c,memory_to_use) {}
00873         
<a name="l00875"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html#a1">00875</a>     <span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1sort.html#w0">value_type</a> &amp; <a class="code" href="classstxxl_1_1stream_1_1sort.html#a1">operator * </a>()<span class="keyword"> const</span>
00876 <span class="keyword">    </span>{
00877       <span class="keywordflow">return</span> *merger;
00878     }
00879     
<a name="l00881"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html#a2">00881</a>     <a class="code" href="classstxxl_1_1stream_1_1sort.html">sort</a> &amp; <a class="code" href="classstxxl_1_1stream_1_1sort.html#a2">operator ++</a>()
00882     {
00883       ++merger;
00884       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00885     }
00886     
<a name="l00888"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html#a3">00888</a>     <span class="keywordtype">bool</span> <a class="code" href="classstxxl_1_1stream_1_1sort.html#a3">empty</a>()<span class="keyword"> const</span>
00889 <span class="keyword">    </span>{
00890       <span class="keywordflow">return</span> merger.<a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">empty</a>();
00891     }
00892     
00893   };
00894     
00895   
00897   
00898 };
00899 
00900 
00901 
00902 __STXXL_END_NAMESPACE
00903 
00904 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Nov 26 10:56:54 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
