<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: sort_stream.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>sort_stream.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef SORT_STREAM_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define SORT_STREAM_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            sort_stream.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Thu Oct  2 12:09:50 2003</span>
00008 <span class="comment"> *  Copyright  2003  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 
00013 <span class="preprocessor">#include "../common/utils.h"</span>
00014 <span class="preprocessor">#include "../algo/sort.h"</span>
00015 <span class="preprocessor">#include "../mng/buf_istream.h"</span>
00016 <span class="preprocessor">#include "../mng/buf_ostream.h"</span>
00017 
00018 __STXXL_BEGIN_NAMESPACE
00019 
00020 <span class="keyword">template</span> &lt; <span class="keywordtype">unsigned</span> blk_sz,<span class="keyword">class</span> Y,<span class="keyword">class</span> X &gt; 
00021   <span class="keyword">struct </span>bid_iterator_traits&lt; 
00022     __gnu_cxx::__normal_iterator&lt;  sort_local::trigger_entry&lt;BID&lt;blk_sz&gt;,Y&gt; * ,  X&gt; &gt;
00023         {
00024                 <span class="keyword">enum</span>
00025                 {
00026                         block_size = blk_sz
00027                 };      
00028         };
00029 
00030 
<a name="l00031"></a><a class="code" href="namespacestxxl_1_1stream.html">00031</a> <span class="keyword">namespace </span>stream
00032 {
00035  
00036   <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValueType,<span class="keyword">class</span> TriggerEntryType&gt;
00037   <span class="keyword">struct </span>sorted_runs
00038   {
00039     <span class="keyword">typedef</span> TriggerEntryType trigger_entry_type;
00040     <span class="keyword">typedef</span> ValueType value_type;
00041     <span class="keyword">typedef</span> <span class="keyword">typename</span> trigger_entry_type::bid_type bid_type;
00042     <span class="keyword">typedef</span> off_t size_type;
00043     <span class="keyword">typedef</span> std::vector&lt;trigger_entry_type&gt; run_type;
00044     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;bid_type::size,value_type&gt;</a> block_type;
00045     size_type elements;
00046     std::vector&lt;run_type&gt; runs;
00047     
00048     sorted_runs():elements(0) {}
00049   };
00050   
00058   <span class="keyword">template</span> &lt;  
00059                           <span class="keyword">class </span>Input_,
00060               <span class="keyword">class </span>Cmp_,
00061               <span class="keywordtype">unsigned</span> BlockSize_ = STXXL_DEFAULT_BLOCK_SIZE(<span class="keyword">typename</span> Input_::value_type),
00062               <span class="keyword">class </span>AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY&gt;
<a name="l00063"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">00063</a>   <span class="keyword">class </span><a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a>
00064   {
00065     <span class="keyword">typedef</span> <span class="keyword">typename</span> Input_::value_type value_type;
00066     <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1BID.html">BID&lt;BlockSize_&gt;</a> <a class="code" href="structstxxl_1_1BID.html">bid_type</a>;
00067     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">typed_block&lt;BlockSize_,value_type&gt;</a> <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>;
00068     <span class="keyword">typedef</span> sort_local::trigger_entry&lt;bid_type,value_type&gt; trigger_entry_type;
00069     Input_ &amp; input;
00070     Cmp_ cmp;
00071   <span class="keyword">public</span>:
00072     <span class="keyword">typedef</span> sorted_runs&lt;value_type,trigger_entry_type&gt; sorted_runs_type;
00073   <span class="keyword">private</span>:
00074     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::run_type run_type;
00075     sorted_runs_type result_; <span class="comment">// stores the result (sorted runs)</span>
00076     <span class="keywordtype">unsigned</span> m_; <span class="comment">// memory for internal use in blocks</span>
00077     <span class="keywordtype">bool</span> result_computed; <span class="comment">// true result is already computed (used in 'result' method)</span>
00078     
00079     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a>();<span class="comment">// default construction is forbidden</span>
00080     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a> &amp; );<span class="comment">// copy construction is forbidden</span>
00081     
00082     
00083     <span class="keywordtype">void</span> compute_result();
00084     <span class="keywordtype">void</span> sort_run(<a class="code" href="classstxxl_1_1typed__block.html">block_type</a> * run,<span class="keywordtype">unsigned</span> elements)
00085     {
00086       <span class="keywordflow">if</span>(block_type::has_filler)
00087         <a class="code" href="group__stlalgo.html#a12">std::sort</a>(
00088                   TwoToOneDimArrayRowAdaptor&lt; 
00089                     <a class="code" href="classstxxl_1_1typed__block.html">block_type</a>,
00090                     value_type,
00091                     block_type::size &gt; (run,0 ),
00092                   TwoToOneDimArrayRowAdaptor&lt; 
00093                     block_type,
00094                     value_type,
00095                     block_type::size &gt; (run, 
00096                       elements )
00097                   ,cmp);
00098       <span class="keywordflow">else</span> 
00099         <a class="code" href="group__stlalgo.html#a12">std::sort</a>(run[0].elem, run[0].elem + elements, cmp);
00100     }
00101   <span class="keyword">public</span>:
<a name="l00106"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator.html#a0">00106</a>     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator</a>(Input_ &amp; i,Cmp_ c,<span class="keywordtype">unsigned</span> memory_to_use):
00107       input(i),cmp(c),m_(memory_to_use/BlockSize_),result_computed(false)
00108     {
00109     }
00110     
<a name="l00114"></a><a class="code" href="classstxxl_1_1stream_1_1runs__creator.html#a1">00114</a>     <span class="keyword">const</span> sorted_runs_type &amp; result()
00115     {
00116       <span class="keywordflow">if</span>(!result_computed)
00117       {
00118         compute_result();
00119         result_computed = <span class="keyword">true</span>;
00120       }
00121       <span class="keywordflow">return</span> result_;
00122     }
00123   };
00124   
00125  
00126   <span class="keyword">template</span> &lt;<span class="keyword">class</span> Input_,<span class="keyword">class</span> Cmp_,<span class="keywordtype">unsigned</span> BlockSize_,<span class="keyword">class</span> AllocStr_&gt;
00127   <span class="keywordtype">void</span> runs_creator&lt;Input_,Cmp_,BlockSize_,AllocStr_&gt;::compute_result()
00128   {
00129     <span class="keywordtype">unsigned</span> i = 0;
00130     <span class="keywordtype">unsigned</span> m2 = m_ / 2;
00131     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> el_in_run = m2* block_type::size; <span class="comment">// # el in a run</span>
00132     <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * bm = block_manager::get_instance();
00133     block_type *Blocks1 = <span class="keyword">new</span> block_type[m2*2];
00134     block_type *Blocks2 = Blocks1 + m2;
00135     <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a> * write_reqs = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1request__ptr.html">request_ptr</a>[m2];
00136     run_type run;
00137     
00138     <span class="keywordtype">unsigned</span> pos = 0;
00139     <span class="keywordflow">while</span>(!input.empty() &amp;&amp; pos != el_in_run)
00140     {
00141       Blocks1[pos/block_type::size][pos%block_type::size] = *input;
00142       ++input;
00143       ++pos;
00144     }
00145     
00146     <span class="comment">// sort first run</span>
00147     sort_run(Blocks1,pos);
00148     result_.elements = pos;
00149     <span class="keywordtype">unsigned</span> cur_run_size = div_and_round_up(pos,block_type::size); <span class="comment">// in blocks</span>
00150     run.resize(cur_run_size);
00151     bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(AllocStr_(),
00152       trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.begin()),
00153       trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.end())
00154     );
00155     
00156     disk_queues::get_instance ()-&gt;set_priority_op(disk_queue::WRITE);
00157     
00158     <span class="comment">// fill the rest of the last block with max values</span>
00159     <span class="keywordflow">for</span>(;pos!=el_in_run;++pos)
00160         Blocks1[pos/block_type::size][pos%block_type::size] = cmp.max_value();
00161     
00162     <span class="keywordflow">for</span> (i = 0; i &lt; cur_run_size; ++i)
00163     {
00164         run[i].value = Blocks1[i][0];
00165         write_reqs[i] = Blocks1[i].write(run[i].bid);
00166         <span class="comment">//STXXL_MSG("BID: "&lt;&lt;run[i].bid&lt;&lt;" val: "&lt;&lt;run[i].value)</span>
00167     }
00168     result_.runs.push_back(run);
00169     
00170     <span class="keywordflow">if</span>(input.empty())
00171     {
00172       <span class="comment">// return</span>
00173       <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs,write_reqs + cur_run_size);
00174       <span class="keyword">delete</span> [] write_reqs;
00175       <span class="keyword">delete</span> [] Blocks1;
00176       <span class="keywordflow">return</span>;
00177     }
00178       
00179     pos = 0;
00180     <span class="keywordflow">while</span>(!input.empty() &amp;&amp; pos != el_in_run)
00181     {
00182       Blocks2[pos/block_type::size][pos%block_type::size] = *input;
00183       ++input;
00184       ++pos;
00185     }
00186     result_.elements += pos;
00187     
00188     <span class="keywordflow">if</span>(input.empty())
00189     {
00190       <span class="comment">// (re)sort internally and return</span>
00191       pos += el_in_run;
00192       sort_run(Blocks1,pos); <span class="comment">// sort first an second run together</span>
00193       <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs,write_reqs + cur_run_size);
00194       bm-&gt;<a class="code" href="group__mnglayer.html#a17">delete_blocks</a>(trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.begin()),
00195         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.end()) );
00196       
00197       cur_run_size = div_and_round_up(pos,block_type::size);
00198       run.resize(cur_run_size);
00199       bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(AllocStr_(),
00200         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.begin()),
00201         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.end())
00202       );
00203       
00204       <span class="comment">// fill the rest of the last block with max values</span>
00205       <span class="keywordflow">for</span>(;pos!=2*el_in_run;++pos)
00206         Blocks1[pos/block_type::size][pos%block_type::size] = cmp.max_value();
00207       
00208       <span class="keywordflow">for</span> (i = 0; i &lt; cur_run_size; ++i)
00209       {
00210         run[i].value = Blocks1[i][0];
00211         write_reqs[i]-&gt;wait();
00212         write_reqs[i] = Blocks1[i].write(run[i].bid);
00213       }
00214       result_.runs[0] = run;
00215       
00216       <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs,write_reqs+cur_run_size);
00217       <span class="keyword">delete</span> [] write_reqs;
00218       <span class="keyword">delete</span> [] Blocks1;
00219       
00220       <span class="keywordflow">return</span>;
00221     }
00222     
00223     sort_run(Blocks2,pos);
00224     
00225     cur_run_size = div_and_round_up(pos,block_type::size); <span class="comment">// in blocks</span>
00226     run.resize(cur_run_size);
00227     bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(AllocStr_(),
00228       trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.begin()),
00229       trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.end())
00230     );
00231     
00232     <span class="keywordflow">for</span>(i = 0; i &lt; cur_run_size; ++i)
00233     {
00234         run[i].value = Blocks2[i][0];
00235         write_reqs[i]-&gt;wait();
00236         write_reqs[i] = Blocks2[i].write(run[i].bid);
00237     }
00238     result_.runs.push_back(run);
00239     
00240     <span class="keywordflow">while</span>(!input.empty())
00241     {
00242       pos = 0;
00243       <span class="keywordflow">while</span>(!input.empty() &amp;&amp; pos != el_in_run)
00244       {
00245         Blocks1[pos/block_type::size][pos%block_type::size] = *input;
00246         ++input;
00247         ++pos;
00248       }
00249       result_.elements += pos;
00250       sort_run(Blocks1,pos);
00251       cur_run_size = div_and_round_up(pos,block_type::size); <span class="comment">// in blocks</span>
00252       run.resize(cur_run_size);
00253       bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>(AllocStr_(),
00254         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.begin()),
00255         trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(run.end())
00256       );
00257       
00258       <span class="comment">// fill the rest of the last block with max values (occurs only on the last run)</span>
00259       <span class="keywordflow">for</span>(;pos!=el_in_run;++pos)
00260         Blocks1[pos/block_type::size][pos%block_type::size] = cmp.max_value();
00261       
00262       <span class="keywordflow">for</span>(i = 0; i &lt; cur_run_size; ++i)
00263       {
00264         run[i].value = Blocks1[i][0];
00265         write_reqs[i]-&gt;wait();
00266         write_reqs[i] = Blocks1[i].write(run[i].bid);
00267       }
00268       result_.runs.push_back(run);
00269       std::swap(Blocks1,Blocks2);
00270     }
00271     
00272     <a class="code" href="group__iolayer.html#a3">wait_all</a>(write_reqs,write_reqs+m2);
00273     <span class="keyword">delete</span> [] write_reqs;
00274     <span class="keyword">delete</span> [] ((Blocks1&lt;Blocks2)?Blocks1:Blocks2);
00275     
00276   }
00277   
00278   <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValueType_&gt;
00279   <span class="keyword">struct </span>use_push
00280   {
00281                 <span class="keyword">typedef</span> ValueType_ value_type;
00282   };
00283   
00284   
00289   <span class="keyword">template</span> &lt;<span class="keyword">class</span> RunsType_, <span class="keyword">class</span> Cmp_&gt;
<a name="l00290"></a><a class="code" href="group__streampack.html#a0">00290</a>   <span class="keywordtype">bool</span> <a class="code" href="group__streampack.html#a0">check_sorted_runs</a>(RunsType_ &amp; sruns, Cmp_ cmp)
00291   {
00292     <span class="keyword">typedef</span> <span class="keyword">typename</span> RunsType_::block_type block_type;
00293     <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::value_type value_type;
00294     STXXL_VERBOSE2(<span class="stringliteral">"Elements: "</span>&lt;&lt;sruns.elements)
00295     <span class="keywordtype">unsigned</span> nruns = sruns.runs.size();
00296     STXXL_VERBOSE2(<span class="stringliteral">"Runs: "</span>&lt;&lt;nruns)
00297     <span class="keywordtype">unsigned</span> irun=0;
00298     <span class="keywordflow">for</span>(irun = 0;irun&lt;nruns;++irun)
00299     {
00300        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nblocks = sruns.runs[irun].size();
00301        block_type * blocks = <span class="keyword">new</span> block_type[nblocks];
00302        request_ptr * reqs = <span class="keyword">new</span> request_ptr[nblocks];
00303        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;nblocks;++j)
00304        {
00305          reqs[j] = blocks[j].read(sruns.runs[irun][j].bid);
00306        }
00307        <a class="code" href="group__iolayer.html#a3">wait_all</a>(reqs,reqs + nblocks);
00308        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;nblocks;++j)
00309        {
00310          <span class="keywordflow">if</span>(blocks[j][0] != sruns.runs[irun][j].value)
00311            <span class="keywordflow">return</span> <span class="keyword">false</span>;
00312        }
00313        <span class="keywordflow">if</span>(!is_sorted(
00314                   TwoToOneDimArrayRowAdaptor&lt; 
00315                     block_type,
00316                     value_type,
00317                     block_type::size &gt; (blocks,0 ),
00318                   TwoToOneDimArrayRowAdaptor&lt; 
00319                     block_type,
00320                     value_type,
00321                     block_type::size &gt; (blocks, 
00322                        <span class="comment">//nblocks*block_type::size</span>
00323                       (irun&lt;nruns-1)?(nblocks*block_type::size): (sruns.elements%(nblocks*block_type::size))
00324                   ),cmp) )
00325            <span class="keywordflow">return</span> <span class="keyword">false</span>;
00326        
00327        <span class="keyword">delete</span> [] reqs;
00328        <span class="keyword">delete</span> [] blocks;
00329     }
00330 
00331     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00332   }
00333   
00341   <span class="keyword">template</span> &lt;  <span class="keyword">class </span>RunsType_,
00342               <span class="keyword">class </span>Cmp_,
00343               <span class="keyword">class </span>AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY &gt;
<a name="l00344"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">00344</a>   <span class="keyword">class </span><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger</a>
00345   {
00346     <span class="keyword">typedef</span> RunsType_ sorted_runs_type;
00347     <span class="keyword">typedef</span> AllocStr_ alloc_strategy;
00348     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::size_type size_type;
00349     <span class="keyword">typedef</span> Cmp_ value_cmp;
00350     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::run_type run_type;
00351     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::block_type block_type;
00352     <span class="keyword">typedef</span> <span class="keyword">typename</span> block_type::bid_type bid_type;
00353     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1block__prefetcher.html">block_prefetcher&lt;block_type,typename run_type::iterator&gt;</a> <a class="code" href="classstxxl_1_1block__prefetcher.html">prefetcher_type</a>;
00354     <span class="keyword">typedef</span> run_cursor2&lt;block_type,prefetcher_type&gt; run_cursor_type;
00355     <span class="keyword">typedef</span> sort_local::run_cursor2_cmp&lt;block_type,prefetcher_type,value_cmp&gt; run_cursor2_cmp_type;
00356     <span class="keyword">typedef</span> looser_tree&lt;run_cursor_type,run_cursor2_cmp_type,block_type::size&gt; looser_tree_type;
00357     
00358     sorted_runs_type sruns;
00359     <span class="keywordtype">unsigned</span> m_; <span class="comment">//  blocks to use - 1</span>
00360     value_cmp cmp;
00361     size_type elements_remaining;
00362     <span class="keywordtype">unsigned</span> buffer_pos;
00363     block_type current_block;
00364     run_type consume_seq;
00365     <a class="code" href="classstxxl_1_1block__prefetcher.html">prefetcher_type</a> * prefetcher;
00366     looser_tree_type * loosers;
00367     <span class="keywordtype">int</span> * prefetch_seq;
00368     
00369     <span class="keywordtype">void</span> merge_recursively();
00370     
00371     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a0">runs_merger</a>(); <span class="comment">// forbidden</span>
00372     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a0">runs_merger</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger</a> &amp;); <span class="comment">// forbidden</span>
00373   <span class="keyword">public</span>:
<a name="l00375"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#w0">00375</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> sorted_runs_type::value_type <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#w0">value_type</a>;
00376     
<a name="l00381"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a0">00381</a>     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a0">runs_merger</a>(<span class="keyword">const</span> sorted_runs_type &amp; r,value_cmp c,<span class="keywordtype">unsigned</span> memory_to_use):
00382       sruns(r),m_(memory_to_use/block_type::raw_size <span class="comment">/* - 1 */</span>),cmp(c),
00383       elements_remaining(r.elements)
00384     {
00385       disk_queues::get_instance ()-&gt;set_priority_op (disk_queue::WRITE);
00386       
00387       <span class="keywordtype">unsigned</span> nruns = sruns.runs.size();
00388       
00389       <span class="keywordflow">if</span>(m_ &lt; nruns)
00390       {
00391         <span class="comment">// can not merge runs in one pass</span>
00392         <span class="comment">// merge recursively:</span>
00393         STXXL_ERRMSG(<span class="stringliteral">"An implementation requires more than one merge pass, therefore for"</span>)
00394         STXXL_ERRMSG(<span class="stringliteral">"efficiency decrease block size of run storage (a parameter of the run_creator)"</span>)
00395         STXXL_ERRMSG(<span class="stringliteral">"or increase the ammount memory dedicated to the merger."</span>)
00396         STXXL_ERRMSG(<span class="stringliteral">"m = "</span>&lt;&lt; m_&lt;&lt;<span class="stringliteral">" nruns="</span>&lt;&lt;nruns)
00397         
00398         merge_recursively();
00399         
00400         nruns = sruns.runs.size();
00401       }
00402       
00403       assert(nruns &lt;= m_);
00404       
00405       <span class="keywordtype">unsigned</span> i;
00406       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> out_run_size = div_and_round_up(elements_remaining,size_type(block_type::size));
00407       consume_seq.resize(out_run_size);
00408     
00409       prefetch_seq = <span class="keyword">new</span> <span class="keywordtype">int</span>[out_run_size];
00410       
00411       <span class="keyword">typename</span> run_type::iterator copy_start = consume_seq.begin ();
00412       <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00413       {
00414         copy_start = std::copy(
00415                 sruns.runs[i].begin (),
00416                 sruns.runs[i].end (),
00417                 copy_start      );
00418       }
00419       
00420       <a class="code" href="group__stlalgo.html#a12">std::sort</a>(consume_seq.begin (), consume_seq.end (),
00421               sort_local::trigger_entry_cmp&lt;bid_type,value_type,value_cmp&gt;(cmp));
00422     
00423       <span class="keywordtype">int</span> disks_number = config::get_instance ()-&gt;disks_number ();
00424       
00425       <span class="keyword">const</span> <span class="keywordtype">int</span> n_prefetch_buffers = std::max( 2 * disks_number , (<span class="keywordtype">int</span>(m_) - <span class="keywordtype">int</span>(nruns)) );
00426     
00427 <span class="preprocessor">      #ifdef SORT_OPT_PREFETCHING</span>
00428 <span class="preprocessor"></span>      <span class="comment">// heuristic</span>
00429       <span class="keyword">const</span> <span class="keywordtype">int</span> n_opt_prefetch_buffers = 2 * disks_number + (3*(n_prefetch_buffers - 2 * disks_number))/10;
00430       
00431       compute_prefetch_schedule(
00432           consume_seq,
00433           prefetch_seq,
00434           n_opt_prefetch_buffers,
00435           disks_number );
00436 <span class="preprocessor">      #else</span>
00437 <span class="preprocessor"></span>      <span class="keywordflow">for</span>(i=0;i&lt;out_run_size;++i)
00438         prefetch_seq[i] = i;
00439 <span class="preprocessor">      #endif</span>
00440 <span class="preprocessor"></span>      
00441      
00442       prefetcher = <span class="keyword">new</span> <a class="code" href="classstxxl_1_1block__prefetcher.html">prefetcher_type</a>( consume_seq.begin(),
00443                                         consume_seq.end(),
00444                                         prefetch_seq,
00445                                         nruns + n_prefetch_buffers);
00446       
00447     
00448       loosers  =  <span class="keyword">new</span> looser_tree_type(prefetcher, nruns,run_cursor2_cmp_type(cmp));
00449       
00450       loosers-&gt;multi_merge(current_block.elem);
00451       current_value = current_block.elem[0];
00452       buffer_pos = 1;
00453     }
00454     
<a name="l00456"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">00456</a>     <span class="keywordtype">bool</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">empty</a>()<span class="keyword"> const</span>
00457 <span class="keyword">    </span>{
00458       <span class="keywordflow">return</span> elements_remaining==0;
00459     }
<a name="l00461"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a2">00461</a>     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger</a> &amp; <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a2">operator ++</a>() <span class="comment">// preincrement operator</span>
00462     {
00463       assert(!<a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">empty</a>());
00464       
00465       --elements_remaining;
00466       
00467       <span class="keywordflow">if</span>(buffer_pos != block_type::size)
00468       {
00469         current_value = current_block.elem[buffer_pos];
00470         ++buffer_pos;
00471       }
00472       <span class="keywordflow">else</span>
00473       {
00474         <span class="keywordflow">if</span>(!<a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">empty</a>())
00475         {
00476           loosers-&gt;multi_merge(current_block.elem);
00477           current_value = current_block.elem[0];  
00478           buffer_pos = 1;
00479         }
00480       }
00481       
00482       
00483       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00484     }
<a name="l00486"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a3">00486</a>     <span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#w0">value_type</a> &amp; <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a3">operator * </a>()<span class="keyword"> const</span>
00487 <span class="keyword">    </span>{
00488       assert(!<a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">empty</a>());
00489       <span class="keywordflow">return</span> current_value;
00490     }
<a name="l00493"></a><a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a4">00493</a>     <span class="keyword">virtual</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a4">~runs_merger</a>()
00494     {
00495       <span class="keyword">delete</span> loosers;
00496       <span class="keyword">delete</span> prefetcher;
00497       <span class="keyword">delete</span> [] prefetch_seq;
00498       
00499       <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * bm = block_manager::get_instance();
00500       <span class="comment">// free blocks in runs</span>
00501       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;sruns.runs.size();++i)
00502         bm-&gt;<a class="code" href="group__mnglayer.html#a17">delete_blocks</a>(
00503           trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(sruns.runs[i].begin()),
00504           trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(sruns.runs[i].end()) );
00505     }
00506   <span class="keyword">private</span>:
00507     <span class="comment">// cache for the current value</span>
00508     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#w0">value_type</a> current_value;
00509   };
00510   
00511   
00512   <span class="keyword">template</span> &lt;<span class="keyword">class</span> RunsType_,<span class="keyword">class</span> Cmp_,<span class="keyword">class</span> AllocStr_&gt;
00513   <span class="keywordtype">void</span> runs_merger&lt;RunsType_,Cmp_,AllocStr_&gt;::merge_recursively()
00514   {
00515     <a class="code" href="classstxxl_1_1block__manager.html">block_manager</a> * bm = block_manager::get_instance();
00516     <span class="keywordtype">unsigned</span> ndisks = config::get_instance ()-&gt;disks_number ();
00517     <span class="keywordtype">unsigned</span> nwrite_buffers = 2*ndisks;
00518     
00519     <span class="keywordtype">unsigned</span> nruns = sruns.runs.size();
00520     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> merge_factor = static_cast&lt;unsigned&gt;(ceil(pow(nruns,1./ceil(log(nruns)/log(m_)))));
00521     assert(merge_factor &lt;= m_);
00522     <span class="keywordflow">while</span>(nruns &gt; m_)
00523     {
00524       <span class="keywordtype">unsigned</span> new_nruns = div_and_round_up(nruns,merge_factor);
00525       STXXL_VERBOSE(<span class="stringliteral">"Starting new merge phase: nruns: "</span>&lt;&lt;nruns&lt;&lt;
00526         <span class="stringliteral">" opt_merge_factor: "</span>&lt;&lt;merge_factor&lt;&lt;<span class="stringliteral">" m:"</span>&lt;&lt;m_&lt;&lt;<span class="stringliteral">" new_nruns: "</span>&lt;&lt;new_nruns)
00527       
00528       sorted_runs_type new_runs;
00529       new_runs.runs.resize(new_nruns);
00530       new_runs.elements = sruns.elements;
00531       
00532       <span class="keywordtype">unsigned</span> runs_left = nruns;
00533       <span class="keywordtype">unsigned</span> cur_out_run = 0;
00534       <span class="keywordtype">unsigned</span> blocks_in_new_run = 0;
00535       
00536       
00537       <span class="keywordflow">while</span>(runs_left &gt; 0)
00538       {
00539         <span class="keywordtype">int</span> runs2merge = STXXL_MIN(runs_left,merge_factor);
00540         blocks_in_new_run = 0;
00541         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = nruns - runs_left; i &lt; (nruns - runs_left + runs2merge);++i)
00542           blocks_in_new_run += sruns.runs[i].size();
00543         <span class="comment">// allocate run</span>
00544         new_runs.runs[cur_out_run++].resize(blocks_in_new_run);
00545         runs_left -= runs2merge;
00546         
00547       }
00548       
00549       <span class="comment">// allocate blocks for the new runs</span>
00550       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;new_runs.runs.size();++i)
00551         bm-&gt;<a class="code" href="group__mnglayer.html#a15">new_blocks</a>( alloc_strategy(),
00552           trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(new_runs.runs[i].begin()),
00553           trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(new_runs.runs[i].end()) );
00554       
00555       <span class="comment">// merge all</span>
00556       runs_left = nruns;
00557       cur_out_run = 0;
00558       size_type elements_left = sruns.elements;
00559       
00560       <span class="keywordflow">while</span>(runs_left &gt; 0)
00561       {
00562           <span class="keywordtype">unsigned</span> runs2merge = STXXL_MIN(runs_left,merge_factor);
00563           STXXL_VERBOSE(<span class="stringliteral">"Merging "</span>&lt;&lt;runs2merge&lt;&lt;<span class="stringliteral">" runs"</span>)
00564           
00565           sorted_runs_type cur_runs;
00566           cur_runs.runs.resize(runs2merge);
00567         
00568           std::copy(sruns.runs.begin() + nruns - runs_left,
00569                     sruns.runs.begin() + nruns - runs_left + runs2merge,
00570                     cur_runs.runs.begin() );
00571         
00572           runs_left -= runs2merge;
00573           cur_runs.elements = (runs_left)? 
00574             (new_runs.runs[cur_out_run].size()*block_type::size):
00575             (elements_left);
00576           elements_left -= cur_runs.elements;
00577           
00578           <span class="keywordflow">if</span>(runs2merge &gt; 1)
00579           { 
00580             
00581             runs_merger&lt;RunsType_,Cmp_,AllocStr_&gt; merger(cur_runs,cmp,m_*block_type::raw_size);  
00582             
00583             { <span class="comment">// make sure everything is being destroyed in right time</span>
00584               
00585               buf_ostream&lt;block_type,typename run_type::iterator&gt; out(
00586                   new_runs.runs[cur_out_run].begin(),
00587                   nwrite_buffers );
00588               
00589               size_type cnt = 0;
00590               <span class="keyword">const</span> size_type cnt_max = cur_runs.elements;
00591               
00592               <span class="keywordflow">while</span>(cnt != cnt_max)
00593               {
00594                 *out = *merger;
00595                 <span class="keywordflow">if</span>( (cnt % block_type::size) == 0) <span class="comment">// have to write the trigger value</span>
00596                   new_runs.runs[cur_out_run][cnt/size_type(block_type::size)].value = *merger;
00597                 
00598                 ++cnt;
00599                 ++out;
00600                 ++merger;
00601               }
00602               assert(merger.empty());
00603               
00604               <span class="keywordflow">while</span>(cnt % block_type::size)
00605               {
00606                 *out = cmp.max_value();
00607                 ++out;
00608                 ++cnt;
00609               }
00610             } 
00611           }
00612           <span class="keywordflow">else</span>
00613           {
00614             bm-&gt;<a class="code" href="group__mnglayer.html#a17">delete_blocks</a>( 
00615               trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(
00616                   new_runs.runs.back().begin()),
00617               trigger_entry_iterator&lt;typename run_type::iterator,block_type::raw_size&gt;(
00618                   new_runs.runs.back().end()) );
00619       
00620             assert(cur_runs.runs.size() == 1);
00621             
00622             std::copy(cur_runs.runs.front().begin(),
00623                       cur_runs.runs.front().end(),
00624                       new_runs.runs.back().begin());
00625           }
00626           
00627           ++cur_out_run;
00628       }
00629       assert(elements_left == 0);
00630       
00631       nruns = new_nruns;
00632       sruns = new_runs;
00633       
00634     }
00635   }
00636   
00637   
00646   <span class="keyword">template</span> &lt;  <span class="keyword">class </span>Input_,
00647               <span class="keyword">class </span>Cmp_,
00648               <span class="keywordtype">unsigned</span> BlockSize_ = STXXL_DEFAULT_BLOCK_SIZE(<span class="keyword">typename</span> Input_::value_type),
00649               <span class="keyword">class </span>AllocStr_ = STXXL_DEFAULT_ALLOC_STRATEGY&gt;
<a name="l00650"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html">00650</a>   <span class="keyword">class </span><a class="code" href="classstxxl_1_1stream_1_1sort.html">sort</a>
00651   {
00652     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator&lt;Input_,Cmp_,BlockSize_,AllocStr_&gt;</a> <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator_type</a>;
00653     <span class="keyword">typedef</span> <span class="keyword">typename</span> runs_creator_type::sorted_runs_type sorted_runs_type;
00654     <span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger&lt;sorted_runs_type,Cmp_,AllocStr_&gt;</a> <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger_type</a>;
00655     
00656     <a class="code" href="classstxxl_1_1stream_1_1runs__creator.html">runs_creator_type</a> creator;
00657     <a class="code" href="classstxxl_1_1stream_1_1runs__merger.html">runs_merger_type</a> merger;
00658     
00659     <a class="code" href="classstxxl_1_1stream_1_1sort.html#a0">sort</a>(); <span class="comment">// forbidden</span>
00660     <a class="code" href="classstxxl_1_1stream_1_1sort.html#a0">sort</a>(<span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1sort.html">sort</a> &amp;); <span class="comment">// forbidden</span>
00661   <span class="keyword">public</span>:
<a name="l00663"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html#w0">00663</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Input_::value_type <a class="code" href="classstxxl_1_1stream_1_1sort.html#w0">value_type</a>;
00664    
<a name="l00669"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html#a0">00669</a>     <a class="code" href="classstxxl_1_1stream_1_1sort.html#a0">sort</a>(Input_ &amp; in,Cmp_ c,<span class="keywordtype">unsigned</span> memory_to_use):
00670       creator(in,c,memory_to_use),
00671       merger(creator.result(),c,memory_to_use) {}
00672         
<a name="l00674"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html#a1">00674</a>     <span class="keyword">const</span> <a class="code" href="classstxxl_1_1stream_1_1sort.html#w0">value_type</a> &amp; <a class="code" href="classstxxl_1_1stream_1_1sort.html#a1">operator * </a>()<span class="keyword"> const</span>
00675 <span class="keyword">    </span>{
00676       <span class="keywordflow">return</span> *merger;
00677     }
00678     
<a name="l00680"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html#a2">00680</a>     <a class="code" href="classstxxl_1_1stream_1_1sort.html">sort</a> &amp; <a class="code" href="classstxxl_1_1stream_1_1sort.html#a2">operator ++</a>()
00681     {
00682       ++merger;
00683       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00684     }
00685     
<a name="l00687"></a><a class="code" href="classstxxl_1_1stream_1_1sort.html#a3">00687</a>     <span class="keywordtype">bool</span> <a class="code" href="classstxxl_1_1stream_1_1sort.html#a3">empty</a>()<span class="keyword"> const</span>
00688 <span class="keyword">    </span>{
00689       <span class="keywordflow">return</span> merger.<a class="code" href="classstxxl_1_1stream_1_1runs__merger.html#a1">empty</a>();
00690     }
00691     
00692   };
00693     
00694   
00696   
00697 };
00698 
00699 
00700 
00701 __STXXL_END_NAMESPACE
00702 
00703 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Nov 21 15:28:12 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
