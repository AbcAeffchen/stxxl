<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: Example Documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>stream/test_stream.cpp</h1>This is an example of how to use some basic algorithms from stream package. The example sorts characters of a string producing array of sorted tuples (character,index position). <div class="fragment"><pre> <span class="comment">/***************************************************************************</span>
<span class="comment"> *            test_stream.cpp</span>
<span class="comment"> *</span>
<span class="comment"> *  Fri Oct 5  13:40:22 2003</span>
<span class="comment"> *  Copyright  2003  Roman Dementiev</span>
<span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
<span class="comment"> ****************************************************************************/</span>
<span class="preprocessor">#include "stream.h"</span>
<span class="preprocessor">#include "../containers/vector.h"</span>
<span class="preprocessor">#include &lt;vector&gt;</span>


<span class="preprocessor">#define USE_FORMRUNS_N_MERGE // comment if you want to use one 'sort' algorithm</span>
<span class="preprocessor"></span>                             <span class="comment">// without producing intermediate sorted runs.</span>

<span class="preprocessor">#define USE_EXTERNAL_ARRAY // comment if you want to use internal vectors as</span>
<span class="preprocessor"></span>                           <span class="comment">// input/output of the algorithm</span>

<span class="keyword">typedef</span> <a name="_a15"></a><a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple&lt;char,int&gt;</a> <a class="code" href="structstxxl_1_1tuple.html">tuple_type</a>;

<span class="preprocessor">#ifdef USE_EXTERNAL_ARRAY</span>
<span class="preprocessor"></span>  <span class="keyword">typedef</span> <a name="_a16"></a><a class="code" href="structstxxl_1_1VECTOR__GENERATOR.html">stxxl::VECTOR_GENERATOR&lt;char&gt;</a>::result <a class="code" href="structstxxl_1_1VECTOR__GENERATOR.html">input_array_type</a>;
  <span class="keyword">typedef</span> <a class="code" href="structstxxl_1_1VECTOR__GENERATOR.html">stxxl::VECTOR_GENERATOR&lt;tuple_type&gt;</a>::result <a class="code" href="structstxxl_1_1VECTOR__GENERATOR.html">output_array_type</a>;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  <span class="keyword">typedef</span> std::vector&lt;char&gt; input_array_type;
  <span class="keyword">typedef</span> std::vector&lt;tuple_type&gt; output_array_type;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">using</span> <span class="keyword">namespace </span>stxxl;
<span class="keyword">using</span> stxxl::stream::streamify;
<span class="keyword">using</span> <a name="_a17"></a><a class="code" href="classstxxl_1_1stream_1_1make__tuple.html">stxxl::stream::make_tuple</a>;
<span class="keyword">using</span> <a class="code" href="structstxxl_1_1tuple.html">stxxl::tuple</a>;


<span class="keyword">const</span> <span class="keywordtype">char</span> * phrase = <span class="stringliteral">"Astalavista, baby"</span>;


<span class="keyword">template</span> &lt;<span class="keyword">class</span> Container_,<span class="keyword">class</span> It_&gt;
<span class="keywordtype">void</span> fill_input_array(Container_ &amp; container,It_ p)
{
  <span class="keywordflow">while</span>(*p)
  {
    container.push_back(*p);
    ++p;
  }
}

<span class="keyword">template</span> &lt;<span class="keyword">class</span> ValTp&gt;
<span class="keyword">struct </span>counter
{
  <span class="keyword">typedef</span> ValTp value_type;
  
  value_type cnt;
  counter(): cnt(0) {}
  
  value_type operator() ()
  {
     value_type ret = cnt;
     ++cnt;
     <span class="keywordflow">return</span> ret;
  }
};

<span class="keyword">typedef</span> counter&lt;int&gt; counter_type;

<span class="keyword">struct </span>cmp_type
{
  <span class="keyword">typedef</span> tuple_type value_type;
  <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> value_type &amp; a, <span class="keyword">const</span> value_type &amp; b)<span class="keyword"> const</span>
<span class="keyword">  </span>{
    <span class="keywordflow">return</span> a.first &lt; b.first;
  }
  
  value_type min_value()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> value_type(std::numeric_limits&lt;char&gt;::min(),0); }
  value_type max_value()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> value_type(std::numeric_limits&lt;char&gt;::max(),0); }
};

<span class="keywordtype">int</span> main()
{
  input_array_type input;
  output_array_type output;
  
  fill_input_array(input,phrase);
  
  output.resize(input.size());
  
  <span class="comment">// HERE streaming part begins (streamifying)</span>
  <span class="comment">// create input stream</span>
  <span class="keyword">typedef</span> typeof(<a name="a18"></a><a class="code" href="group__streampack.html#a3">streamify</a>(input.begin(),input.end())) input_stream_type;
  input_stream_type input_stream = <a class="code" href="group__streampack.html#a3">streamify</a>(input.begin(),input.end());
  
  <span class="comment">// create counter stream</span>
  <span class="keyword">typedef</span> typeof(<a class="code" href="group__streampack.html#a3">streamify</a>(counter_type())) counter_stream_type;
  counter_stream_type counter_stream = <a class="code" href="group__streampack.html#a3">streamify</a>(counter_type());
  
  <span class="comment">// create tuple stream</span>
  <span class="keyword">typedef</span> make_tuple&lt;input_stream_type,counter_stream_type&gt; tuple1_stream_type;
  tuple1_stream_type tuples1_stream(input_stream,counter_stream);
  
<span class="preprocessor">  #ifdef USE_FORMRUNS_N_MERGE</span>
<span class="preprocessor"></span>  <span class="comment">// sort tuples by character </span>
  <span class="comment">// 1. form runs</span>
  <span class="keyword">typedef</span> stream::runs_creator&lt;tuple1_stream_type,cmp_type,4096&gt; run_creator_type;
  run_creator_type runscreator(tuples1_stream,cmp_type(),128*1024);
  <span class="comment">// 2. merge runs</span>
  <span class="keyword">typedef</span> stream::runs_merger&lt;run_creator_type::sorted_runs_type,cmp_type&gt; runs_merger_type;
  runs_merger_type sorted_stream(runscreator.result(),cmp_type(),128*1024);
<span class="preprocessor">  #else</span>
<span class="preprocessor"></span>  <span class="comment">// sort tuples by character </span>
  <span class="comment">// (combination of the previous two steps in one algorithm: form runs and merge)</span>
  <span class="keyword">typedef</span> stream::sort&lt;tuple1_stream_type,cmp_type,4096&gt; sorted_stream_type;
  sorted_stream_type sorted_stream(tuples1_stream,cmp_type(),128*1024);
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  <span class="comment">// HERE streaming part ends (materializing)</span>
  <a name="a19"></a><a class="code" href="group__streampack.html#a2">materialize</a>(sorted_stream,output.begin());
  
  
  STXXL_MSG(<span class="stringliteral">"input string (character,position) :"</span>)
  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0;i&lt;input.size();++i)
  {
    STXXL_MSG(<span class="stringliteral">"('"</span>&lt;&lt;input[i] &lt;&lt; <span class="stringliteral">"',"</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">")"</span>)
  }
  STXXL_MSG(<span class="stringliteral">"sorted tuples (character,position):"</span>)
  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0;i&lt;input.size();++i)
  {
    STXXL_MSG(<span class="stringliteral">"('"</span>&lt;&lt;output[i].first&lt;&lt;<span class="stringliteral">"',"</span>&lt;&lt;output[i].second&lt;&lt;<span class="stringliteral">")"</span>)
  }
  
}
</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Fri Nov 21 15:28:10 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
