<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;stxxl&gt;: ksort_exp.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>ksort_exp.h</h1><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef KSORT_HEADER</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define KSORT_HEADER</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">/***************************************************************************</span>
00005 <span class="comment"> *            ksort.h</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  Fri Oct  4 19:18:04 2002</span>
00008 <span class="comment"> *  Copyright  2002  Roman Dementiev</span>
00009 <span class="comment"> *  dementiev@mpi-sb.mpg.de</span>
00010 <span class="comment"> ****************************************************************************/</span>
00011 
00012 <span class="preprocessor">#include "../mng/mng.h"</span>
00013 <span class="preprocessor">#include "../common/rand.h"</span>
00014 <span class="preprocessor">#include "../mng/adaptor.h"</span>
00015 <span class="preprocessor">#include "../common/simple_vector.h"</span>
00016 <span class="preprocessor">#include "../common/switch.h"</span>
00017 <span class="preprocessor">#include "interleaved_alloc.h"</span>
00018 <span class="preprocessor">#include "intksort.h"</span>
00019 <span class="preprocessor">#include "adaptor.h"</span>
00020 <span class="preprocessor">#include &lt;list&gt;</span>
00021 <span class="preprocessor">#include "async_schedule.h"</span>
00022 
00023 <span class="comment">//#define SORT_OPT_PREFETCHING</span>
00024 <span class="comment">//#define INTERLEAVED_ALLOC</span>
00025 
00026 
00027 __STXXL_BEGIN_NAMESPACE
00028 
00029 
00030 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _BIDTp,<span class="keyword">typename</span> _KeyTp&gt;
00031 <span class="keyword">struct </span>trigger_entry
00032 {
00033         <span class="keyword">typedef</span> _BIDTp bid_type;
00034         <span class="keyword">typedef</span> _KeyTp key_type;
00035 
00036         bid_type bid;
00037         key_type key;
00038         
00039         operator bid_type ()
00040         {
00041                 <span class="keywordflow">return</span> bid;
00042         };
00043 };
00044 
00045 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _BIDTp,<span class="keyword">typename</span> _KeyTp&gt;
00046 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &lt; (const trigger_entry&lt;_BIDTp,_KeyTp&gt; &amp; a, 
00047                                                                                                 <span class="keyword">const</span> trigger_entry&lt;_BIDTp,_KeyTp&gt; &amp; b)
00048 {
00049         <span class="keywordflow">return</span> (a.key &lt; b.key);
00050 };
00051 
00052 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _BIDTp,<span class="keyword">typename</span> _KeyTp&gt;
00053 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator &gt; (<span class="keyword">const</span> trigger_entry&lt;_BIDTp,_KeyTp&gt; &amp; a,
00054                                                                                                 <span class="keyword">const</span> trigger_entry&lt;_BIDTp,_KeyTp&gt; &amp; b)
00055 {
00056         <span class="keywordflow">return</span> (a.key &gt; b.key);
00057 };
00058 
00059 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type, <span class="keyword">typename</span> key_type&gt;
00060 <span class="keyword">struct </span>type_key
00061 {
00062         key_type key;
00063         type * ptr;
00064         
00065         type_key() {};
00066         type_key(<span class="keyword">typename</span> key_type k, type * p): key(k), ptr (p) { };
00067 };
00068 
00069 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00070 <span class="keywordtype">bool</span> operator  &lt; (const type_key&lt;type&gt; &amp; a, <span class="keyword">const</span> type_key&lt;type&gt; &amp; b)
00071 {
00072                 <span class="keywordflow">return</span> a.key &lt; b.key;
00073 }
00074 
00075 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;
00076 <span class="keywordtype">bool</span> operator  &gt; (<span class="keyword">const</span> type_key&lt;type&gt; &amp; a, <span class="keyword">const</span> type_key&lt;type&gt; &amp; b)
00077 {
00078                 <span class="keywordflow">return</span> a.key &gt; b.key;
00079 }
00080 
00081 
00082 
00083 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> block_type,<span class="keyword">typename</span> bid_type&gt;
00084 <span class="keyword">struct </span>write_completion_handler: <span class="keyword">public</span> generic_completion_handler
00085 {
00086         block_type * block;
00087         bid_type bid;
00088         request ** req;
00089         <span class="keywordtype">void</span> operator () (request * completed_req)
00090         {
00091                 block-&gt;read(bid,*req); 
00092         }
00093 };
00094 
00095 
00096 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type,<span class="keyword">typename</span> type_key, <span class="keyword">typename</span> key_extractor&gt;
00097 <span class="keywordtype">void</span> classify_block(type * begin,type * end,type_key * &amp; out,<span class="keywordtype">int</span> * bucket,
00098         <span class="keywordtype">unsigned</span> offset, <span class="keywordtype">unsigned</span> shift,key_extractor keyobj)
00099 {
00100         <span class="keywordflow">for</span> (type * p = begin;p&lt;end; p++,out++) <span class="comment">// count &amp; create references</span>
00101         {
00102                 out-&gt;ptr = p;
00103                 <span class="keyword">typename</span> key_extractor::key_type key = keyobj(*p);
00104                 <span class="keywordtype">int</span> ibucket = (key - offset) &gt;&gt; shift;
00105                 out-&gt;key = key;
00106                 bucket[ibucket]++;
00107         }
00108 }
00109 
00110 
00111 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type,
00112                                         <span class="keyword">typename</span> type_key,
00113                                         <span class="keyword">typename</span> block_type,
00114                                         <span class="keyword">typename</span> bid_type,
00115                                         <span class="keyword">typename</span> run_type,
00116                                         <span class="keyword">typename</span> input_bid_iterator,
00117                                         <span class="keyword">typename</span> key_extractor&gt;
00118 <span class="keyword">inline</span> <span class="keywordtype">void</span> write_out(
00119                                         type_key *begin,
00120                                         type_key * end,
00121                                         block_type *&amp; cur_blk,
00122                                         <span class="keyword">const</span> block_type * end_blk,
00123                                         <span class="keywordtype">int</span> &amp; out_block,
00124                                         <span class="keywordtype">int</span> &amp; out_pos,
00125                                         run_type &amp; run,
00126                                         write_completion_handler&lt;block_type,bid_type&gt; *&amp; next_read,
00127                                         request ** write_reqs,
00128                                         request ** read_reqs,
00129                                         input_bid_iterator &amp; it,
00130                                         key_extractor keyobj)
00131 {                       
00132         
00133         block_manager *bm = block_manager::get_instance ();
00134         type * elem = cur_blk-&gt;elem;
00135         <span class="keywordflow">for</span> (type_key * p = begin; p &lt; end; p++)
00136         {
00137                 elem[out_pos++] = *(p-&gt;ptr);
00138                 
00139                 <span class="keywordflow">if</span> (out_pos &gt;= block_type::size)
00140                 {
00141                         run[out_block].key = keyobj(*(cur_blk-&gt;elem));
00142                         
00143                         <span class="keywordflow">if</span> (cur_blk &lt; end_blk)
00144                         {
00145                                         next_read-&gt;block = cur_blk;
00146                                         next_read-&gt;req = read_reqs + out_block;
00147                                         read_reqs[out_block] = NULL;
00148                                         bm-&gt;delete_block( next_read-&gt;bid = *(it++) );
00149                                                                                                                                                                                                                                                                 
00150                                         cur_blk-&gt;write (        
00151                                                         run[out_block].bid, 
00152                                                         write_reqs[out_block],
00153                                                                           <span class="comment">// queue read of block from next run</span>
00154                                                         *(next_read++));  <span class="comment">// after write of block from this run</span>
00155                                         
00156                         }
00157                         <span class="keywordflow">else</span>
00158                         {
00159                                 cur_blk-&gt;write (run[out_block].bid, write_reqs[out_block]);
00160                         }
00161                                                                                 
00162                         cur_blk++;
00163                         elem = cur_blk-&gt;elem;
00164                         out_block++;
00165                         out_pos = 0;
00166                 }
00167         }
00168 }
00169 
00170 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type,
00171                                         <span class="keyword">typename</span> type_key,
00172                                         <span class="keyword">typename</span> block_type,
00173                                         <span class="keyword">typename</span> bid_type,
00174                                         <span class="keyword">typename</span> run_type,
00175                                         <span class="keyword">typename</span> input_bid_iterator&gt;
00176 <span class="keywordtype">void</span>
00177 create_runs(
00178                 input_bid_iterator it,
00179                 run_type ** runs,
00180                 <span class="keywordtype">int</span> nruns,
00181                 <span class="keywordtype">int</span> _m )
00182 {
00183         <span class="keyword">const</span> <span class="keywordtype">int</span> m2 = _m / 2;
00184         block_manager *bm = block_manager::get_instance ();
00185         block_type *Blocks1 = <span class="keyword">new</span> block_type[m2];
00186         block_type *Blocks2 = <span class="keyword">new</span> block_type[m2];
00187         type_key *refs1 = <span class="keyword">new</span> type_key[m2 * Blocks1-&gt;size];
00188         type_key *refs2 = <span class="keyword">new</span> type_key[m2 * Blocks1-&gt;size];
00189         request **read_reqs = <span class="keyword">new</span> request *[m2];
00190         request **write_reqs = <span class="keyword">new</span> request *[m2];
00191         write_completion_handler&lt;block_type,bid_type&gt; * next_run_reads = 
00192                 <span class="keyword">new</span> write_completion_handler&lt;block_type,bid_type&gt;[m2];
00193         
00194         <span class="keyword">const</span> <span class="keywordtype">int</span> offset = 0;
00195         <span class="keyword">const</span> <span class="keywordtype">int</span> log_k1 = 10;
00196         <span class="keyword">const</span> <span class="keywordtype">int</span> log_k2 = int(log2 (m2 * Blocks1-&gt;size)) - log_k1 - 1;
00197         <span class="keyword">const</span> <span class="keywordtype">int</span> k1 = 1 &lt;&lt; log_k1;
00198         <span class="keyword">const</span> <span class="keywordtype">int</span> k2 = 1 &lt;&lt; log_k2;
00199         <span class="keywordtype">int</span> *bucket1 = <span class="keyword">new</span> <span class="keywordtype">int</span>[k1];
00200         <span class="keywordtype">int</span> *bucket2 = <span class="keyword">new</span> <span class="keywordtype">int</span>[k2];
00201         <span class="keywordtype">int</span> i;
00202         
00203         run_type *run;
00204 
00205         disk_queues::get_instance ()-&gt;set_priority_op (disk_queue::WRITE);
00206 
00207         run = *runs;
00208         <span class="keywordtype">int</span> run_size = (*runs)-&gt;size ();
00209         
00210         <span class="keywordflow">for</span> (i = 0; i &lt; run_size; i++)
00211         {
00212                 bid_type bid = *(it++);
00213                 Blocks1[i].read(bid, read_reqs[i]);
00214                 bm-&gt;delete_block(bid);
00215         }
00216         
00217         <span class="keywordtype">int</span> k = 0;
00218         <span class="keywordtype">int</span> shift1 = <span class="keyword">sizeof</span>(<span class="keyword">typename</span> type::key_type)*8 - log_k1;
00219         <span class="keywordtype">int</span> shift2 = shift1 - log_k2;
00220 
00221         <span class="keywordflow">for</span> (; k &lt; nruns; k++)
00222         {
00223                 run = runs[k];
00224                 run_size = run-&gt;size ();
00225                 
00226                 <span class="keywordflow">for</span> (i = 0; i &lt; k1; i++)
00227                         bucket1[i] = 0;
00228 
00229                 type_key * ref_ptr = refs1;
00230                 <span class="keywordflow">for</span> (i = 0; i &lt; run_size; i++)
00231                 {
00232                         <span class="keywordflow">if</span> (k)
00233                         {
00234                                 write_reqs[i]-&gt;wait();
00235                                 <span class="keyword">delete</span> write_reqs[i];
00236                         }
00237                         
00238         <span class="comment">/*      if(! read_reqs[i])</span>
00239 <span class="comment">                        {</span>
00240 <span class="comment">                                STXXL_ERRMSG("NULL");</span>
00241 <span class="comment">                                abort();</span>
00242 <span class="comment">                        }*/</span>
00243                         read_reqs[i]-&gt;wait();
00244                         <span class="keyword">delete</span> read_reqs[i];
00245 
00246                         classify_block(Blocks1[i].begin(),Blocks1[i].end(),ref_ptr,bucket1,offset,shift1);
00247                 }
00248                                 
00249                 exclusive_prefix_sum(bucket1, k1);
00250                 classify(refs1, refs1 + run_size * Blocks1-&gt;size, refs2, bucket1,
00251                           offset, shift1);
00252                 
00253                 <span class="keywordtype">int</span> out_block = 0;
00254                 <span class="keywordtype">int</span> out_pos = 0;
00255                 <span class="keywordtype">int</span> next_run_size = (k &lt; nruns - 1)?(runs[k + 1]-&gt;size ()):0;
00256                 
00257                 <span class="comment">// recurse on each bucket</span>
00258                 type_key *c = refs2;
00259                 type_key *d = refs1;
00260                 block_type *cur_blk = Blocks2;
00261                 block_type *end_blk = Blocks2 + next_run_size;
00262                 write_completion_handler&lt;block_type,bid_type&gt; * next_read = next_run_reads;
00263                 
00264                 <span class="keywordflow">for</span> (i = 0; i &lt; k1; i++)
00265                 {
00266                         type_key *cEnd = refs2 + bucket1[i];
00267                         type_key *dEnd = refs1 + bucket1[i];
00268                         
00269                         l1sort (c, cEnd, d, bucket2, k2,
00270                                 offset + (1 &lt;&lt; shift1) * i , shift2);
00271                         
00272                         write_out&lt;type,type_key,block_type,bid_type,run_type&gt;(
00273                                                         d,dEnd,cur_blk,end_blk,
00274                                                         out_block,out_pos,*run,next_read,
00275                                                         write_reqs,read_reqs,it,keyobj);
00276                         
00277                         c = cEnd;
00278                         d = dEnd;
00279                 }
00280 
00281                 std::swap (Blocks1, Blocks2);
00282         }
00283         
00284         mc::waitdel_all (write_reqs, m2);
00285 
00286         <span class="keyword">delete</span>[]bucket1;
00287         <span class="keyword">delete</span>[]bucket2;
00288         <span class="keyword">delete</span>[]refs1;
00289         <span class="keyword">delete</span>[]refs2;
00290         <span class="keyword">delete</span>[]Blocks1;
00291         <span class="keyword">delete</span>[]Blocks2;
00292         <span class="keyword">delete</span>[]next_run_reads;
00293         <span class="keyword">delete</span>[]read_reqs;
00294         <span class="keyword">delete</span>[]write_reqs;
00295 }
00296 
00297 
00298 
00299 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> block_type&gt;
00300 <span class="keyword">struct </span>run_cursor
00301 {
00302         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos;
00303         block_type *buffer;
00304 
00305         <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">typename</span> block_type::type &amp; current ()<span class="keyword"> const</span>
00306 <span class="keyword">        </span>{
00307                 <span class="keywordflow">return</span> (*buffer)[pos];
00308         }
00309         <span class="keyword">inline</span> <span class="keywordtype">void</span> operator ++ (<span class="keywordtype">int</span>)
00310         {
00311                 pos++;
00312         }
00313 };
00314 
00315 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> run_type,
00316                                         <span class="keyword">typename</span> block_type,
00317                                         <span class="keyword">typename</span> run_cursor,
00318                                         <span class="keyword">typename</span> run_cursor2,
00319                                         <span class="keyword">typename</span> trigger_entry&gt;
00320 <span class="keyword">class </span>prefetcher_writer;
00321 
00322 
00323 <span class="keyword">struct </span>have_prefetcher
00324 {
00325         <span class="keyword">static</span> <span class="keywordtype">void</span> * untyped_prefetcher;
00326 };
00327 
00328 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> bid_type,
00329                                         <span class="keyword">typename</span> key_type,
00330                                         <span class="keyword">typename</span> block_type,
00331                                         <span class="keywordtype">unsigned</span> block_size,
00332                                         <span class="keyword">typename</span> run_type&gt;
00333 <span class="keyword">struct </span>run_cursor2:<span class="keyword">public</span> run_cursor&lt;block_type&gt;,<span class="keyword">public</span> have_prefetcher
00334 {
00335         <span class="keyword">typedef</span> run_cursor2&lt;bid_type,key_type,block_type,block_size,run_type&gt; _Self;
00336         <span class="keyword">typedef</span> prefetcher_writer&lt;run_type,block_type,
00337                 run_cursor&lt;block_type&gt;,_Self,trigger_entry&lt;bid_type,key_type&gt; &gt; prefetcher_writer_type;
00338                                                                                         
00339         <span class="keyword">static</span> prefetcher_writer_type *&amp; prefetcher() <span class="comment">// sorry, hack</span>
00340         {
00341                 <span class="keywordflow">return</span> (prefetcher_writer_type * &amp;) untyped_prefetcher;
00342         };
00343         
00344         run_cursor2 ()
00345         {
00346         };
00347         
00348         <span class="keyword">inline</span> <span class="keywordtype">bool</span> empty ()<span class="keyword"> const</span>
00349 <span class="keyword">        </span>{
00350                 <span class="keywordflow">return</span> (pos &gt;= block_size);
00351         };
00352         <span class="keyword">inline</span> <span class="keywordtype">void</span> operator ++ (<span class="keywordtype">int</span>);
00353         <span class="keyword">inline</span> <span class="keywordtype">void</span> make_inf ()
00354         {
00355                 pos = block_size;
00356         };
00357 };
00358 
00359 <span class="keywordtype">void</span> * have_prefetcher::untyped_prefetcher = NULL;
00360 
00361 <span class="preprocessor">#ifdef SORT_OPT_PREFETCHING</span>
00362 <span class="preprocessor"></span><span class="preprocessor">#include "koptprefetcher.h"</span>
00363 <span class="preprocessor">#else</span>
00364 <span class="preprocessor"></span><span class="preprocessor">#include "kprefetcher.h"</span>
00365 <span class="preprocessor">#endif</span>
00366 <span class="preprocessor"></span>
00367 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> bid_type,
00368                                         <span class="keyword">typename</span> key_type,
00369                                         <span class="keyword">typename</span> block_type,
00370                                         <span class="keywordtype">unsigned</span> block_size,
00371                                         <span class="keyword">typename</span> run_type&gt;
00372 <span class="keywordtype">void</span>
00373 run_cursor2&lt;bid_type,key_type,block_type,block_size,run_type&gt;::operator ++ (<span class="keywordtype">int</span>)
00374 {
00375         pos++;
00376         <span class="keywordflow">if</span> (UNLIKELY (pos &gt;= block_size))
00377         {
00378                 prefetcher()-&gt;block_consumed (*<span class="keyword">this</span>);
00379         }
00380 };
00381 
00382 
00383 
00384 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> block_type&gt;
00385 <span class="keyword">struct </span>run_cursor_cmp
00386 {
00387         <span class="keyword">typedef</span> run_cursor&lt;block_type&gt; cursor_type;
00388         
00389         <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator  () (<span class="keyword">const</span> cursor_type &amp; a, <span class="keyword">const</span> cursor_type &amp; b) <span class="comment">// greater or equal</span>
00390         {
00391                 <span class="keywordflow">return</span> !((*a.buffer)[a.pos] &lt; (*b.buffer)[b.pos]);
00392         };
00393 };
00394 
00395 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> bid_type,
00396                                         <span class="keyword">typename</span> key_type,
00397                                         <span class="keyword">typename</span> block_type,
00398                                         <span class="keywordtype">unsigned</span> block_size,
00399                                         <span class="keyword">typename</span> run_type&gt;
00400 <span class="keyword">struct </span>run_cursor2_cmp
00401 {
00402         <span class="keyword">typedef</span> run_cursor2&lt;bid_type,key_type,block_type,block_size,run_type&gt; cursor_type;
00403         <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator  () (<span class="keyword">const</span> cursor_type &amp; a, <span class="keyword">const</span> cursor_type &amp; b)
00404         {
00405                 <span class="keywordflow">if</span> (UNLIKELY (b.empty ()))
00406                         <span class="keywordflow">return</span> <span class="keyword">true</span>;    <span class="comment">// sentinel emulation</span>
00407                 <span class="keywordflow">if</span> (UNLIKELY (a.empty ()))
00408                         <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">//sentinel emulation</span>
00409 
00410                 <span class="keywordflow">return</span> (a.current ().key() &lt; b.current ().key());
00411         };
00412 };
00413 
00414 
00415 <span class="preprocessor">#include "loosertree.h"</span>
00416 
00417 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> run_type,
00418                                         <span class="keyword">typename</span> prefetcher_writer_type,
00419                                         <span class="keyword">typename</span> block_type,
00420                                         <span class="keywordtype">unsigned</span> block_size&gt;
00421 <span class="keywordtype">void</span>
00422 merge_2runs (run_type ** in_runs, prefetcher_writer_type &amp; prefetcher, <span class="keywordtype">unsigned</span> nblocks)
00423 {
00424         <span class="keywordtype">unsigned</span> pos1 = 0, pos2 = 0, out_buf_pos = 0, i_out_buf =
00425                 prefetcher.get_free_write_block();
00426         <span class="keywordtype">unsigned</span> blocks_written = 0;
00427         block_type *buf1 = prefetcher.r_block (0), *buf2 =
00428                 prefetcher.r_block (1), *out_buf =
00429                 prefetcher.w_block (i_out_buf);
00430         
00431 
00432         <span class="keywordflow">while</span> (UNLIKELY (blocks_written &lt; nblocks))
00433         {
00434                 <span class="keywordflow">if</span> ((*buf1)[pos1].key() &lt; (*buf2)[pos2].key())
00435                 {
00436                         (*out_buf)[out_buf_pos++] = (*buf1)[pos1++];
00437 
00438                         <span class="keywordflow">if</span> (UNLIKELY (pos1 &gt;= block_size))
00439                         {
00440                                 <span class="keywordflow">if</span> (LIKELY (prefetcher.block_consumed (buf1)))
00441                                 {
00442                                         pos1 = 0;
00443                                 }
00444                                 <span class="keywordflow">else</span>
00445                                 {
00446                                         <span class="comment">// first run is empty</span>
00447                                         <span class="keywordflow">for</span> (;;)
00448                                         {
00449                                                 <span class="keywordflow">if</span> (UNLIKELY(out_buf_pos &gt;= block_size))
00450                                                 {
00451                                                         i_out_buf = prefetcher.block_filled(i_out_buf);
00452                                                         
00453                                                         <span class="keywordflow">if</span> (++blocks_written &gt;= nblocks)
00454                                                                 <span class="keywordflow">break</span>;
00455 
00456                                                         out_buf = prefetcher.w_block(i_out_buf);
00457                                                         out_buf_pos = 0;
00458                                                 }
00459                                                 <span class="keywordflow">else</span>
00460                                                 {
00461                                                         (*out_buf)[out_buf_pos++] = (*buf2)[pos2++];
00462                                                         <span class="keywordflow">if</span> (UNLIKELY(pos2 &gt;= block_size))
00463                                                         {
00464                                                                 pos2 = 0;
00465                                                                 prefetcher.block_consumed(buf2);
00466                                                         }
00467                                                 }
00468 
00469                                         };
00470 
00471                                         <span class="keywordflow">break</span>;
00472                                 }
00473                         }
00474                 }
00475                 <span class="keywordflow">else</span>
00476                 {
00477                         (*out_buf)[out_buf_pos++] = (*buf2)[pos2++];
00478 
00479                         <span class="keywordflow">if</span> (UNLIKELY (pos2 &gt;= block_size))
00480                         {
00481                                 <span class="keywordflow">if</span> (LIKELY (prefetcher.block_consumed (buf2)))
00482                                 {
00483                                         pos2 = 0;
00484                                 }
00485                                 <span class="keywordflow">else</span>
00486                                 {
00487                                         <span class="comment">// second run is empty</span>
00488                                         <span class="keywordflow">for</span> (;;)
00489                                         {
00490                                                 <span class="keywordflow">if</span> (UNLIKELY(out_buf_pos &gt;= block_size))
00491                                                 {
00492                                                         i_out_buf =
00493                                                                 prefetcher.
00494                                                                 block_filled
00495                                                                 (i_out_buf);
00496                                                         <span class="keywordflow">if</span> (++blocks_written
00497                                                             &gt;= nblocks)
00498                                                                 <span class="keywordflow">break</span>;
00499 
00500                                                         out_buf =
00501                                                                 prefetcher.
00502                                                                 w_block
00503                                                                 (i_out_buf);
00504                                                         out_buf_pos = 0;
00505                                                 }
00506                                                 <span class="keywordflow">else</span>
00507                                                 {
00508                                                         (*out_buf)
00509                                                                 [out_buf_pos++]
00510                                                                 =
00511                                                                 (*buf1)
00512                                                                 [pos1++];
00513                                                         <span class="keywordflow">if</span> (UNLIKELY
00514                                                             (pos1 &gt;=
00515                                                              block_size))
00516                                                         {
00517                                                                 pos1 = 0;
00518                                                                 prefetcher.
00519                                                                         block_consumed
00520                                                                         (buf1);
00521                                                         }
00522                                                 }
00523 
00524                                         };
00525 
00526                                         <span class="keywordflow">break</span>;
00527                                 }
00528                         }
00529                 }
00530 
00531                 <span class="keywordflow">if</span> (UNLIKELY (out_buf_pos &gt;= block_size))
00532                 {
00533                         blocks_written++;
00534                         i_out_buf = prefetcher.block_filled (i_out_buf);
00535                         out_buf = prefetcher.w_block (i_out_buf);
00536                         out_buf_pos = 0;
00537                 }
00538 
00539         }
00540 
00541 
00542         block_manager *bm = block_manager::get_instance ();
00543         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; 2; i++)
00544         {
00545                 <span class="keywordtype">unsigned</span> sz = in_runs[i]-&gt;size ();
00546                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; sz; j++)
00547                         bm-&gt;delete_block ((*in_runs[i])[j].bid);
00548         }
00549 }
00550 
00551 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type,
00552                                         <span class="keyword">typename</span> bid_type,
00553                                         <span class="keyword">typename</span> key_type,
00554                                         <span class="keyword">typename</span> block_type,
00555                                         <span class="keywordtype">unsigned</span> block_size,
00556                                         <span class="keyword">typename</span> run_type,
00557                                         <span class="keyword">typename</span> run_cursor_type,
00558                                         <span class="keyword">typename</span> run_cursor2_type,
00559                                         <span class="keyword">typename</span> trigger_entry_type&gt;
00560 <span class="keywordtype">void</span>
00561 merge_runs_lt (run_type ** in_runs, <span class="keywordtype">int</span> nruns, run_type * out_run,<span class="keywordtype">unsigned</span>  _m)
00562 {
00563         <span class="keyword">typedef</span> prefetcher_writer&lt;run_type,block_type,run_cursor_type,
00564                 run_cursor2_type,trigger_entry_type&gt; prefetcher_writer_type;
00565         
00566         
00567 
00568         <span class="keywordtype">int</span> i;
00569         run_type consume_seq(out_run-&gt;size());
00570 
00571 <span class="preprocessor">        #ifdef SORT_OPT_PREFETCHING</span>
00572 <span class="preprocessor"></span>        <span class="keywordtype">int</span> * prefetch_seq = <span class="keyword">new</span> <span class="keywordtype">int</span>[out_run-&gt;size()];
00573 <span class="preprocessor">        #endif</span>
00574 <span class="preprocessor"></span>
00575         <span class="keyword">typename</span> run_type::iterator copy_start = consume_seq.begin ();
00576         <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00577         {
00578                 <span class="comment">// TODO: try to avoid copy</span>
00579                 copy_start = std::copy(
00580                                                 in_runs[i]-&gt;begin (),
00581                                                 in_runs[i]-&gt;end (),
00582                                                 copy_start      );
00583         }
00584         <a class="code" href="group__stlalgo.html#a12">std::sort</a> (consume_seq.begin (), consume_seq.end ());
00585 
00586         <span class="keywordtype">int</span> disks_number = config::get_instance ()-&gt;disks_number ();
00587         
00588         
00589         <span class="comment">//const int n_write_buffers = std::max(2 * disks_number ,  ((int(_m) - nruns) / 3) );</span>
00590         <span class="comment">//const int n_prefetch_buffers = std::max( 2 * disks_number , (2 * (int(_m) - nruns) / 3));</span>
00591         <span class="comment">//const int n_write_buffers = 3 * disks_number;</span>
00592         <span class="comment">//const int n_prefetch_buffers = std::max( 2 * disks_number , int(_m) - nruns - n_write_buffers );</span>
00593         
00594         <span class="keyword">const</span> <span class="keywordtype">int</span> n_write_buffers = std::max( 2 * disks_number , <span class="keywordtype">int</span>(_m) - nruns - n_prefetch_buffers );
00595         
00596 <span class="preprocessor">        #ifdef SORT_OPT_PREFETCHING</span>
00597 <span class="preprocessor"></span>        compute_prefetch_schedule(
00598                         consume_seq,
00599                         prefetch_seq,
00600                         n_opt_prefetch_buffers,
00601                         disks_number );
00602 <span class="preprocessor">        #endif</span>
00603 <span class="preprocessor"></span>        
00604 <span class="preprocessor">        #ifdef SORT_OPT_PREFETCHING</span>
00605 <span class="preprocessor"></span>        prefetcher_writer_type prefetcher(
00606                                                 &amp;consume_seq,
00607                                                 prefetch_seq,
00608                                     out_run,
00609                                                 nruns,
00610                                     n_prefetch_buffers,
00611                                     n_write_buffers,
00612                                     n_write_buffers/2 );
00613 <span class="preprocessor">        #else</span>
00614 <span class="preprocessor"></span>        prefetcher_writer_type prefetcher(
00615                                                 &amp;consume_seq,
00616                                     out_run,
00617                                                 nruns,
00618                                     n_prefetch_buffers,
00619                                     n_write_buffers,
00620                                     n_write_buffers/2 );
00621 <span class="preprocessor">        #endif</span>
00622 <span class="preprocessor"></span>
00623         <span class="keywordtype">int</span> out_run_size = out_run-&gt;size ();
00624 
00625         
00626         <span class="keywordflow">switch</span> (nruns)
00627         {
00628         <span class="keywordflow">case</span> 2:
00629                 merge_2runs&lt;run_type,prefetcher_writer_type,block_type,block_size&gt;(in_runs, prefetcher, out_run_size);
00630                 <span class="keywordflow">return</span>;
00631         }
00632 
00633         looser_tree&lt;type,
00634                                                         run_cursor2_type,
00635                                                         run_cursor2_cmp&lt;bid_type,key_type,block_type,block_size,run_type&gt;,
00636                                                         prefetcher_writer_type,
00637                                                         block_size&gt; 
00638                                                                                                                 loosers (&amp;prefetcher, nruns);
00639 
00640         <span class="keywordtype">int</span> i_out_buffer = prefetcher.get_free_write_block ();
00641         <span class="comment">//  STXXL_MSG("Block "&lt;&lt;i_out_buffer&lt;&lt;" taken")</span>
00642         type *out_buffer = prefetcher.w_block (i_out_buffer)-&gt;elem;
00643 
00644         <span class="keywordflow">for</span> (i = 0; i &lt; out_run_size; i++)
00645         {
00646                 loosers.multi_merge (out_buffer);
00647 
00648                 i_out_buffer = prefetcher.block_filled (i_out_buffer);
00649                 <span class="comment">//    STXXL_MSG("Block "&lt;&lt;i_out_buffer&lt;&lt;" taken")</span>
00650                 out_buffer = prefetcher.w_block (i_out_buffer)-&gt;elem;
00651         }
00652         
00653 <span class="preprocessor">        #ifdef SORT_OPT_PREFETCHING</span>
00654 <span class="preprocessor"></span>        <span class="keyword">delete</span> [] prefetch_seq;
00655 <span class="preprocessor">        #endif</span>
00656 <span class="preprocessor"></span>
00657         block_manager *bm = block_manager::get_instance ();
00658         <span class="keywordflow">for</span> (i = 0; i &lt; nruns; i++)
00659         {
00660                 <span class="keywordtype">unsigned</span> sz = in_runs[i]-&gt;size ();
00661                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; sz; j++)
00662                         bm-&gt;delete_block ((*in_runs[i])[j].bid);
00663         }
00664 }
00665 
00666 
00667 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> type,
00668                                         <span class="keyword">typename</span> bid_type,
00669                                         <span class="keyword">typename</span> block_type,
00670                                         <span class="keyword">typename</span> alloc_strategy,
00671                                         <span class="keyword">typename</span> input_bid_iterator&gt;
00672 simple_vector&lt; trigger_entry&lt;bid_type,typename type::key_type&gt; &gt; * 
00673         ksort_blocks(input_bid_iterator input_bids,<span class="keywordtype">unsigned</span> _n,<span class="keywordtype">unsigned</span> _m)
00674 {
00675         <span class="keyword">typedef</span> trigger_entry&lt;bid_type,typename type::key_type&gt; trigger_entry_type;
00676         <span class="keyword">typedef</span> simple_vector&lt; trigger_entry_type &gt; run_type;
00677         <span class="keyword">typedef</span> <span class="keyword">typename</span> interleaved_alloc_traits&lt;alloc_strategy&gt;::strategy interleaved_alloc_strategy;
00678         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m2 = _m / 2;
00679         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> full_runs = _n / m2;
00680         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> partial_runs = ((_n % m2) ? 1 : 0);
00681         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nruns = full_runs + partial_runs;
00682         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00683         
00684         config *cfg = config::get_instance ();
00685         block_manager *mng = block_manager::get_instance ();
00686         <span class="keywordtype">int</span> ndisks = cfg-&gt;disks_number ();
00687         
00688         <span class="comment">//STXXL_MSG ("n=" &lt;&lt; _n &lt;&lt; " nruns=" &lt;&lt; nruns &lt;&lt; "=" &lt;&lt; full_runs &lt;&lt; "+"</span>
00689         <span class="comment">//         &lt;&lt; partial_runs) </span>
00690         
00691 <span class="preprocessor">#ifdef STXXL_IO_STATS</span>
00692 <span class="preprocessor"></span>        stats *iostats = stats::get_instance ();
00693         iostats-&gt;reset ();
00694 <span class="preprocessor">#endif</span>
00695 <span class="preprocessor"></span>
00696         
00697         <span class="keywordtype">double</span> begin =
00698                 stxxl_timestamp (), after_runs_creation, end;
00699 
00700         run_type **runs = <span class="keyword">new</span> run_type *[nruns];
00701 
00702         <span class="keywordflow">for</span> (i = 0; i &lt; full_runs; i++)
00703                 runs[i] = <span class="keyword">new</span> run_type (m2);
00704 
00705 <span class="preprocessor">#ifdef INTERLEAVED_ALLOC</span>
00706 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (partial_runs)
00707         {
00708                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last_run_size = _n - full_runs * m2;
00709                 runs[i] = <span class="keyword">new</span> run_type (last_run_size);
00710 
00711                 mng-&gt;new_blocks (interleaved_alloc_strategy (nruns, 0, ndisks),
00712                                  RunsToBIDArrayAdaptor2 &lt; block_type::raw_size,run_type &gt;
00713                                  (runs, 0, nruns, last_run_size),
00714                                  RunsToBIDArrayAdaptor2 &lt; block_type::raw_size,run_type &gt;
00715                                  (runs, _n, nruns, last_run_size));
00716 
00717         }
00718         <span class="keywordflow">else</span>
00719                 mng-&gt;new_blocks (interleaved_alloc_strategy (nruns, 0, ndisks),
00720                                  RunsToBIDArrayAdaptor &lt; block_type::raw_size,run_type &gt;
00721                                  (runs, 0, nruns),
00722                                  RunsToBIDArrayAdaptor &lt; block_type::raw_size,run_type &gt;
00723                                  (runs, _n, nruns));
00724 <span class="preprocessor">#else</span>
00725 <span class="preprocessor"></span>        
00726                 <span class="keywordflow">if</span> (partial_runs)
00727                         runs[i] = <span class="keyword">new</span> run_type (_n - full_runs * m2);
00728                 
00729                 <span class="keywordflow">for</span>(i=0;i&lt;nruns;i++)
00730                 {
00731                         mng-&gt;new_blocks(        alloc_strategy(0,ndisks),
00732                                                                                                 trigger_entry_iterator&lt;trigger_entry_type,block_type::raw_size&gt;(runs[i]-&gt;begin()),
00733                                                                                                 trigger_entry_iterator&lt;trigger_entry_type,block_type::raw_size&gt;(runs[i]-&gt;end()) );
00734                 }
00735 <span class="preprocessor">#endif</span>
00736 <span class="preprocessor"></span>        
00737         
00738         create_runs&lt;type,
00739                                                         type_key&lt;type&gt;,
00740                                                         block_type,
00741                                                         bid_type,
00742                                                         run_type,
00743                                                         input_bid_iterator &gt; (input_bids, runs, nruns,_m);
00744 
00745         after_runs_creation = stxxl_timestamp ();
00746 <span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00747 <span class="preprocessor"></span>        <span class="keywordtype">double</span> io_wait_after_rf = stxxl::wait_time_counter;
00748 <span class="preprocessor">#endif</span>
00749 <span class="preprocessor"></span>
00750 <span class="preprocessor">#define merge_runs merge_runs_lt</span>
00751 <span class="preprocessor"></span>
00752 
00753         disk_queues::get_instance ()-&gt;set_priority_op (disk_queue::WRITE);
00754 
00755         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> full_runsize = m2;
00756         run_type **new_runs;
00757 
00758         <span class="keywordflow">while</span> (nruns &gt; 1)
00759         {
00760                 full_runsize = full_runsize * _m;
00761                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> new_full_runs = _n / full_runsize;
00762                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> new_partial_runs = ((_n % full_runsize) ? 1 : 0);
00763                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> new_nruns = new_full_runs + new_partial_runs;
00764 
00765                 new_runs = <span class="keyword">new</span> run_type *[new_nruns];
00766 
00767                 <span class="keywordflow">for</span> (i = 0; i &lt; new_full_runs; i++)
00768                         new_runs[i] = <span class="keyword">new</span> run_type (full_runsize);
00769 
00770                 <span class="keywordflow">if</span> (nruns - new_full_runs * _m == 1)
00771                 {
00772                         <span class="comment">// case where one partial run is left to be sorted</span>
00773                         <span class="comment">//      STXXL_MSG("case where one partial run is left to be sorted")</span>
00774                         new_runs[i] =
00775                                 <span class="keyword">new</span> run_type (_n - full_runsize * new_full_runs);
00776                         
00777                         run_type *tmp = runs[new_full_runs * _m];
00778                         std::copy (tmp-&gt;begin (), tmp-&gt;end (),
00779                                    new_runs[i]-&gt;begin ());
00780 
00781                         mng-&gt;new_blocks (interleaved_alloc_strategy
00782                                          (new_nruns - 1, 0, ndisks),
00783                                          RunsToBIDArrayAdaptor &lt;
00784                                          block_type::raw_size,run_type &gt; (new_runs, 0,
00785                                                             new_nruns - 1),
00786                                          RunsToBIDArrayAdaptor &lt;
00787                                          block_type::raw_size,run_type &gt; (new_runs,
00788                                                             new_full_runs *
00789                                                             full_runsize,
00790                                                             new_nruns - 1));
00791 
00792                         
00793                         <span class="keywordflow">for</span> (i = 0; i &lt; new_full_runs; i++)
00794                         {
00795                                 merge_runs &lt;type,
00796                                                                                 bid_type,
00797                                                                                 <span class="keyword">typename</span> type::key_type,
00798                                                                                 block_type,
00799                                                                                 block_type::size,
00800                                                                                 run_type,
00801                                                                                 run_cursor&lt;block_type&gt;,
00802                                                                                 run_cursor2&lt;bid_type,typename type::key_type,block_type,block_type::size,run_type&gt;,
00803                                                                                 trigger_entry&lt;bid_type,typename type::key_type&gt;
00804                                                                         &gt;
00805                                                         (runs + i * _m, _m,*(new_runs + i),_m);
00806                         }
00807 
00808 
00809                 }
00810                 <span class="keywordflow">else</span>
00811                 {
00812 
00813                         <span class="comment">//allocate output blocks</span>
00814                         <span class="keywordflow">if</span> (new_partial_runs)
00815                         {
00816                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last_run_size =
00817                                         _n - full_runsize * new_full_runs;
00818                                 new_runs[i] = <span class="keyword">new</span> run_type (last_run_size);
00819 
00820                                 mng-&gt;new_blocks (interleaved_alloc_strategy
00821                                                  (new_nruns, 0, ndisks),
00822                                                  RunsToBIDArrayAdaptor2 &lt;
00823                                                  block_type::raw_size,run_type &gt; (new_runs,
00824                                                                     0,
00825                                                                     new_nruns,
00826                                                                     last_run_size),
00827                                                  RunsToBIDArrayAdaptor2 &lt;
00828                                                  block_type::raw_size,run_type &gt; (new_runs,
00829                                                                     _n,
00830                                                                     new_nruns,
00831                                                                     last_run_size));
00832                         }
00833                         <span class="keywordflow">else</span>
00834                                 mng-&gt;new_blocks (interleaved_alloc_strategy
00835                                                  (new_nruns, 0, ndisks),
00836                                                  RunsToBIDArrayAdaptor &lt;
00837                                                  block_type::raw_size,run_type &gt; (new_runs,
00838                                                                     0,
00839                                                                     new_nruns),
00840                                                  RunsToBIDArrayAdaptor &lt;
00841                                                  block_type::raw_size,run_type &gt; (new_runs,
00842                                                                     _n,
00843                                                                     new_nruns));
00844 
00845 
00846                         <span class="comment">//      STXXL_MSG("Output runs:" &lt;&lt; new_nruns &lt;&lt; "=" &lt;&lt; new_full_runs &lt;&lt; "+" &lt;&lt; new_partial_runs)</span>
00847                         <span class="keywordflow">for</span> (i = 0; i &lt; new_full_runs; i++)
00848                         {
00849                                 <span class="comment">//        STXXL_MSG("Merge of m ("&lt;&lt; _m &lt;&lt;") runs")</span>
00850                                 merge_runs &lt;type,
00851                                                                                 bid_type,
00852                                                                                 <span class="keyword">typename</span> type::key_type,
00853                                                                                 block_type,
00854                                                                                 block_type::size,
00855                                                                                 run_type,
00856                                                                                 run_cursor&lt;block_type&gt;,
00857                                                                                 run_cursor2&lt;bid_type,typename type::key_type,block_type,block_type::size,run_type &gt;,
00858                                                                                 trigger_entry&lt;bid_type,typename type::key_type&gt;
00859                                                                         &gt;
00860                                                 (runs + i * _m, _m, *(new_runs + i),_m);
00861                         }
00862 
00863                         <span class="keywordflow">if</span> (new_partial_runs)
00864                         {
00865                                 <span class="comment">//      STXXL_MSG("Partial merge of "&lt;&lt; (nruns - i*_m) &lt;&lt;" runs")</span>
00866                                 merge_runs &lt;type,
00867                                                                                 bid_type,
00868                                                                                 <span class="keyword">typename</span> type::key_type,
00869                                                                                 block_type,
00870                                                                                 block_type::size,
00871                                                                                 run_type,
00872                                                                                 run_cursor&lt;block_type&gt;,
00873                                                                                 run_cursor2&lt;bid_type,typename type::key_type,block_type,block_type::size,run_type &gt;,
00874                                                                                 trigger_entry&lt;bid_type,typename type::key_type&gt;
00875                                                                         &gt;
00876                                                                                         (runs + i * _m, nruns - i * _m,*(new_runs + i),_m);
00877                         }
00878 
00879                 }
00880 
00881                 nruns = new_nruns;
00882                 <span class="keyword">delete</span>[]runs;
00883                 runs = new_runs;
00884 
00885         }
00886         run_type * result = *runs;
00887         <span class="keyword">delete</span> [] runs;
00888         
00889         
00890         end = stxxl_timestamp ();
00891 
00892         STXXL_MSG (<span class="stringliteral">"Elapsed time        : "</span> &lt;&lt; end - begin &lt;&lt; <span class="stringliteral">" s. Run creation time: "</span> &lt;&lt; 
00893         after_runs_creation - begin &lt;&lt; <span class="stringliteral">" s"</span>)
00894 #ifdef STXXL_IO_STATS
00895         STXXL_MSG (<span class="stringliteral">"reads               : "</span> &lt;&lt; iostats-&gt;get_reads ()) 
00896         STXXL_MSG (<span class="stringliteral">"writes              : "</span> &lt;&lt; iostats-&gt;get_writes ())
00897         STXXL_MSG (<span class="stringliteral">"read time           : "</span> &lt;&lt; iostats-&gt;get_read_time () &lt;&lt; <span class="stringliteral">" s"</span>) 
00898         STXXL_MSG (<span class="stringliteral">"write time          : "</span> &lt;&lt; iostats-&gt;get_write_time () &lt;&lt;<span class="stringliteral">" s"</span>)
00899         STXXL_MSG (<span class="stringliteral">"parallel read time  : "</span> &lt;&lt; iostats-&gt;get_pread_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00900         STXXL_MSG (<span class="stringliteral">"parallel write time : "</span> &lt;&lt; iostats-&gt;get_pwrite_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00901         STXXL_MSG (<span class="stringliteral">"parallel io time    : "</span> &lt;&lt; iostats-&gt;get_pio_time () &lt;&lt; <span class="stringliteral">" s"</span>)
00902 <span class="preprocessor">#endif</span>
00903 <span class="preprocessor"></span><span class="preprocessor">#ifdef COUNT_WAIT_TIME</span>
00904 <span class="preprocessor"></span>        STXXL_MSG (<span class="stringliteral">"Time in I/O wait(rf): "</span> &lt;&lt; io_wait_after_rf &lt;&lt; <span class="stringliteral">" s"</span>)
00905         STXXL_MSG (<span class="stringliteral">"Time in I/O wait    : "</span> &lt;&lt; stxxl::wait_time_counter &lt;&lt; <span class="stringliteral">" s"</span>)
00906 #endif
00907         
00908         <span class="keywordflow">return</span> result;
00909 }
00910 
00911 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _RAIter&gt;
00912 <span class="keywordtype">void</span> <a class="code" href="group__stlalgo.html#a8">ksort</a>(_RAIter __first, _RAIter __last,<span class="keywordtype">unsigned</span> __M)
00913 {
00914         <span class="keyword">typedef</span> simple_vector&lt; trigger_entry&lt;<span class="keyword">typename</span> _RAIter::bid_type,
00915                         <span class="keyword">typename</span> _RAIter::vector_type::value_type::key_type&gt; &gt; run_type;
00916         <span class="keyword">typedef</span> <span class="keyword">typename</span> _RAIter::vector_type::value_type value_type;
00917         <span class="keyword">typedef</span> <span class="keyword">typename</span> _RAIter::block_type block_type;
00918         
00919         <span class="keywordtype">unsigned</span> n=0;
00920         block_manager *mng = block_manager::get_instance ();
00921         
00922         __first.flush();
00923         
00924         <span class="keywordflow">if</span>((__last - __first)*<span class="keyword">sizeof</span>(value_type) &lt; __M)
00925         {
00926                 STXXL_ERRMSG(<span class="stringliteral">"In-memory sort, not implemented"</span>)
00927                 abort();
00928         }
00929         <span class="keywordflow">else</span>
00930         {
00931                 <span class="keywordflow">if</span>(__first.block_offset()) 
00932                 {
00933                         <span class="keywordflow">if</span>(__last.block_offset()) <span class="comment">// first and last element reside </span>
00934                                                                                                                                 <span class="comment">// not in the beginning of the block</span>
00935                         {
00936                                 <span class="keyword">typename</span> _RAIter::block_type * first_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
00937                                 <span class="keyword">typename</span> _RAIter::block_type * last_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
00938                                 <span class="keyword">typename</span> _RAIter::bid_type first_bid,last_bid;
00939                                 request *req;
00940                                 
00941                                 first_block-&gt;read(*__first.bid(),req);
00942                                 mng-&gt;new_blocks( FR(), &amp;first_bid,(&amp;first_bid) + 1); <span class="comment">// try to overlap</span>
00943                                 mng-&gt;new_blocks( FR(), &amp;last_bid,(&amp;last_bid) + 1);
00944                                 req-&gt;wait();
00945                                 <span class="keyword">delete</span> req;
00946                         
00947                                 last_block-&gt;read(*__last.bid(),req);
00948                                 
00949                                 <span class="keywordtype">unsigned</span> i=0;
00950                                 <span class="keywordflow">for</span>(;i&lt;__first.block_offset();i++)
00951                                 {
00952                                         first_block-&gt;elem[i] = value_type::min_value();
00953                                 }
00954                                 
00955                                 req-&gt;wait();
00956                                 <span class="keyword">delete</span> req;
00957                                 
00958                                 first_block-&gt;write(first_bid,req);
00959                                 <span class="keywordflow">for</span>(i=__last.block_offset(); i &lt; block_type::size;i++)
00960                                 {
00961                                         last_block-&gt;elem[i] = value_type::max_value();
00962                                 }
00963                                 
00964                                 req-&gt;wait();
00965                                 <span class="keyword">delete</span> req;
00966                                 
00967                                 last_block-&gt;write(last_bid,req);
00968                                 
00969                                 n=__last.bid() - __first.bid() + 1;
00970                                 
00971                                 std::swap(first_bid,*__first.bid());
00972                                 std::swap(last_bid,*__last.bid());
00973                                 
00974                                 req-&gt;wait();
00975                                 <span class="keyword">delete</span> req;
00976                                 
00977                                 <span class="keyword">delete</span> first_block;
00978                                 <span class="keyword">delete</span> last_block;
00979 
00980                                 run_type * out =
00981                                                 ksort_blocks&lt;   <span class="keyword">typename</span> _RAIter::vector_type::value_type,
00982                                                                                                         <span class="keyword">typename</span> _RAIter::bid_type,
00983                                                                                                         <span class="keyword">typename</span> _RAIter::block_type,
00984                                                                                                         <span class="keyword">typename</span> _RAIter::vector_type::alloc_strategy,
00985                                                                                                         <span class="keyword">typename</span> _RAIter::bids_container_iterator &gt;
00986                                                                                                                  (__first.bid(),n,__M/block_type::raw_size);
00987                                         
00988                                 
00989                                 first_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
00990                                 last_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
00991                                 <span class="keyword">typename</span> _RAIter::block_type * sorted_first_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
00992                                 <span class="keyword">typename</span> _RAIter::block_type * sorted_last_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
00993                                 request ** reqs = <span class="keyword">new</span> request * [2];
00994                                 
00995                                 first_block-&gt;read(first_bid,reqs[0]);
00996                                 sorted_first_block-&gt;read((*(out-&gt;begin())).bid,reqs[1]);
00997                                 mc::waitdel_all(reqs,2);
00998                                 
00999                                 last_block-&gt;read(last_bid,reqs[0]);
01000                                 sorted_last_block-&gt;read( ((*out)[out-&gt;size() - 1]).bid,reqs[1]);
01001                                 
01002                                 <span class="keywordflow">for</span>(i=__first.block_offset();i&lt;block_type::size;i++)
01003                                 {
01004                                         first_block-&gt;elem[i] = sorted_first_block-&gt;elem[i];
01005                                 }
01006                                 mc::waitdel_all(reqs,2);
01007                                 
01008                                 first_block-&gt;write(first_bid,req);
01009                                 
01010                                 <span class="keywordflow">for</span>(i=0;i&lt;__last.block_offset();i++)
01011                                 {
01012                                         last_block-&gt;elem[i] = sorted_last_block-&gt;elem[i];
01013                                 }
01014                                 
01015                                 req-&gt;wait();
01016                                 <span class="keyword">delete</span> req;
01017                                 
01018                                 last_block-&gt;write(last_bid,req);
01019                                 
01020                                 mng-&gt;delete_block(out-&gt;begin()-&gt;bid);
01021                                 mng-&gt;delete_block((*out)[out-&gt;size() - 1].bid);
01022                                 
01023                                 *__first.bid() = first_bid;
01024                                 *__last.bid() = last_bid; 
01025                                 
01026                                 run_type::iterator it = out-&gt;begin(); it++;
01027                                 <span class="keyword">typename</span> _RAIter::bids_container_iterator cur_bid = __first.bid(); cur_bid ++;
01028                                 
01029                                 <span class="keywordflow">for</span>(;cur_bid != __last.bid(); cur_bid++,it++)
01030                                 {
01031                                         *cur_bid = (*it).bid;
01032                                 }
01033                                 
01034                                 <span class="keyword">delete</span> first_block;
01035                                 <span class="keyword">delete</span> sorted_first_block;
01036                                 <span class="keyword">delete</span> sorted_last_block;
01037                                 <span class="keyword">delete</span> [] reqs;
01038                                 <span class="keyword">delete</span> out;
01039                                 
01040                                 req-&gt;wait();
01041                                 <span class="keyword">delete</span> req;
01042                                 
01043                                 <span class="keyword">delete</span> last_block;
01044                         }
01045                         <span class="keywordflow">else</span>
01046                         {
01047                                 <span class="comment">// first element resides</span>
01048                                 <span class="comment">// not in the beginning of the block</span>
01049                                 
01050                                 <span class="keyword">typename</span> _RAIter::block_type * first_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
01051                                 <span class="keyword">typename</span> _RAIter::bid_type first_bid;
01052                                 request *req;
01053                                 
01054                                 first_block-&gt;read(*__first.bid(),req);
01055                                 mng-&gt;new_blocks( FR(), &amp;first_bid,(&amp;first_bid) + 1); <span class="comment">// try to overlap</span>
01056                                 req-&gt;wait();
01057                                 <span class="keyword">delete</span> req;
01058                                 
01059                                 <span class="keywordtype">unsigned</span> i=0;
01060                                 <span class="keywordflow">for</span>(;i&lt;__first.block_offset();i++)
01061                                 {
01062                                         first_block-&gt;elem[i] = value_type::min_value();
01063                                 }
01064                                 
01065                                 first_block-&gt;write(first_bid,req);
01066                                 
01067                                 n=__last.bid() - __first.bid();
01068                                 
01069                                 std::swap(first_bid,*__first.bid());
01070                                 
01071                                 req-&gt;wait();
01072                                 <span class="keyword">delete</span> req;
01073                                 
01074                                 <span class="keyword">delete</span> first_block;
01075 
01076                                 run_type * out =
01077                                                 ksort_blocks&lt;   <span class="keyword">typename</span> _RAIter::vector_type::value_type,
01078                                                                                                         <span class="keyword">typename</span> _RAIter::bid_type,
01079                                                                                                         <span class="keyword">typename</span> _RAIter::block_type,
01080                                                                                                         <span class="keyword">typename</span> _RAIter::vector_type::alloc_strategy,
01081                                                                                                         <span class="keyword">typename</span> _RAIter::bids_container_iterator &gt;
01082                                                                                                                  (__first.bid(),n,__M/block_type::raw_size);
01083                                         
01084                                 
01085                                 first_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
01086                                 
01087                                 <span class="keyword">typename</span> _RAIter::block_type * sorted_first_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
01088         
01089                                 request ** reqs = <span class="keyword">new</span> request * [2];
01090                                 
01091                                 first_block-&gt;read(first_bid,reqs[0]);
01092                                 sorted_first_block-&gt;read((*(out-&gt;begin())).bid,reqs[1]);
01093                                 mc::waitdel_all(reqs,2);
01094                                 
01095                                 <span class="keywordflow">for</span>(i=__first.block_offset();i&lt;block_type::size;i++)
01096                                 {
01097                                         first_block-&gt;elem[i] = sorted_first_block-&gt;elem[i];
01098                                 }
01099                                 
01100                                 first_block-&gt;write(first_bid,req);
01101                                 
01102                                 mng-&gt;delete_block(out-&gt;begin()-&gt;bid);
01103                                 
01104                                 *__first.bid() = first_bid;
01105                                 
01106                                 run_type::iterator it = out-&gt;begin(); it++;
01107                                 <span class="keyword">typename</span> _RAIter::bids_container_iterator cur_bid = __first.bid(); cur_bid ++;
01108                                 
01109                                 <span class="keywordflow">for</span>(;cur_bid != __last.bid(); cur_bid++,it++)
01110                                 {
01111                                         *cur_bid = (*it).bid;
01112                                 }
01113                                 
01114                                 *cur_bid = (*it).bid;
01115                                 
01116                                 <span class="keyword">delete</span> sorted_first_block;
01117                                 <span class="keyword">delete</span> [] reqs;
01118                                 <span class="keyword">delete</span> out;
01119                                 
01120                                 req-&gt;wait();
01121                                 <span class="keyword">delete</span> req;
01122                                 
01123                                 <span class="keyword">delete</span> first_block;
01124                                 
01125                         }
01126                         
01127                 }
01128                 <span class="keywordflow">else</span>
01129                 {
01130                         <span class="keywordflow">if</span>(__last.block_offset()) <span class="comment">// last element resides</span>
01131                                                                                                                                 <span class="comment">// not in the beginning of the block</span>
01132                         {
01133                                 <span class="keyword">typename</span> _RAIter::block_type * last_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
01134                                 <span class="keyword">typename</span> _RAIter::bid_type last_bid;
01135                                 request *req;
01136                                 <span class="keywordtype">unsigned</span> i;
01137                                 
01138                                 last_block-&gt;read(*__last.bid(),req);
01139                                 mng-&gt;new_blocks( FR(), &amp;last_bid,(&amp;last_bid) + 1);
01140                                 req-&gt;wait();
01141                                 <span class="keyword">delete</span> req;
01142                         
01143                                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=__last.block_offset(); i &lt; block_type::size;i++)
01144                                 {
01145                                         last_block-&gt;elem[i] = value_type::max_value();
01146                                 }
01147                                 
01148                                 last_block-&gt;write(last_bid,req);
01149                                 
01150                                 n=__last.bid() - __first.bid() + 1;
01151                                 
01152                                 std::swap(last_bid,*__last.bid());
01153                                 
01154                                 req-&gt;wait();
01155                                 <span class="keyword">delete</span> req;
01156                                 
01157                                 <span class="keyword">delete</span> last_block;
01158 
01159                                 run_type * out =
01160                                                 ksort_blocks&lt;   <span class="keyword">typename</span> _RAIter::vector_type::value_type,
01161                                                                                                         <span class="keyword">typename</span> _RAIter::bid_type,
01162                                                                                                         <span class="keyword">typename</span> _RAIter::block_type,
01163                                                                                                         <span class="keyword">typename</span> _RAIter::vector_type::alloc_strategy,
01164                                                                                                         <span class="keyword">typename</span> _RAIter::bids_container_iterator &gt;
01165                                                                                                                  (__first.bid(),n,__M/block_type::raw_size);
01166                                         
01167                                 
01168                                 
01169                                 last_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
01170                                 <span class="keyword">typename</span> _RAIter::block_type * sorted_last_block = <span class="keyword">new</span> <span class="keyword">typename</span> _RAIter::block_type;
01171                                 request ** reqs = <span class="keyword">new</span> request * [2];
01172                                 
01173                                 last_block-&gt;read(last_bid,reqs[0]);
01174                                 sorted_last_block-&gt;read( ((*out)[out-&gt;size() - 1]).bid,reqs[1]);
01175                                 mc::waitdel_all(reqs,2);
01176                                 
01177                                 <span class="keywordflow">for</span>(i=0;i&lt;__last.block_offset();i++)
01178                                 {
01179                                         last_block-&gt;elem[i] = sorted_last_block-&gt;elem[i];
01180                                 }
01181                                 
01182                                 last_block-&gt;write(last_bid,req);
01183                                 
01184                                 mng-&gt;delete_block((*out)[out-&gt;size() - 1].bid);
01185                                 
01186                                 *__last.bid() = last_bid; 
01187                                 
01188                                 run_type::iterator it = out-&gt;begin();
01189                                 <span class="keyword">typename</span> _RAIter::bids_container_iterator cur_bid = __first.bid();
01190                                 
01191                                 <span class="keywordflow">for</span>(;cur_bid != __last.bid(); cur_bid++,it++)
01192                                 {
01193                                         *cur_bid = (*it).bid;
01194                                 }
01195                                 
01196                                 <span class="keyword">delete</span> sorted_last_block;
01197                                 <span class="keyword">delete</span> [] reqs;
01198                                 <span class="keyword">delete</span> out;
01199                                 
01200                                 req-&gt;wait();
01201                                 <span class="keyword">delete</span> req;
01202                                 
01203                                 <span class="keyword">delete</span> last_block;
01204                         }
01205                         <span class="keywordflow">else</span>
01206                         {
01207                                 <span class="comment">// first and last element resine in the beginning of blocks </span>
01208                                 n = __last.bid() - __first.bid();
01209                                 
01210                                 run_type * out =
01211                                                 ksort_blocks&lt;   <span class="keyword">typename</span> _RAIter::vector_type::value_type,
01212                                                                                                         <span class="keyword">typename</span> _RAIter::bid_type,
01213                                                                                                         <span class="keyword">typename</span> _RAIter::block_type,
01214                                                                                                         <span class="keyword">typename</span> _RAIter::vector_type::alloc_strategy,
01215                                                                                                         <span class="keyword">typename</span> _RAIter::bids_container_iterator &gt;
01216                                                                                                                  (__first.bid(),n,__M/block_type::raw_size);
01217                                 
01218                                 run_type::iterator it = out-&gt;begin();
01219                                 <span class="keyword">typename</span> _RAIter::bids_container_iterator cur_bid = __first.bid();
01220                                 
01221                                 <span class="keywordflow">for</span>(;cur_bid != __last.bid(); cur_bid++,it++)
01222                                 {
01223                                         *cur_bid = (*it).bid;
01224                                 }
01225                                 
01226                         }
01227                 }
01228                 
01229         }
01230 };
01231 
01232 __STXXL_END_NAMESPACE
01233 
01234 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Nov 26 10:56:52 2003 for <stxxl> by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
